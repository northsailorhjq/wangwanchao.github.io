{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/search.xml","path":"search.xml","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/alifather.jpg","path":"images/alifather.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/search.xml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524279772430},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1524274577104},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1524274577105},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1524274577106},{"_id":"themes/next/.gitignore","hash":"b935cc0e5b099ebd343ca1766e02f65138c13dd0","modified":1524274577109},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1524274577110},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1524274577110},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1524274577111},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1524274577112},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1524274577113},{"_id":"themes/next/.travis.yml","hash":"360f38044910e74bf628b0799e19db90718b2cbe","modified":1524274577112},{"_id":"themes/next/README.en.md","hash":"fd7a00ae9026fb4f87dd7eed9ce049d0db447140","modified":1524274577113},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1524274577114},{"_id":"themes/next/bower.json","hash":"63c38f50fb54b25bf5101f566189f9e5b3a6ef0e","modified":1524274577115},{"_id":"themes/next/_config.yml","hash":"660be0d1138ca9f4399a28792c16d516a2c83dfb","modified":1532687515306},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1524274577115},{"_id":"themes/next/package.json","hash":"85a77bafb3d1e958b82e52528b7a95fcd59efda9","modified":1524274577171},{"_id":"source/CNAME","hash":"acd175551321597c7543081c94dfe2a7ee877335","modified":1520326125310},{"_id":"themes/next/.git/HEAD","hash":"75173e2dd18a6221ff84742ff53d01ac5c6e04b0","modified":1524274577091},{"_id":"themes/next/.git/config","hash":"1e06409308d4cbf741f720967697b0352a7f6d0a","modified":1524274523631},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1524274521083},{"_id":"themes/next/.git/index","hash":"e0f85c625766aa32e1073f1f11dfe8badae5e5d1","modified":1524277382506},{"_id":"themes/next/.git/packed-refs","hash":"69237944e31c16fe545d1f47b0b1e5b1d99660da","modified":1524274577083},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1524274577107},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"3178cadcec94bfad651bdf320d83946b4e0ac932","modified":1524274577108},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"55091b1aab0b472d3f3e239c8d93306c751e4c1c","modified":1524274577109},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1524274577173},{"_id":"themes/next/scripts/merge-configs.js","hash":"3ce1be32bb77ee19da25e8dae7dc04e2afc46ca1","modified":1524274577172},{"_id":"themes/next/languages/de.yml","hash":"4be3e7d296d5592e0d111dfa6cbbff02602c972d","modified":1524274577116},{"_id":"themes/next/languages/default.yml","hash":"d912814caac150da1611c96843371a87714e52f9","modified":1524274577117},{"_id":"themes/next/languages/en.yml","hash":"b3ee45143bc014578db6b8ac0573f7c7b143a743","modified":1524274577117},{"_id":"themes/next/languages/fr-FR.yml","hash":"0d5bd8bbbeafb72506124ed35e7509debc753612","modified":1524274577118},{"_id":"themes/next/languages/id.yml","hash":"c0848e93bf33a1333ff232905b6b392b1e056dd1","modified":1524274577118},{"_id":"themes/next/languages/ja.yml","hash":"1a608dc799c0f9c36b626bac6fe3404acb45b86d","modified":1524274577119},{"_id":"themes/next/languages/ko.yml","hash":"5c811514aef401317a9ec38b95679d6d2ef0ad42","modified":1524274577119},{"_id":"themes/next/languages/pt-BR.yml","hash":"cc8b5a67ec87b0d5aec6e253bab67ec3cfe3069c","modified":1524274577120},{"_id":"themes/next/languages/pt.yml","hash":"943475a7d681f37ede579cd62da9c50568ca0f8d","modified":1524274577121},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3111ce4cc5f30868b3628f9f805d2aef3b75d1c1","modified":1524274577122},{"_id":"themes/next/languages/ru.yml","hash":"84d41a111e497236b2c1fa16e9b91668a1f37037","modified":1524274577121},{"_id":"themes/next/languages/zh-tw.yml","hash":"8ce0a32411de111ae39d08e4bc936767dacdeb08","modified":1524274577123},{"_id":"themes/next/languages/zh-hk.yml","hash":"b58c0d85daa4d62b0c9753a59de0739aa0120735","modified":1524274577122},{"_id":"themes/next/layout/_layout.swig","hash":"b88585f9e1b7071f6670b20b77b656edd087ccc9","modified":1524274577125},{"_id":"themes/next/layout/archive.swig","hash":"c2be7c95af6205c7501a261f2fc9702c57107f89","modified":1524274577168},{"_id":"themes/next/layout/page.swig","hash":"dbff0302b4bfabb51556a197bf65190eb30361f0","modified":1524274577169},{"_id":"themes/next/layout/index.swig","hash":"4bf29f44ca9519a005671f2f2a79a48a148b435b","modified":1524274577168},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1524274577168},{"_id":"themes/next/layout/post.swig","hash":"182a99b1f6db0350106c6bb480fede0bbdb7e40f","modified":1524274577169},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1524274577367},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1524274577170},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1524274577170},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1524274577368},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1524274577368},{"_id":"source/_posts/Thirtysomething.md","hash":"b139c78eb48568c0f4cbbeb26da8df08236a8e52","modified":1533741205090},{"_id":"source/_posts/Weekly20180512.md","hash":"ea5f26050afe815fe4e20e142685a9779fa738ca","modified":1526165008217},{"_id":"source/_posts/Weekly20180501.md","hash":"4ada191df78df1835792efa0ddaa91f06930c178","modified":1532501782039},{"_id":"source/_posts/RedisTemplate.md","hash":"f05f461681ac638b1f5074bb62c44ef0c5e73741","modified":1532421718962},{"_id":"source/_posts/cdn-base.md","hash":"079af70d74e9e8539b8c10d36aeb1f7fd2a91ad6","modified":1532686946770},{"_id":"source/_posts/algorithms-1.md","hash":"d496735a16728c6619c74cfca0a7ece9af106b21","modified":1534217235638},{"_id":"source/_posts/class-interface.md","hash":"82267034459b301e2cd07d7c45910f38521d2470","modified":1532421936343},{"_id":"source/_posts/hello-world.md","hash":"f574693470ede355ad860dd7911dac6ad4b0ae80","modified":1533740527206},{"_id":"source/_posts/go-base.md","hash":"842b4662b1947a8d5c62c2f1a8cc891c39a6dda2","modified":1532504238937},{"_id":"source/_posts/java-concurrenthashmap.md","hash":"e83ad41dad42186abff2ee66ba5b4b846fbb4c4b","modified":1534263531656},{"_id":"source/_posts/java-annotation.md","hash":"835160487fb4a7b5735cd26e563c78f2034ce6b7","modified":1534162515301},{"_id":"source/_posts/java-jvm.md","hash":"e18401c5ed6b253a8665d710465d57cdd978098c","modified":1533634293170},{"_id":"source/_posts/java-hashmap.md","hash":"5f9e1fcbbe5bcee6a0c4b1df49e261a2aa803795","modified":1534260922301},{"_id":"source/_posts/java-jvm-cmd.md","hash":"6974b4d25e19f70152d964f5cf75f838ac45713c","modified":1533660955047},{"_id":"source/_posts/java-jvm-gc.md","hash":"03fbd074388abfa7d0563ae60eb906326d3b9022","modified":1533806248704},{"_id":"source/_posts/java-nio.md","hash":"fbf5ee3e8bbafadff081486ff1aee82da547ea98","modified":1534220052504},{"_id":"source/_posts/java-reference.md","hash":"67ecfac7478d522d78465b73674eb2eb1715be62","modified":1534219290909},{"_id":"source/_posts/java-treemap.md","hash":"42b897a35b5f8e854025f9e10048d4c6bd1c7b9c","modified":1534328232730},{"_id":"source/_posts/java-list.md","hash":"b889fef5818934445627e7e64486d3ee069a24c6","modified":1534345089417},{"_id":"source/_posts/javaCrawler.md","hash":"cbbd9aeab8eef0705995f6d39de867aa1195c9b0","modified":1532510512562},{"_id":"source/_posts/mysql-lock.md","hash":"1e6c389a7eaa620086657cc9633cedcbc740d727","modified":1533575071438},{"_id":"source/_posts/mysql-index.md","hash":"2b44d69d48d3607ed9a55dd60cbceaf9f0eb51af","modified":1533634450045},{"_id":"source/_posts/java-threadlocal.md","hash":"76272d44bd2eb46ac02d16e23843c25f772c228f","modified":1533960499183},{"_id":"source/_posts/raspberry-snowboy.md","hash":"0ac5adbe19226a02e022a1d96d74793f684c7ba9","modified":1524743157492},{"_id":"source/_posts/raspberry-facerecognition.md","hash":"9f53f936cc606c955d99ea24f625f006c6e16024","modified":1532512412609},{"_id":"source/_posts/mysql-master-slave.md","hash":"e34c610bdd2a5d6edf9bb8de11e4e76c769fb9ac","modified":1533795248862},{"_id":"source/_posts/raspberry-base.md","hash":"6525a338a80efd8636820acb3530ea57cbc18eb9","modified":1532830057070},{"_id":"source/_posts/spring-ioc.md","hash":"42b574ee4980feb5e1f40043c59f456946043b3e","modified":1534044377851},{"_id":"source/_posts/scala-base.md","hash":"e29bd36ce6efd1837c739c28717bd0cf2daa68fa","modified":1532421697752},{"_id":"source/_posts/spring-design-pattern.md","hash":"3e195860826db2a14cd0c8da1bd1ae64615ce819","modified":1534219279490},{"_id":"source/_posts/spring-bean.md","hash":"2867503ca44af08fa21337f48d8c0d14412492ba","modified":1534173023150},{"_id":"source/_posts/spring-transaction.md","hash":"ff317b3a3ffc2bf4ae2a01c175fcbc5f1f837e5a","modified":1533649955773},{"_id":"source/about/index.md","hash":"e665f772af0dee3f57507c5b464705e98bd0851c","modified":1522737024560},{"_id":"source/_posts/spring-boot-1.md","hash":"244bd0a7691c0b2d1c6552b50672b51e5d912866","modified":1534167231017},{"_id":"source/_posts/thinking-in-today.md","hash":"9c666f2fa9b7e51fe8bc35d20908b99c5198fe3a","modified":1534173168623},{"_id":"source/_posts/thread-1.md","hash":"b52bd0da3ba16eda130b44ae3573317d1ccfefa3","modified":1533571338697},{"_id":"source/_posts/thread-lock.md","hash":"33c7044d8482b5a1a5d2b660dbd0112c1ae43666","modified":1533575334489},{"_id":"source/_posts/thread-pool.md","hash":"9e778c62d8659e800ca270d3d289936036416a1a","modified":1533573016809},{"_id":"source/categories/index.md","hash":"c0ebd711119b66f78a1b81070cbb428d2d67a1bf","modified":1532687676299},{"_id":"source/archive/traveling.md","hash":"9b441691ae49b7a76923dda205906065bb662f44","modified":1523793062202},{"_id":"source/tags/index.md","hash":"b7d52149811fce21f36bda3553aef0cdcd15af8a","modified":1532687873849},{"_id":"source/_posts/thread-15.md","hash":"d7f4f38400965c5981642bd7ae488c4d350c2fda","modified":1533032978726},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524274577254},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1524274521101},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1524274521089},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1524274521092},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1524274521090},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1524274521091},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1524274521093},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1524274521095},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1524274521094},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1524274521097},{"_id":"themes/next/.git/logs/HEAD","hash":"b1aa29a46ee5350713545933c7ddfe4b0ec3e7bb","modified":1524274577091},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1524274521096},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1524274521098},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1524274521099},{"_id":"themes/next/scripts/tags/button.js","hash":"aaf71be6b483fca7a65cd6296c2cf1c2271c26a6","modified":1524274577174},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1524274577175},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1524274577175},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1524274577177},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1524274577176},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1524274577177},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1524274577178},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1524274577179},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1524274577179},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"3072a271be57a878a853545136023df82adae72e","modified":1524278309726},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1524274577124},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"0f59a51b5cea3e8a7c078db486626cddc2978622","modified":1524274577126},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1524274577125},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1524274577128},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1524274577140},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1524274577141},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"f10ca698e8ea0c31ff72a6cffa832c3cd703a133","modified":1524274577128},{"_id":"themes/next/layout/_macro/reward.swig","hash":"5b1e91c2f6f88fbecd426cd0727e7b7854c6cc1d","modified":1524274577127},{"_id":"themes/next/layout/_macro/post.swig","hash":"b6b86a199f5a3692ec492123fe8cb53a8ca08169","modified":1524274577126},{"_id":"themes/next/layout/_partials/footer.swig","hash":"683616f4a80796051e2346d80acf838a589450b0","modified":1524274577130},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"53c894e6f3573c662dc4e4f7b5a6f1a32f1a8c94","modified":1524274577146},{"_id":"themes/next/layout/_partials/comments.swig","hash":"7a229b569743555215a4f2561997ad496d81e938","modified":1524274577129},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1524274577132},{"_id":"themes/next/layout/_partials/header.swig","hash":"d6bf1d1554d91eaf1bfc40ba8905ae81673e5f45","modified":1524274577132},{"_id":"themes/next/layout/_partials/head.swig","hash":"476e6c2452732c2741f518004d336bc348e710d7","modified":1524274577130},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1524274577133},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1524274577133},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1524274577160},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1524274577161},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1524274577160},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1524274577162},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1524274577162},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1524274577162},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1524277319086},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1524274577273},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1524274577273},{"_id":"themes/next/source/images/alifather.jpg","hash":"94ef36383ef88728c3689a5ef87337457cb0696b","modified":1511606670896},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1524274577275},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1524274577274},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1524274577275},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1524274577278},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1524274577277},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1524274577279},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1524274577276},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1524274577278},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1524274577278},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1524274577279},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1524274577280},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1524274577280},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524274577144},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524274577144},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524278540645},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524274577229},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524274577230},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524274577231},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524274577246},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524277075379},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1524274577142},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1524274577143},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1524274577145},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1524274577131},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1524274577132},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1524274577134},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1524274577135},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1524274577135},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1524274577136},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1524274577138},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1524274577137},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1524274577139},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1524274577148},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1524274577147},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1524274577149},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1524274577149},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1524274577150},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1524274577151},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"441f1a1b4e2f652d3b975995bd9d44ff4866f057","modified":1524274577151},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1524274577153},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1524274577153},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1524274577152},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1524274577154},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1524274577155},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1524274577156},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1524274577155},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"be2aaeb8f05979e2ba501248480d5294256d61f2","modified":1524274577157},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1524274577158},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1524274577157},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1524274577159},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1524274577165},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1524274577166},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1524274577165},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1524274577167},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1524274577229},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"bf009e85212749405c27d89b49f401911355ecc7","modified":1524274577230},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1524274577246},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"2a4e844dec690365774c2f6e8984706fee39ea63","modified":1524274577245},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1524274577231},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"89f88b9c9a191dd980f799fc36b83b63290d3ac9","modified":1524274577247},{"_id":"themes/next/source/css/_variables/base.styl","hash":"a627633d3bb70b8501572b18037def478beb7017","modified":1524274577248},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1524274577282},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1524274577281},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1524274577283},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"96c8b5fe1999de1b3a46730d9812787dfcd65884","modified":1524274577282},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1524274577284},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1524274577287},{"_id":"themes/next/source/js/src/motion.js","hash":"dda8c76fce91d7f140c06de2583ba806810f12c2","modified":1524274577285},{"_id":"themes/next/source/js/src/post-details.js","hash":"50fa390554f0fb467d8eb84ac8eff2cffb13fe67","modified":1524274577286},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1524274577285},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1524274577288},{"_id":"themes/next/source/js/src/utils.js","hash":"f90c7611dc665b5e321cb81c0bd689445bab438a","modified":1524274577288},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1524274577297},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1524274577304},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1524274577304},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1524274577301},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"82fee688910efc644d3d1c3305c6ae28ba3f38f9","modified":1524274577303},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1524274577316},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1524274577339},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1524274577318},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1524274577317},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1524274577316},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1524274577353},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1524274577320},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1524274577354},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1524274577320},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1524274577321},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1524274577354},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1524274577321},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1524274577322},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1524274577361},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1524274577361},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1524274577365},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1524274577365},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1524274577366},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1524274577342},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1524274577342},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1524274577344},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1524274577343},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1524274577345},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1524274577346},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1524274577346},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1524274577344},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1524274577347},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1524274577348},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1524274577350},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1524274577348},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1524274577349},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1524274577348},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1524274577349},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1524274577350},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1524274577352},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1524274577351},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1524274577351},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1524274577352},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1524274577341},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1524274577089},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1524274577164},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1524274577164},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1524274577223},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"eec22651977ea25b5e65e8cb1b4906eef69ec588","modified":1524274577224},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1524274577224},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"9a45ed506274f655b11995c408cc566b16dada79","modified":1524274577225},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1524274577226},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1524274577227},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1524274577226},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"a509016ac0227a1903d7f0ca3a825cf9ac7fde33","modified":1524274577232},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1524274577238},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1524274577238},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"f23ac53ab901c48859dd29eee6e386b60ff956ba","modified":1524274577239},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1524274577239},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1524274577240},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1524274577242},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1524274577244},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1524274577242},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1524274577243},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"c48d4a561d047b3705924949b3ab7b57bee94ecd","modified":1524274577244},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1524274577245},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"b0e2a0e27a32f72cb283fe4b33d010d485113379","modified":1524274577181},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1524274577182},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1524274577183},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1524274577183},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1524274577181},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1524274577196},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1524274577213},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1524274577233},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1524274577233},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1524274577234},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1524274577234},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1524274577235},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"ce272226a1570f5f7c70243b751a5b0fe1671a88","modified":1524274577235},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1524274577236},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"c4358416f0a116d7f4037542fa3b385947e80908","modified":1524274577286},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1524274577293},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1524274577305},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1524274577295},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1524274577296},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1524274577306},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1524274577307},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1524274577306},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1524274577308},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1524274577308},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1524274577313},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1524274577314},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1524274577315},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1524274577319},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1524274577318},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1524274577323},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1524274577323},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1524274577324},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1524274577360},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1524274577360},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1524274577294},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1524274577363},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1524274577338},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1524274577339},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"1ab39226a883a7ac15e445bdd41b1ad3eb68905f","modified":1524274577089},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1524274577241},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1524274577184},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1524274577185},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1524274577186},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1524274577187},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1524274577188},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1524274577189},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1524274577192},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1524274577188},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1524274577191},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1524274577192},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"b3b783511bbd94af7e941abf8ff411885db7395b","modified":1524274577190},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1524274577193},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1524274577192},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1524274577194},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1524274577206},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"5f3510419161ec22ca88cce6a181ddad61de9e86","modified":1524274577206},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"ac060861b27b764bc4012fc362a25a332df4045a","modified":1524274577207},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1524274577207},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1524274577208},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1524274577209},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1524274577212},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"28a8737c090fbffd188d73a00b42e90b9ee57df2","modified":1524274577210},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"4783f85872bc7e218c1522a5c1c68cd27a5922db","modified":1524274577196},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1524274577211},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1524274577197},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"8e00d9a0bdf35ffc0a7fa387fa294b953c2d28fc","modified":1524274577212},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1524274577197},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1524274577198},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1524274577196},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"58f9e6aba94733244a87d2ba5966c5a009486509","modified":1524274577198},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1524274577202},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"658accf8e196721f295003da66941e6d1f7b81b0","modified":1524274577199},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1524274577202},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1524274577199},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1524274577203},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"f363a544aa800a2a5ed97c40887fe9743f67b03b","modified":1524274577201},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"2cb09973d29a8e34e2a3425ac6e0938296970d8e","modified":1524274577204},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"268c9704481fdb0b4d1e646196386143990fe235","modified":1524274577204},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"350469437b20ecfd6f3ca45e400478f8e3f71cfb","modified":1524274577203},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1524274577214},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1524274577215},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"3159b55f35c40bd08e55b00148c523760a708c51","modified":1524274577215},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"efc65bba7f2423439e9bca7d32ef7728c21e5c97","modified":1524274577205},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1524274577216},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1524274577214},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1524274577218},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1524274577217},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1524274577217},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1524274577220},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1524274577219},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"962b654f8f7cbd18a298126a403d236ed4540516","modified":1524274577216},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1524274577219},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1524274577221},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1524274577221},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"37e406ec42b7a53c72395bdbaa434270019e7179","modified":1524274577222},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1524274577220},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1524274577222},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1524274577237},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1524274577237},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1524274577290},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1524274577290},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1524274577291},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1524274577292},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1524274577309},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1524274577310},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1524274577311},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1524274577312},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1524274577312},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1524274577313},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1524274577329},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1524274577336},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1524274577327},{"_id":"themes/next/.git/objects/pack/pack-4a376867f92a55cc1eff78dd206b449049df8e30.idx","hash":"5d82e4a6963dfe724c3089c59327e82e9d35f246","modified":1524274576919},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1524274577300},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1524274577358},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1524274577334},{"_id":"themes/next/.git/objects/pack/pack-4a376867f92a55cc1eff78dd206b449049df8e30.pack","hash":"9b960c80f1ec4d36aa534a86efe48883d7046fb8","modified":1524274576958},{"_id":"public/about/index.html","hash":"ca161f2b9d5b2fca778be78323e25da1a5b0f93c","modified":1535342656791},{"_id":"public/archive/traveling.html","hash":"3f73dfa0b5c58aac7e2b6b43b84c8098a9b84acb","modified":1535342656822},{"_id":"public/tags/index.html","hash":"75714cf16205887d74e9f948eac628b1e77958e9","modified":1535342656822},{"_id":"public/categories/index.html","hash":"68902818759b66a910be20fd0d98a0761841fc0a","modified":1535342656822},{"_id":"public/2018/08/15/java-treemap/index.html","hash":"e76d68b180e5f9f736949baabd85fd4c34abc9bd","modified":1535342656823},{"_id":"public/2018/08/15/hello-world/index.html","hash":"d13e46a274f2c09a1c37c80fd978dbdd833d6b11","modified":1535342656823},{"_id":"public/2018/08/14/java-concurrenthashmap/index.html","hash":"3d6c06bbf04702078d9018008f1cb694c266563c","modified":1535342656823},{"_id":"public/2018/08/14/java-nio/index.html","hash":"7308989adb4250a568a591751dae6b0830d0ccb5","modified":1535342656823},{"_id":"public/2018/08/15/java-list/index.html","hash":"2d6b0ef44b88f5b6bd6b4dd92828ed32272ed3fe","modified":1535342656823},{"_id":"public/2018/08/14/algorithms-1/index.html","hash":"534bd3b64c8ae254068f0eb452b3202ca192546a","modified":1535342656823},{"_id":"public/2018/08/13/spring-bean/index.html","hash":"cdc023f7cc5b4459a2e7e2aed4b28a87b8066817","modified":1535342656823},{"_id":"public/2018/08/12/spring-design-pattern/index.html","hash":"3bb1abcb10ade3fb872ebfa527fba4ae3e86e9a3","modified":1535342656824},{"_id":"public/2018/08/11/java-reference/index.html","hash":"fffe0c78ac79a5388086d638d53d4d2b61b4411d","modified":1535342656824},{"_id":"public/2018/08/11/java-threadlocal/index.html","hash":"b0f98a3b6298a45499aab7d0955a9761bfaba010","modified":1535342656824},{"_id":"public/2018/08/13/java-annotation/index.html","hash":"3b5583f9daba3e2c71111e6ea9aefba329dba8a9","modified":1535342656824},{"_id":"public/2018/08/09/java-hashmap/index.html","hash":"8b6b43e751ea49279cf5c5c6ab1cdb1d9edd2d8b","modified":1535342656824},{"_id":"public/2018/08/08/thinking-in-today/index.html","hash":"acd8e806a3a2f6bd4a262b56f290a5cad3e37b52","modified":1535342656824},{"_id":"public/2018/08/08/mysql-master-slave/index.html","hash":"aaa0e7c914c78537ff7c71605d961d5fa7286953","modified":1535342656824},{"_id":"public/2018/08/08/spring-ioc/index.html","hash":"f21ac6781363aac14eee7de5ae1d1996161244c7","modified":1535342656824},{"_id":"public/2018/08/07/java-jvm-cmd/index.html","hash":"ac9167b6c6a321caed12e2ede9ea312a7cf4b5c8","modified":1535342656825},{"_id":"public/2018/08/07/java-jvm-gc/index.html","hash":"dd1615eaaa05dbe356693cd519f13872cb5e1a11","modified":1535342656825},{"_id":"public/2018/08/07/spring-transaction/index.html","hash":"dabb4c9bb56edbf613cc420ff31bda8aef98ba80","modified":1535342656825},{"_id":"public/2018/08/07/java-jvm/index.html","hash":"44e33931f480b6f1ed2c92508cab00c1cc62346d","modified":1535342656825},{"_id":"public/2018/08/07/mysql-lock/index.html","hash":"192c21c5f65d146dd7f76e17a7e9226183ef274e","modified":1535342656825},{"_id":"public/2018/08/07/mysql-index/index.html","hash":"48476d8f0f02de6415cade35ec59904073d79a95","modified":1535342656825},{"_id":"public/2018/08/07/thread-lock/index.html","hash":"b446ae1c9f99a284a7e4f2d0fef97e167aa5045e","modified":1535342656825},{"_id":"public/2018/08/07/thread-pool/index.html","hash":"cbfa27393d767ea100996076a2d2412ee5c58745","modified":1535342656825},{"_id":"public/2018/07/31/thread-15/index.html","hash":"37b91c00d80351269181f41c0f69a0fa15264877","modified":1535342656826},{"_id":"public/2018/07/27/thread-1/index.html","hash":"1df06ae05205f769a4edb57a8c638fb61c684ee8","modified":1535342656826},{"_id":"public/2018/07/27/cdn-base/index.html","hash":"82aab265e2dd6436680233a3f352d814688ebc74","modified":1535342656830},{"_id":"public/2018/07/25/go-base/index.html","hash":"8de6932e2712ab8f5e9f0b0f58b09a648cf06aae","modified":1535342656830},{"_id":"public/2018/07/25/raspberry-facerecognition/index.html","hash":"8a94bd732beef47bd980546be2ff26f5fdc010a5","modified":1535342656831},{"_id":"public/2018/07/24/Thirtysomething/index.html","hash":"ea5c67e40be9b7faa9edd6dad37b27aff1c5d14c","modified":1535342656831},{"_id":"public/2018/07/12/spring-boot-1/index.html","hash":"661ace39305ca1ad6ce115d4abf8a50dba5df30d","modified":1535342656831},{"_id":"public/2018/06/16/RedisTemplate/index.html","hash":"17d9468ba2932450f66417436f60d8bf7082f054","modified":1535342656831},{"_id":"public/2018/05/13/Weekly20180512/index.html","hash":"a3119d53ef3b054e17c0e499e26fb293d810438a","modified":1535342656831},{"_id":"public/2018/05/13/scala-base/index.html","hash":"d61423f454f535a7c8c04f37a10688e77d71817f","modified":1535342656831},{"_id":"public/2018/05/06/Weekly20180501/index.html","hash":"46c617636360327dfbbe343c1c8187baaf83cd15","modified":1535342656831},{"_id":"public/2018/05/06/class-interface/index.html","hash":"884a1a50a3fa51c1e4b4d8035385edac6cb83837","modified":1535342656831},{"_id":"public/2018/04/26/raspberry-snowboy/index.html","hash":"c616278ac3d38a4eea18465bcff63fcc7335d00a","modified":1535342656831},{"_id":"public/2018/04/21/javaCrawler/index.html","hash":"417cce3aea5c78087e95f7165669e2db81069a90","modified":1535342656832},{"_id":"public/2018/04/26/raspberry-base/index.html","hash":"3bd05f5f4b1c757bcb818ebb21daefda856ce5ac","modified":1535342656832},{"_id":"public/archives/index.html","hash":"be646c17693177c7313a38c5f27e54af246f1af8","modified":1535342656832},{"_id":"public/archives/page/2/index.html","hash":"a981517d48bad1436230a04838a1ac47357b418c","modified":1535342656832},{"_id":"public/archives/page/3/index.html","hash":"a50142d24993ac0da2652ce6caa2b9086f387d70","modified":1535342656832},{"_id":"public/archives/page/4/index.html","hash":"2c7c0a4962eb5f159b81e6ee3d044e202e0d9a67","modified":1535342656832},{"_id":"public/archives/2018/index.html","hash":"8ec7fb9bde64b1cee35cc2c7ca60e4c156bfd5ab","modified":1535342656832},{"_id":"public/archives/2018/04/index.html","hash":"47fcd57eb448e5335ba166b7dbcaea536b0c034b","modified":1535342656832},{"_id":"public/archives/2018/page/2/index.html","hash":"ab48c81b588ceee5a50d8e6406a2a847d23d00fb","modified":1535342656832},{"_id":"public/archives/2018/page/3/index.html","hash":"3abf26de360b6a1d5d9bfa0e06cd8c4ec744c622","modified":1535342656833},{"_id":"public/archives/2018/page/4/index.html","hash":"932981d9f80eb7569ab45bbfd5c646611cd1ab57","modified":1535342656833},{"_id":"public/archives/2018/05/index.html","hash":"3dd7ea68a26ff70648fb0f6a3aca68fd4754d090","modified":1535342656833},{"_id":"public/archives/2018/06/index.html","hash":"13ae4b2c7fc169546327ece79a1f7ab3ba177fa9","modified":1535342656833},{"_id":"public/archives/2018/07/index.html","hash":"6494f3badb4d6d107eb000ec033036d8272a1a27","modified":1535342656833},{"_id":"public/categories/life/index.html","hash":"b315820fb3b449d6fbd52ac3c70751ee9eae2052","modified":1535342656833},{"_id":"public/archives/2018/08/index.html","hash":"f2d61322f8e7531df59e5e8be719b49fe11f1776","modified":1535342656833},{"_id":"public/archives/2018/08/page/3/index.html","hash":"ccd457a86621bd57d00e32a881629842c91a063c","modified":1535342656833},{"_id":"public/archives/2018/08/page/2/index.html","hash":"046bdbe017f5d0718e29b6bc75f6eafc09b00f34","modified":1535342656834},{"_id":"public/categories/周报/index.html","hash":"1c5e1998a483a495b440af0fe6b2a129d0301413","modified":1535342656834},{"_id":"public/categories/Go/index.html","hash":"c63aca02bf9dac4252bac93189ddbfa863eab238","modified":1535342656834},{"_id":"public/categories/algorithms/index.html","hash":"d56f3e126dcafd0f54c149360dac999149c95047","modified":1535342656834},{"_id":"public/categories/java/index.html","hash":"62a62a9c5323ec654b749fc9d7aa2f3ebe409337","modified":1535342656834},{"_id":"public/categories/java/page/2/index.html","hash":"6fb831451aee79e413a7418c1cfc1fc9fc571d11","modified":1535342656834},{"_id":"public/categories/mysql/index.html","hash":"b79e92d36b065eb5513b71d698e96e34597dfb93","modified":1535342656834},{"_id":"public/categories/爬虫/index.html","hash":"15e542f2eaa2208a998c11a6ffdf1e63635850da","modified":1535342656834},{"_id":"public/categories/raspberry/index.html","hash":"2d60fabfa9b8b9bfd9f8edf0355705c3570b4c7f","modified":1535342656835},{"_id":"public/categories/Python/index.html","hash":"298490ea2e044c8baf7928265f2da5f254e7a5cc","modified":1535342656835},{"_id":"public/categories/spring/index.html","hash":"fff52aafebf23151579d4b8193c8d533ff7c7069","modified":1535342656835},{"_id":"public/categories/多线程/index.html","hash":"8845708606ccae2657670996dd2c7321ecf919b0","modified":1535342656835},{"_id":"public/tags/life-thirty/index.html","hash":"b1b27ea40a96606bc8bddd6ad483c56739d87d21","modified":1535342656835},{"_id":"public/tags/周报-技术/index.html","hash":"d97d417ff88ab33c4542be6abe298c15ecddd560","modified":1535342656835},{"_id":"public/tags/algorithms-java-go/index.html","hash":"175544c470916080af6bcb27e751d3d54018f0d4","modified":1535342656835},{"_id":"public/tags/语言-go/index.html","hash":"79371ea1457dc18234f7f0384f15b41330c88546","modified":1535342656835},{"_id":"public/tags/java-集合/index.html","hash":"7bca036834322da80df93b907c52f56373b9711b","modified":1535342656835},{"_id":"public/tags/java-annotation/index.html","hash":"4aeb4a8c0c37dcbb227cf04992091b2804dc883e","modified":1535342656836},{"_id":"public/tags/java-jvm/index.html","hash":"ed6827e8a526c3c3a80c6db7d189e736c85142a8","modified":1535342656836},{"_id":"public/tags/mysql-索引/index.html","hash":"e772b262d13725ec894e98f3c6f8a0073f7d76cf","modified":1535342656836},{"_id":"public/tags/java-爬虫/index.html","hash":"e9a7b8aa2826803cee50a70d50e7f0271a825493","modified":1535342656836},{"_id":"public/tags/java-threadlocal/index.html","hash":"e881583f0a927b6b7c8ea13346a0a91261b7cad1","modified":1535342656836},{"_id":"public/tags/树莓派/index.html","hash":"173036e94c9b0803b724009cc9ce56460957e221","modified":1535342656836},{"_id":"public/tags/mysql/index.html","hash":"d572f5776a9a1069cf1e75cce2adab118f9c5b08","modified":1535342656836},{"_id":"public/tags/raspberry-python-人脸识别/index.html","hash":"49dd444364a045b5b3a0e3f4dc887513f8aaa903","modified":1535342656837},{"_id":"public/tags/Scala-函数式编程/index.html","hash":"acddadc0dfe7113bccbc270f2cb205d98abebba3","modified":1535342656837},{"_id":"public/tags/java-spring-ioc/index.html","hash":"8a6be85003e373ad6947d68b360e65559aa67242","modified":1535342656837},{"_id":"public/tags/java/index.html","hash":"2951f7665742b540335de7af92fa08be0ce1c71b","modified":1535342656837},{"_id":"public/tags/spring-事务/index.html","hash":"990e7b7653c2177761aebfebc899e7136130d02e","modified":1535342656837},{"_id":"public/tags/java-springboot-源码/index.html","hash":"a4d6c515ff374fb810b0a3042070de46ddcf5e10","modified":1535342656837},{"_id":"public/tags/java-多线程/index.html","hash":"62b6a1b4086dd9f44493cf8f1798684c1c4ae835","modified":1535342656837},{"_id":"public/index.html","hash":"2913ed799945c40e20ea1977fbd16f7a88e94230","modified":1535342656837},{"_id":"public/tags/life-reading/index.html","hash":"d6ccf4d183d166d797a0533c0b80f5e04681df4f","modified":1535342656838},{"_id":"public/page/2/index.html","hash":"0f9a4263d5ce3d460751a0645dc790c15e4268a9","modified":1535342656838},{"_id":"public/page/3/index.html","hash":"bc5cd4fb8f580cc0cff76016b4d13e7da35db202","modified":1535342656838},{"_id":"public/page/4/index.html","hash":"e6ae6c9e8ab45a436b799bf64487f7923d3f7520","modified":1535342656838},{"_id":"public/search.xml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535342656847},{"_id":"public/CNAME","hash":"acd175551321597c7543081c94dfe2a7ee877335","modified":1535342656854},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1535342656854},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1535342656854},{"_id":"public/images/alifather.jpg","hash":"94ef36383ef88728c3689a5ef87337457cb0696b","modified":1535342656855},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1535342656855},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1535342656855},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1535342656855},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1535342656855},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1535342656855},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1535342656855},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1535342656855},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1535342656856},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1535342656856},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1535342656856},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1535342656856},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1535342656856},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1535342656856},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1535342656856},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1535342656857},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1535342656857},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1535342656857},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1535342656857},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1535342656857},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1535342656857},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1535342656858},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1535342656858},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1535342656858},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1535342656858},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1535342656858},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1535342656858},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1535342657711},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1535342657712},{"_id":"public/js/src/bootstrap.js","hash":"6117f97b4984b8e33f21c726132da64ba678e4ed","modified":1535342657725},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1535342657725},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1535342657725},{"_id":"public/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1535342657725},{"_id":"public/js/src/motion.js","hash":"dc0365b2fb315a8b43d3ef19b59d3a82a366fcc1","modified":1535342657725},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1535342657725},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1535342657725},{"_id":"public/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1535342657725},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1535342657725},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1535342657725},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1535342657725},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1535342657726},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1535342657726},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1535342657726},{"_id":"public/css/main.css","hash":"b9390bd8f7994eccc0bc9ca5396644900f3fa509","modified":1535342657726},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1535342657726},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1535342657726},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1535342657737},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1535342657737},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1535342657738},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1535342657738},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1535342657738},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1535342657738},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1535342657738},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1535342657738},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1535342657738},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1535342657738},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1535342657738},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1535342657739},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1535342657739},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1535342657739},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1535342657739},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1535342657739},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1535342657739},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1535342657739},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1535342657740},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1535342657740},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1535342657740},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1535342657740},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1535342657740},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1535342657740},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1535342657740},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1535342657740},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1535342657740},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1535342657741},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1535342657741},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1535342657741},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1535342657741},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1535342657741},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1535342657741},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1535342657741},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1535342657741},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1535342657741},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1535342657741},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1535342657742},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1535342657742},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1535342657742},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1535342657742},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1535342657742},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1535342657742},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1535342657742},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1535342657742},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1535342657743},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1535342657743},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1535342657743},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1535342657743},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1535342657743},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1535342657744},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1535342657744},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1535342657744},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1535342657759}],"Category":[{"name":"life","_id":"cjlbrddzg0004v0f055tozbek"},{"name":"周报","_id":"cjlbrde08000ev0f0u5zh5jei"},{"name":"algorithms","_id":"cjlbrde0m000lv0f00avexqz1"},{"name":"Go","_id":"cjlbrde0u000rv0f0ue9c8y7b"},{"name":"java","_id":"cjlbrde10000xv0f06mx5cnuf"},{"name":"mysql","_id":"cjlbrde1z001qv0f0n3vq6qdk"},{"name":"爬虫","_id":"cjlbrde28001xv0f041ygreno"},{"name":"raspberry","_id":"cjlbrde2f0024v0f0gag2pbjn"},{"name":"Python","_id":"cjlbrde2r002av0f0nyxov0lq"},{"name":"spring","_id":"cjlbrde32002kv0f0eo9bz0i9"},{"name":"多线程","_id":"cjlbrde3q0033v0f0i6yp4k4m"}],"Data":[],"Page":[{"title":"一个写后端的程序员","date":"2018-04-03T10:08:11.000Z","_content":"从2014可以折腾博客，先是在博客园，然后觉得博客园写博客太麻烦，又转到Octopress,换了电脑，Octopress又要折腾，依赖于Ruby环境，总是出问题，怒而转至Hexo。从此常驻Hexo\n\n* 技术信仰\n\t> 主要是Java栈\n\t> \n\t> 爱好Go系列语言\n\t> \n\t> 也写点Scala\n  \n* 生活爱好\n\t> 喜欢音乐，正在练习吉他\n\n\t> 爱好骑行、旅行，希望去更多的地方\n\n\t> 也读一些乱七八糟的书，写代码后读的书越来越少了\n\n希望自己以后能多输出一些博客，为技术努力搬砖！","source":"about/index.md","raw":"---\ntitle: 一个写后端的程序员\ndate: 2018-04-03 18:08:11\n---\n从2014可以折腾博客，先是在博客园，然后觉得博客园写博客太麻烦，又转到Octopress,换了电脑，Octopress又要折腾，依赖于Ruby环境，总是出问题，怒而转至Hexo。从此常驻Hexo\n\n* 技术信仰\n\t> 主要是Java栈\n\t> \n\t> 爱好Go系列语言\n\t> \n\t> 也写点Scala\n  \n* 生活爱好\n\t> 喜欢音乐，正在练习吉他\n\n\t> 爱好骑行、旅行，希望去更多的地方\n\n\t> 也读一些乱七八糟的书，写代码后读的书越来越少了\n\n希望自己以后能多输出一些博客，为技术努力搬砖！","updated":"2018-04-03T06:30:24.560Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjlbrddz80001v0f03zxc15uu","content":"<p>从2014可以折腾博客，先是在博客园，然后觉得博客园写博客太麻烦，又转到Octopress,换了电脑，Octopress又要折腾，依赖于Ruby环境，总是出问题，怒而转至Hexo。从此常驻Hexo</p>\n<ul>\n<li><p>技术信仰</p>\n<blockquote>\n<p>主要是Java栈</p>\n<p>爱好Go系列语言</p>\n<p>也写点Scala</p>\n</blockquote>\n</li>\n<li><p>生活爱好</p>\n<blockquote>\n<p>喜欢音乐，正在练习吉他</p>\n</blockquote>\n<blockquote>\n<p>爱好骑行、旅行，希望去更多的地方</p>\n</blockquote>\n<blockquote>\n<p>也读一些乱七八糟的书，写代码后读的书越来越少了</p>\n</blockquote>\n</li>\n</ul>\n<p>希望自己以后能多输出一些博客，为技术努力搬砖！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>从2014可以折腾博客，先是在博客园，然后觉得博客园写博客太麻烦，又转到Octopress,换了电脑，Octopress又要折腾，依赖于Ruby环境，总是出问题，怒而转至Hexo。从此常驻Hexo</p>\n<ul>\n<li><p>技术信仰</p>\n<blockquote>\n<p>主要是Java栈</p>\n<p>爱好Go系列语言</p>\n<p>也写点Scala</p>\n</blockquote>\n</li>\n<li><p>生活爱好</p>\n<blockquote>\n<p>喜欢音乐，正在练习吉他</p>\n</blockquote>\n<blockquote>\n<p>爱好骑行、旅行，希望去更多的地方</p>\n</blockquote>\n<blockquote>\n<p>也读一些乱七八糟的书，写代码后读的书越来越少了</p>\n</blockquote>\n</li>\n</ul>\n<p>希望自己以后能多输出一些博客，为技术努力搬砖！</p>\n"},{"title":"categories","date":"2018-07-27T10:33:32.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-07-27 18:33:32\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-07-27T10:34:36.299Z","path":"categories/index.html","layout":"page","_id":"cjlbrddze0003v0f0rf951ugv","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"subpost","title":"traveling","date":"2018-04-15T10:35:52.000Z","tags":null,"_content":"\n###CQ bail options data ccc\n","source":"archive/traveling.md","raw":"---\nlayout: subpost\ntitle: traveling\ndate: 2018-04-15 18:35:52\ntags:\n---\n\n###CQ bail options data ccc\n","updated":"2018-04-15T11:51:02.202Z","path":"archive/traveling.html","comments":1,"_id":"cjlbrddzq0007v0f0y54grvu5","content":"<p>###CQ bail options data ccc</p>\n","site":{"data":{}},"excerpt":"","more":"<p>###CQ bail options data ccc</p>\n"},{"title":"tags","date":"2018-07-27T10:37:16.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-07-27 18:37:16\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-07-27T10:37:53.849Z","path":"tags/index.html","layout":"page","_id":"cjlbrddzw0009v0f0d2qsyq9y","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"三十而立(Thirtysomething)","date":"2018-07-24T07:29:55.000Z","_content":"虽说不是三十，却也是即将奔三。\n   \n2018年2月份的时候离开上家公司，当初胸怀大志，希望出来能在一个更好的平台上施展一番。如今已经过去四之三，却感觉收获寥寥无几。其实这半年经历了很多的事情，也想了很多很多的东西：关于爱情，关于工作，关于生活。正好最近空闲下来，好好整理下自己，也整理一下生活。\n\n<!-- more -->\n\n### 爱情 ###\n\n一塌糊涂的爱情，和她见过最后一面，吃过最后一顿饭，走过最后一段，我想，也许我还没有放下，但生活总要继续。过年去姑姑家拜年的时候，也是各种被劝说，一直以来自己也想了很多，但是缘分这种事情，也是急不来的。从《不能承受的生命之轻》到《霍乱时期的爱情》，爱情观被不断的冲击，最近开始让自己静下来，遇到真正合适的再义无反顾的去争取吧。\n\n### 工作 ###\n\n三月份来到新的公司，项目组是新组建的，管理上一塌糊涂，哎。对写代码的热情被慢慢的消耗，很多时候我都在想，什么才是有意义的工作，怎样才能发挥自己最大的价值，究竟该选择什么方向努力。希望能尽快步入正轨吧。\n\n### 生活 ###\n\n四月份飞了重庆，当初说好带她去重庆的，结果是自己一个人去，中间在三生有信还看到一个女生一边抹着眼泪，一边给某人写着寄语。\n\n五月份第一次远程骑行到十三陵，摔了膝盖疼了好几天，骑行中间还突然下了一场雨，感觉好狼狈，由于没有远程骑行经验，中间轮子还掉了两次。。。最后终于在十一点多回家，累到倒床就睡。\n\n上周末搬了家，终于从一个“北京村”，搬到了另一个“北京村”，好在新的“村”是个小区，虽然环境不是那么理想，但终于脱离了那种杂乱的环境，为了再接再厉吧！\n\n今年可以说是熬夜最多的一年，更多的还是因为生活中一些不如意的事情吧。有些时候我是一个很情绪化的人，遇到一些苦恼的事情，就会像很多很多，最后一觉醒来，也就没那么多烦恼。前一段时间，终于狠心办了张健身卡，终于第一次去健身房，想想也是自 工作以来，很少去健身房锻炼了，以后还是要规律饮食，勤去健身房才好。\n\n### 阅读 ###\n\n《人类简史》 终于完结了一下，真的是从2017年读到2018年，拖延症太可怕\n\n《黑客与画家》 思想论的东西，和写代码有关，不得不佩服格雷厄姆思想的深刻，毕竟是硅谷创业之父啊\n\n《引爆点》 有点心理学的意味，大多是在地铁上读完的，其实生活中很多的行为都是被潜移默化的影响\n\n《商业的本质》 管理学，大师的作品，正好自己也有兴趣，正好就在地铁上完成吧\n\n《小王子》 重读了一遍，还是有很多不同的感受\n\n《无比无杂的心绪》 很符合今年上半年的心绪，又是偶然发现，村上村树的作品，写的很深刻，直入内心的触动，需要多读几遍\n\n《独居的一年》 感觉有昆德拉的影子在里面，正在读\n\n  \n距离2019年还有五个月的时间，希望自己能在不断的思考中，更成熟、更深刻、更充实。\n","source":"_posts/Thirtysomething.md","raw":"---\ntitle: 三十而立(Thirtysomething)\ndate: 2018-07-24 15:29:55\ntags: life, thirty\ncategories: life\n---\n虽说不是三十，却也是即将奔三。\n   \n2018年2月份的时候离开上家公司，当初胸怀大志，希望出来能在一个更好的平台上施展一番。如今已经过去四之三，却感觉收获寥寥无几。其实这半年经历了很多的事情，也想了很多很多的东西：关于爱情，关于工作，关于生活。正好最近空闲下来，好好整理下自己，也整理一下生活。\n\n<!-- more -->\n\n### 爱情 ###\n\n一塌糊涂的爱情，和她见过最后一面，吃过最后一顿饭，走过最后一段，我想，也许我还没有放下，但生活总要继续。过年去姑姑家拜年的时候，也是各种被劝说，一直以来自己也想了很多，但是缘分这种事情，也是急不来的。从《不能承受的生命之轻》到《霍乱时期的爱情》，爱情观被不断的冲击，最近开始让自己静下来，遇到真正合适的再义无反顾的去争取吧。\n\n### 工作 ###\n\n三月份来到新的公司，项目组是新组建的，管理上一塌糊涂，哎。对写代码的热情被慢慢的消耗，很多时候我都在想，什么才是有意义的工作，怎样才能发挥自己最大的价值，究竟该选择什么方向努力。希望能尽快步入正轨吧。\n\n### 生活 ###\n\n四月份飞了重庆，当初说好带她去重庆的，结果是自己一个人去，中间在三生有信还看到一个女生一边抹着眼泪，一边给某人写着寄语。\n\n五月份第一次远程骑行到十三陵，摔了膝盖疼了好几天，骑行中间还突然下了一场雨，感觉好狼狈，由于没有远程骑行经验，中间轮子还掉了两次。。。最后终于在十一点多回家，累到倒床就睡。\n\n上周末搬了家，终于从一个“北京村”，搬到了另一个“北京村”，好在新的“村”是个小区，虽然环境不是那么理想，但终于脱离了那种杂乱的环境，为了再接再厉吧！\n\n今年可以说是熬夜最多的一年，更多的还是因为生活中一些不如意的事情吧。有些时候我是一个很情绪化的人，遇到一些苦恼的事情，就会像很多很多，最后一觉醒来，也就没那么多烦恼。前一段时间，终于狠心办了张健身卡，终于第一次去健身房，想想也是自 工作以来，很少去健身房锻炼了，以后还是要规律饮食，勤去健身房才好。\n\n### 阅读 ###\n\n《人类简史》 终于完结了一下，真的是从2017年读到2018年，拖延症太可怕\n\n《黑客与画家》 思想论的东西，和写代码有关，不得不佩服格雷厄姆思想的深刻，毕竟是硅谷创业之父啊\n\n《引爆点》 有点心理学的意味，大多是在地铁上读完的，其实生活中很多的行为都是被潜移默化的影响\n\n《商业的本质》 管理学，大师的作品，正好自己也有兴趣，正好就在地铁上完成吧\n\n《小王子》 重读了一遍，还是有很多不同的感受\n\n《无比无杂的心绪》 很符合今年上半年的心绪，又是偶然发现，村上村树的作品，写的很深刻，直入内心的触动，需要多读几遍\n\n《独居的一年》 感觉有昆德拉的影子在里面，正在读\n\n  \n距离2019年还有五个月的时间，希望自己能在不断的思考中，更成熟、更深刻、更充实。\n","slug":"Thirtysomething","published":1,"updated":"2018-08-08T15:13:25.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrddyz0000v0f0b1nlcobc","content":"<p>虽说不是三十，却也是即将奔三。</p>\n<p>2018年2月份的时候离开上家公司，当初胸怀大志，希望出来能在一个更好的平台上施展一番。如今已经过去四之三，却感觉收获寥寥无几。其实这半年经历了很多的事情，也想了很多很多的东西：关于爱情，关于工作，关于生活。正好最近空闲下来，好好整理下自己，也整理一下生活。</p>\n<a id=\"more\"></a>\n<h3 id=\"爱情\"><a href=\"#爱情\" class=\"headerlink\" title=\"爱情\"></a>爱情</h3><p>一塌糊涂的爱情，和她见过最后一面，吃过最后一顿饭，走过最后一段，我想，也许我还没有放下，但生活总要继续。过年去姑姑家拜年的时候，也是各种被劝说，一直以来自己也想了很多，但是缘分这种事情，也是急不来的。从《不能承受的生命之轻》到《霍乱时期的爱情》，爱情观被不断的冲击，最近开始让自己静下来，遇到真正合适的再义无反顾的去争取吧。</p>\n<h3 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h3><p>三月份来到新的公司，项目组是新组建的，管理上一塌糊涂，哎。对写代码的热情被慢慢的消耗，很多时候我都在想，什么才是有意义的工作，怎样才能发挥自己最大的价值，究竟该选择什么方向努力。希望能尽快步入正轨吧。</p>\n<h3 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h3><p>四月份飞了重庆，当初说好带她去重庆的，结果是自己一个人去，中间在三生有信还看到一个女生一边抹着眼泪，一边给某人写着寄语。</p>\n<p>五月份第一次远程骑行到十三陵，摔了膝盖疼了好几天，骑行中间还突然下了一场雨，感觉好狼狈，由于没有远程骑行经验，中间轮子还掉了两次。。。最后终于在十一点多回家，累到倒床就睡。</p>\n<p>上周末搬了家，终于从一个“北京村”，搬到了另一个“北京村”，好在新的“村”是个小区，虽然环境不是那么理想，但终于脱离了那种杂乱的环境，为了再接再厉吧！</p>\n<p>今年可以说是熬夜最多的一年，更多的还是因为生活中一些不如意的事情吧。有些时候我是一个很情绪化的人，遇到一些苦恼的事情，就会像很多很多，最后一觉醒来，也就没那么多烦恼。前一段时间，终于狠心办了张健身卡，终于第一次去健身房，想想也是自 工作以来，很少去健身房锻炼了，以后还是要规律饮食，勤去健身房才好。</p>\n<h3 id=\"阅读\"><a href=\"#阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读</h3><p>《人类简史》 终于完结了一下，真的是从2017年读到2018年，拖延症太可怕</p>\n<p>《黑客与画家》 思想论的东西，和写代码有关，不得不佩服格雷厄姆思想的深刻，毕竟是硅谷创业之父啊</p>\n<p>《引爆点》 有点心理学的意味，大多是在地铁上读完的，其实生活中很多的行为都是被潜移默化的影响</p>\n<p>《商业的本质》 管理学，大师的作品，正好自己也有兴趣，正好就在地铁上完成吧</p>\n<p>《小王子》 重读了一遍，还是有很多不同的感受</p>\n<p>《无比无杂的心绪》 很符合今年上半年的心绪，又是偶然发现，村上村树的作品，写的很深刻，直入内心的触动，需要多读几遍</p>\n<p>《独居的一年》 感觉有昆德拉的影子在里面，正在读</p>\n<p>距离2019年还有五个月的时间，希望自己能在不断的思考中，更成熟、更深刻、更充实。</p>\n","site":{"data":{}},"excerpt":"<p>虽说不是三十，却也是即将奔三。</p>\n<p>2018年2月份的时候离开上家公司，当初胸怀大志，希望出来能在一个更好的平台上施展一番。如今已经过去四之三，却感觉收获寥寥无几。其实这半年经历了很多的事情，也想了很多很多的东西：关于爱情，关于工作，关于生活。正好最近空闲下来，好好整理下自己，也整理一下生活。</p>","more":"<h3 id=\"爱情\"><a href=\"#爱情\" class=\"headerlink\" title=\"爱情\"></a>爱情</h3><p>一塌糊涂的爱情，和她见过最后一面，吃过最后一顿饭，走过最后一段，我想，也许我还没有放下，但生活总要继续。过年去姑姑家拜年的时候，也是各种被劝说，一直以来自己也想了很多，但是缘分这种事情，也是急不来的。从《不能承受的生命之轻》到《霍乱时期的爱情》，爱情观被不断的冲击，最近开始让自己静下来，遇到真正合适的再义无反顾的去争取吧。</p>\n<h3 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h3><p>三月份来到新的公司，项目组是新组建的，管理上一塌糊涂，哎。对写代码的热情被慢慢的消耗，很多时候我都在想，什么才是有意义的工作，怎样才能发挥自己最大的价值，究竟该选择什么方向努力。希望能尽快步入正轨吧。</p>\n<h3 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h3><p>四月份飞了重庆，当初说好带她去重庆的，结果是自己一个人去，中间在三生有信还看到一个女生一边抹着眼泪，一边给某人写着寄语。</p>\n<p>五月份第一次远程骑行到十三陵，摔了膝盖疼了好几天，骑行中间还突然下了一场雨，感觉好狼狈，由于没有远程骑行经验，中间轮子还掉了两次。。。最后终于在十一点多回家，累到倒床就睡。</p>\n<p>上周末搬了家，终于从一个“北京村”，搬到了另一个“北京村”，好在新的“村”是个小区，虽然环境不是那么理想，但终于脱离了那种杂乱的环境，为了再接再厉吧！</p>\n<p>今年可以说是熬夜最多的一年，更多的还是因为生活中一些不如意的事情吧。有些时候我是一个很情绪化的人，遇到一些苦恼的事情，就会像很多很多，最后一觉醒来，也就没那么多烦恼。前一段时间，终于狠心办了张健身卡，终于第一次去健身房，想想也是自 工作以来，很少去健身房锻炼了，以后还是要规律饮食，勤去健身房才好。</p>\n<h3 id=\"阅读\"><a href=\"#阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读</h3><p>《人类简史》 终于完结了一下，真的是从2017年读到2018年，拖延症太可怕</p>\n<p>《黑客与画家》 思想论的东西，和写代码有关，不得不佩服格雷厄姆思想的深刻，毕竟是硅谷创业之父啊</p>\n<p>《引爆点》 有点心理学的意味，大多是在地铁上读完的，其实生活中很多的行为都是被潜移默化的影响</p>\n<p>《商业的本质》 管理学，大师的作品，正好自己也有兴趣，正好就在地铁上完成吧</p>\n<p>《小王子》 重读了一遍，还是有很多不同的感受</p>\n<p>《无比无杂的心绪》 很符合今年上半年的心绪，又是偶然发现，村上村树的作品，写的很深刻，直入内心的触动，需要多读几遍</p>\n<p>《独居的一年》 感觉有昆德拉的影子在里面，正在读</p>\n<p>距离2019年还有五个月的时间，希望自己能在不断的思考中，更成熟、更深刻、更充实。</p>"},{"title":"周报20180512","date":"2018-05-12T22:28:24.000Z","_content":"\n1、NGINX发布支持动态配置的开源Web服务器NGINX Unit 1.0版，可运行Go、Python、PHP多种语言\n\n\n2、Java性能监控调试工具JMC(java mission control)宣布开源\n\n\n\n3、","source":"_posts/Weekly20180512.md","raw":"---\ntitle: 周报20180512\ndate: 2018-05-13 06:28:24\ntags: 周报, 技术\n---\n\n1、NGINX发布支持动态配置的开源Web服务器NGINX Unit 1.0版，可运行Go、Python、PHP多种语言\n\n\n2、Java性能监控调试工具JMC(java mission control)宣布开源\n\n\n\n3、","slug":"Weekly20180512","published":1,"updated":"2018-05-12T22:43:28.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrddzb0002v0f0ocvl25n1","content":"<p>1、NGINX发布支持动态配置的开源Web服务器NGINX Unit 1.0版，可运行Go、Python、PHP多种语言</p>\n<p>2、Java性能监控调试工具JMC(java mission control)宣布开源</p>\n<p>3、</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1、NGINX发布支持动态配置的开源Web服务器NGINX Unit 1.0版，可运行Go、Python、PHP多种语言</p>\n<p>2、Java性能监控调试工具JMC(java mission control)宣布开源</p>\n<p>3、</p>\n"},{"title":"RedisTemplate","date":"2018-06-16T02:06:06.000Z","_content":"Spring Data Redis(SDR) 2.x\n需要JDK8+、Spring Framework5.0.7+、Redis2.6.x\n\n2、整合了Lettuce和Jedis两个开源库\n\n3、高可见性\n\n可以直接使用底层(本地库)直接连接Redis\n\nRedisConnection\n可以传递底层链接库异常到Spring持久化层DAO层，\n\n使用RedisConnectionFactory创建RedisConncection,RedisConnectionFactory继承PersistenceExceptionTranslator对象，意味着异常操作对RedisConnectionFactory更透明化。\n\n目前并不是所有的SDR特性都被connector开源库支持，使用不支持的特性会抛出\nUnsupportedOperationException异常。\n\n<!-- more -->\n\n二、Lettuce\nLettuce是基于Netty的连接器\n\n1、默认情况下，所有的LettuceConnection被LettuceConnectionFactory创建，它们共享一个线程安全的本地连接执行非阻塞、非事务性操作。\n\n2、LettuceConnectionFactory可以通过配置使用LettucePool\n\n3、LettuceConnectionFactory通过设置shareNativeConnection=false使用事务性连接\n\n三、Jedis\n\n四、RedisTemplate\n1、提供了更高层的抽象，更关注序列化、连接的管理。\nRedisConnection则提供了底层方法可以操作二进制数据。\n\n2、一旦被配置，则是线程安全的，可以被多个实例重用，\n\n3、默认基于Java原生序列类进行序列化，则所有的对象读写都是经过序列化和反序列化的。SDR在org.springframework.data.redis.serializer包内提供了一些其它的序列化实现类。可以通过设置所有的序列器为null同时设置enableDefaultSerializer=false。\n***注意：RedisTemplate要求所有的属性key不能为空，value可以为空***\n\n特殊的String操作：\nStringRedisConnection\nStringRedisTemplate\nStringRedisSerializer\n\n两种serializers都基于RedisSerializer\nElement读写使用RedisElementReader、RedisElementWriter\nRedisCache和RedisTemplate默认使用JdkSerializationRedisSerializer\n\nOxmSerializer用于基于Object/XML mapping\n\nJackson2JsonRedisSerializer / GenericJackson2JsonRedisSerializer用于json格式数据\n\n***如果安全更重要，可以考虑在JVM层使用特殊的filter机制***\n\n使用Redis Hash可以存储更复杂的结构化对象：\n(1)HashOperations + serializer\n(2)Redis Repositories\n(3)HashMapper + HashOperations\nBeanUtilsHashMapper\n\nObjectHashMapper\n\nJackson2HashMapper\n\n\n五、Reactive Redis(异步)\nReactiveRedisConnection\n\nReactiveRedisTemplate\n\n\n六、Redis Cluster\nRedisClusterConnection继承RedisConnection，通过RedisConnectionFactory创建，RedisClusterFactory配置属性\n\nredisTemplate.opsForCluster();\n\n\n七、Redis Repository\n\n要求：Redis Server2.8.0+\n\nCrudRepository\n\nRedisConverter\n\nTTL\n\nKeySpaces\n\n@Reference注解\n\nCDI Integration\n\n\n\n","source":"_posts/RedisTemplate.md","raw":"---\ntitle: RedisTemplate\ndate: 2018-06-16 10:06:06\ntags:\n---\nSpring Data Redis(SDR) 2.x\n需要JDK8+、Spring Framework5.0.7+、Redis2.6.x\n\n2、整合了Lettuce和Jedis两个开源库\n\n3、高可见性\n\n可以直接使用底层(本地库)直接连接Redis\n\nRedisConnection\n可以传递底层链接库异常到Spring持久化层DAO层，\n\n使用RedisConnectionFactory创建RedisConncection,RedisConnectionFactory继承PersistenceExceptionTranslator对象，意味着异常操作对RedisConnectionFactory更透明化。\n\n目前并不是所有的SDR特性都被connector开源库支持，使用不支持的特性会抛出\nUnsupportedOperationException异常。\n\n<!-- more -->\n\n二、Lettuce\nLettuce是基于Netty的连接器\n\n1、默认情况下，所有的LettuceConnection被LettuceConnectionFactory创建，它们共享一个线程安全的本地连接执行非阻塞、非事务性操作。\n\n2、LettuceConnectionFactory可以通过配置使用LettucePool\n\n3、LettuceConnectionFactory通过设置shareNativeConnection=false使用事务性连接\n\n三、Jedis\n\n四、RedisTemplate\n1、提供了更高层的抽象，更关注序列化、连接的管理。\nRedisConnection则提供了底层方法可以操作二进制数据。\n\n2、一旦被配置，则是线程安全的，可以被多个实例重用，\n\n3、默认基于Java原生序列类进行序列化，则所有的对象读写都是经过序列化和反序列化的。SDR在org.springframework.data.redis.serializer包内提供了一些其它的序列化实现类。可以通过设置所有的序列器为null同时设置enableDefaultSerializer=false。\n***注意：RedisTemplate要求所有的属性key不能为空，value可以为空***\n\n特殊的String操作：\nStringRedisConnection\nStringRedisTemplate\nStringRedisSerializer\n\n两种serializers都基于RedisSerializer\nElement读写使用RedisElementReader、RedisElementWriter\nRedisCache和RedisTemplate默认使用JdkSerializationRedisSerializer\n\nOxmSerializer用于基于Object/XML mapping\n\nJackson2JsonRedisSerializer / GenericJackson2JsonRedisSerializer用于json格式数据\n\n***如果安全更重要，可以考虑在JVM层使用特殊的filter机制***\n\n使用Redis Hash可以存储更复杂的结构化对象：\n(1)HashOperations + serializer\n(2)Redis Repositories\n(3)HashMapper + HashOperations\nBeanUtilsHashMapper\n\nObjectHashMapper\n\nJackson2HashMapper\n\n\n五、Reactive Redis(异步)\nReactiveRedisConnection\n\nReactiveRedisTemplate\n\n\n六、Redis Cluster\nRedisClusterConnection继承RedisConnection，通过RedisConnectionFactory创建，RedisClusterFactory配置属性\n\nredisTemplate.opsForCluster();\n\n\n七、Redis Repository\n\n要求：Redis Server2.8.0+\n\nCrudRepository\n\nRedisConverter\n\nTTL\n\nKeySpaces\n\n@Reference注解\n\nCDI Integration\n\n\n\n","slug":"RedisTemplate","published":1,"updated":"2018-07-24T08:41:58.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrddzo0006v0f04xe0on42","content":"<p>Spring Data Redis(SDR) 2.x<br>需要JDK8+、Spring Framework5.0.7+、Redis2.6.x</p>\n<p>2、整合了Lettuce和Jedis两个开源库</p>\n<p>3、高可见性</p>\n<p>可以直接使用底层(本地库)直接连接Redis</p>\n<p>RedisConnection<br>可以传递底层链接库异常到Spring持久化层DAO层，</p>\n<p>使用RedisConnectionFactory创建RedisConncection,RedisConnectionFactory继承PersistenceExceptionTranslator对象，意味着异常操作对RedisConnectionFactory更透明化。</p>\n<p>目前并不是所有的SDR特性都被connector开源库支持，使用不支持的特性会抛出<br>UnsupportedOperationException异常。</p>\n<a id=\"more\"></a>\n<p>二、Lettuce<br>Lettuce是基于Netty的连接器</p>\n<p>1、默认情况下，所有的LettuceConnection被LettuceConnectionFactory创建，它们共享一个线程安全的本地连接执行非阻塞、非事务性操作。</p>\n<p>2、LettuceConnectionFactory可以通过配置使用LettucePool</p>\n<p>3、LettuceConnectionFactory通过设置shareNativeConnection=false使用事务性连接</p>\n<p>三、Jedis</p>\n<p>四、RedisTemplate<br>1、提供了更高层的抽象，更关注序列化、连接的管理。<br>RedisConnection则提供了底层方法可以操作二进制数据。</p>\n<p>2、一旦被配置，则是线程安全的，可以被多个实例重用，</p>\n<p>3、默认基于Java原生序列类进行序列化，则所有的对象读写都是经过序列化和反序列化的。SDR在org.springframework.data.redis.serializer包内提供了一些其它的序列化实现类。可以通过设置所有的序列器为null同时设置enableDefaultSerializer=false。<br><strong><em>注意：RedisTemplate要求所有的属性key不能为空，value可以为空</em></strong></p>\n<p>特殊的String操作：<br>StringRedisConnection<br>StringRedisTemplate<br>StringRedisSerializer</p>\n<p>两种serializers都基于RedisSerializer<br>Element读写使用RedisElementReader、RedisElementWriter<br>RedisCache和RedisTemplate默认使用JdkSerializationRedisSerializer</p>\n<p>OxmSerializer用于基于Object/XML mapping</p>\n<p>Jackson2JsonRedisSerializer / GenericJackson2JsonRedisSerializer用于json格式数据</p>\n<p><strong><em>如果安全更重要，可以考虑在JVM层使用特殊的filter机制</em></strong></p>\n<p>使用Redis Hash可以存储更复杂的结构化对象：<br>(1)HashOperations + serializer<br>(2)Redis Repositories<br>(3)HashMapper + HashOperations<br>BeanUtilsHashMapper</p>\n<p>ObjectHashMapper</p>\n<p>Jackson2HashMapper</p>\n<p>五、Reactive Redis(异步)<br>ReactiveRedisConnection</p>\n<p>ReactiveRedisTemplate</p>\n<p>六、Redis Cluster<br>RedisClusterConnection继承RedisConnection，通过RedisConnectionFactory创建，RedisClusterFactory配置属性</p>\n<p>redisTemplate.opsForCluster();</p>\n<p>七、Redis Repository</p>\n<p>要求：Redis Server2.8.0+</p>\n<p>CrudRepository</p>\n<p>RedisConverter</p>\n<p>TTL</p>\n<p>KeySpaces</p>\n<p>@Reference注解</p>\n<p>CDI Integration</p>\n","site":{"data":{}},"excerpt":"<p>Spring Data Redis(SDR) 2.x<br>需要JDK8+、Spring Framework5.0.7+、Redis2.6.x</p>\n<p>2、整合了Lettuce和Jedis两个开源库</p>\n<p>3、高可见性</p>\n<p>可以直接使用底层(本地库)直接连接Redis</p>\n<p>RedisConnection<br>可以传递底层链接库异常到Spring持久化层DAO层，</p>\n<p>使用RedisConnectionFactory创建RedisConncection,RedisConnectionFactory继承PersistenceExceptionTranslator对象，意味着异常操作对RedisConnectionFactory更透明化。</p>\n<p>目前并不是所有的SDR特性都被connector开源库支持，使用不支持的特性会抛出<br>UnsupportedOperationException异常。</p>","more":"<p>二、Lettuce<br>Lettuce是基于Netty的连接器</p>\n<p>1、默认情况下，所有的LettuceConnection被LettuceConnectionFactory创建，它们共享一个线程安全的本地连接执行非阻塞、非事务性操作。</p>\n<p>2、LettuceConnectionFactory可以通过配置使用LettucePool</p>\n<p>3、LettuceConnectionFactory通过设置shareNativeConnection=false使用事务性连接</p>\n<p>三、Jedis</p>\n<p>四、RedisTemplate<br>1、提供了更高层的抽象，更关注序列化、连接的管理。<br>RedisConnection则提供了底层方法可以操作二进制数据。</p>\n<p>2、一旦被配置，则是线程安全的，可以被多个实例重用，</p>\n<p>3、默认基于Java原生序列类进行序列化，则所有的对象读写都是经过序列化和反序列化的。SDR在org.springframework.data.redis.serializer包内提供了一些其它的序列化实现类。可以通过设置所有的序列器为null同时设置enableDefaultSerializer=false。<br><strong><em>注意：RedisTemplate要求所有的属性key不能为空，value可以为空</em></strong></p>\n<p>特殊的String操作：<br>StringRedisConnection<br>StringRedisTemplate<br>StringRedisSerializer</p>\n<p>两种serializers都基于RedisSerializer<br>Element读写使用RedisElementReader、RedisElementWriter<br>RedisCache和RedisTemplate默认使用JdkSerializationRedisSerializer</p>\n<p>OxmSerializer用于基于Object/XML mapping</p>\n<p>Jackson2JsonRedisSerializer / GenericJackson2JsonRedisSerializer用于json格式数据</p>\n<p><strong><em>如果安全更重要，可以考虑在JVM层使用特殊的filter机制</em></strong></p>\n<p>使用Redis Hash可以存储更复杂的结构化对象：<br>(1)HashOperations + serializer<br>(2)Redis Repositories<br>(3)HashMapper + HashOperations<br>BeanUtilsHashMapper</p>\n<p>ObjectHashMapper</p>\n<p>Jackson2HashMapper</p>\n<p>五、Reactive Redis(异步)<br>ReactiveRedisConnection</p>\n<p>ReactiveRedisTemplate</p>\n<p>六、Redis Cluster<br>RedisClusterConnection继承RedisConnection，通过RedisConnectionFactory创建，RedisClusterFactory配置属性</p>\n<p>redisTemplate.opsForCluster();</p>\n<p>七、Redis Repository</p>\n<p>要求：Redis Server2.8.0+</p>\n<p>CrudRepository</p>\n<p>RedisConverter</p>\n<p>TTL</p>\n<p>KeySpaces</p>\n<p>@Reference注解</p>\n<p>CDI Integration</p>"},{"title":"CDN技术介绍","date":"2018-07-27T10:18:15.000Z","_content":"\n自建CDN\n\n融合CDN\n\n网宿CDN\n\n回源：\n\n例如：又拍回源七牛，就是把七牛作为存储的原站，又拍作为CDN映射域名","source":"_posts/cdn-base.md","raw":"---\ntitle: CDN技术介绍\ndate: 2018-07-27 18:18:15\ntags:\n---\n\n自建CDN\n\n融合CDN\n\n网宿CDN\n\n回源：\n\n例如：又拍回源七牛，就是把七牛作为存储的原站，又拍作为CDN映射域名","slug":"cdn-base","published":1,"updated":"2018-07-27T10:22:26.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrddzu0008v0f07sxr75v2","content":"<p>自建CDN</p>\n<p>融合CDN</p>\n<p>网宿CDN</p>\n<p>回源：</p>\n<p>例如：又拍回源七牛，就是把七牛作为存储的原站，又拍作为CDN映射域名</p>\n","site":{"data":{}},"excerpt":"","more":"<p>自建CDN</p>\n<p>融合CDN</p>\n<p>网宿CDN</p>\n<p>回源：</p>\n<p>例如：又拍回源七牛，就是把七牛作为存储的原站，又拍作为CDN映射域名</p>\n"},{"title":"周报20180501","date":"2018-05-06T09:44:56.000Z","_content":"\nIT技术的日新月异，让我决定对每周的技术更新做一个汇总，主要还是自己关注的一些方向。权当收藏\n\n1、Oracle发布通用型虚拟机GraalVM1.0,支持多种编程语言\n\n允许外部语言直接使用对象与数组，而无需首行将其转换为不同语言的对应版本。举例来说，该工具允许 Node.js 代码访问 Java 库，或者在 Java 内部调用 Python 例程。\n\n2、微服务Istio发布0.7版本\n\n\n3、MySQL发布8.0版本\n\n\n4、Google正式发布Fuchsia文档","source":"_posts/Weekly20180501.md","raw":"---\ntitle: 周报20180501\ndate: 2018-05-06 17:44:56\ntags: 周报, 技术\ncategories: 周报\n---\n\nIT技术的日新月异，让我决定对每周的技术更新做一个汇总，主要还是自己关注的一些方向。权当收藏\n\n1、Oracle发布通用型虚拟机GraalVM1.0,支持多种编程语言\n\n允许外部语言直接使用对象与数组，而无需首行将其转换为不同语言的对应版本。举例来说，该工具允许 Node.js 代码访问 Java 库，或者在 Java 内部调用 Python 例程。\n\n2、微服务Istio发布0.7版本\n\n\n3、MySQL发布8.0版本\n\n\n4、Google正式发布Fuchsia文档","slug":"Weekly20180501","published":1,"updated":"2018-07-25T06:56:22.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde01000av0f0xq3zil6u","content":"<p>IT技术的日新月异，让我决定对每周的技术更新做一个汇总，主要还是自己关注的一些方向。权当收藏</p>\n<p>1、Oracle发布通用型虚拟机GraalVM1.0,支持多种编程语言</p>\n<p>允许外部语言直接使用对象与数组，而无需首行将其转换为不同语言的对应版本。举例来说，该工具允许 Node.js 代码访问 Java 库，或者在 Java 内部调用 Python 例程。</p>\n<p>2、微服务Istio发布0.7版本</p>\n<p>3、MySQL发布8.0版本</p>\n<p>4、Google正式发布Fuchsia文档</p>\n","site":{"data":{}},"excerpt":"","more":"<p>IT技术的日新月异，让我决定对每周的技术更新做一个汇总，主要还是自己关注的一些方向。权当收藏</p>\n<p>1、Oracle发布通用型虚拟机GraalVM1.0,支持多种编程语言</p>\n<p>允许外部语言直接使用对象与数组，而无需首行将其转换为不同语言的对应版本。举例来说，该工具允许 Node.js 代码访问 Java 库，或者在 Java 内部调用 Python 例程。</p>\n<p>2、微服务Istio发布0.7版本</p>\n<p>3、MySQL发布8.0版本</p>\n<p>4、Google正式发布Fuchsia文档</p>\n"},{"title":"类和接口","date":"2018-05-06T02:23:45.000Z","_content":"\n#### 第14条\n\n退化类：\n\n改进：\n\n(1)如果类可以在它所在的包外部进行访问，就提供访问方法，以保留将来改变该类的内部表示法的灵活性(但是如果域是不可变的final,直接public暴露)\n\n反例：java.awt.Point/Dimension类\n\n(2)如果类是包级私有的，或是私有的嵌套类，可以直接暴露它的数据域\n\n<!-- more -->\n\n#### 第15条\n\n不可变类：实例所包含的信息在创建时被提供，并在整个生命周期内固定不变。例如：String、基本类型的封装类、BigInteger、BegDecimal\n\n不可变类的五条原则：\n\n1、不要提供任何会修改对象状态的方法\n\n2、保证类不会被扩展，使这个类成为final类;或者让类的所有构造器变成私有的/包级私有的，并添加公有的静态工厂\n\n3、使所有的域都是final的\n\n4、使所有的域都是私有的(虽然技术上允许public, 但是以后不能再将public降级为private)\n\n5、确保对于任何可变组件的互斥访问\n\n> 如果类具有指向可变对象的域，必须确保客户端无法获得指向这些对象的引用；永远不要用客户端提供的对象引用来初始化这样的域；永远不要从任何方法中返回该对象引用。\n\n> 在构造器、访问方法、readObject中使用保护性拷贝\n\n\n注意：\n> 实际上，许多不可变类拥有一个或多个非final的域，它们在第一次被请求执行这些计算时，把开销昂贵的计算结果缓存在这些域。例如String的延迟初始化\n> \n> 如果让自定义的不可变类实现Serializable接口，并且包含一个或多个指向可变对象的域，就必须提供一个显式的readObject/readResolve方法\n\n>不要为每个get方法编写一个相应的set方法，\n\n>构造器应该创建完全初始化的对象，并建立起所有的约束关系，不要在构造器或者静态工厂之外再提供公有的初始化方法。\n\n函数的\n\n过程的\n\n命令式的\n\n不可变对象的优点：\n\n1、不可变对象比较简单\n\n2、不可变对象本质上是线程安全的，它们不要求同步，所以可以被自由共享\n\npublic static final Complex ZERO = new Complex(0, 0);\n\n可以提供一些静态工厂，把频繁被请求的实例缓存起来，例如BigInteger、基本类型包装类\n\n不需要为不可变类提供clone方法、拷贝构造器\n\n3、不仅可以共享不可变对象，甚至可以共享它们的内部信息。例如：BigInteger类内部使用了符号数值表示法\n\n4、不可变对象为其它对象提供了大量的构件。一旦不可变对象进入映射或集合中，尽管这破坏了映射或者集合的不可变性约束，但是也不用担心它们的值会发生变化\n\n不可变类的缺点：\n\n1、不可变对象对于每个不同的值都需要一个单独的对象。例如：String的可变配套类StringBuilder，Big Integer的BitSet\n\n为了潜在的性能问题，java.util.Date、java.awt.Point本应该是不可变的，实际上却不是\n\n#### 第16条\n\n该条讨论的继承指的是class extends class,而不是class implements interface、interface extends interface\n\n包内使用继承非常安全，跨包使用继承则非常危险。\n\n复合代替继承，使用转发类代替接口实现类实现接口\n\n注意：\n\n> 包装类不适\n> 合用在回调框架中\n\n> 在Java类库中，违反复合原则的有:Stack并不是Vector，Properties也不是HashTable\n\n> 在使用继承而不是复合之前，要确定将要扩展的类中API有没有缺陷\n\n\n#### 第17条\n\n接口优于实现类\n\n骨架实现类(结合接口和抽象类的优点)。例如：AbstractCollection、AbstractSet、AbstractList、AbstractMap\n\n抽象类的演变比接口的演变容易的多\n\n\n#### 第19条\n\n常量接口是一种不良使用，接口应该只被用来定义类型\n\n导出常量的三种方式：\n\n> 直接放在类、接口中\n\n> 枚举类型\n\n> 工具类，如果工具类常量太多，可以通过静态导入机制实现\n\n#### 第20条\n\n标签类：如何定义\n\n改进：\n\n类层次\n\n","source":"_posts/class-interface.md","raw":"---\ntitle: 类和接口\ndate: 2018-05-06 10:23:45\ntags:\n---\n\n#### 第14条\n\n退化类：\n\n改进：\n\n(1)如果类可以在它所在的包外部进行访问，就提供访问方法，以保留将来改变该类的内部表示法的灵活性(但是如果域是不可变的final,直接public暴露)\n\n反例：java.awt.Point/Dimension类\n\n(2)如果类是包级私有的，或是私有的嵌套类，可以直接暴露它的数据域\n\n<!-- more -->\n\n#### 第15条\n\n不可变类：实例所包含的信息在创建时被提供，并在整个生命周期内固定不变。例如：String、基本类型的封装类、BigInteger、BegDecimal\n\n不可变类的五条原则：\n\n1、不要提供任何会修改对象状态的方法\n\n2、保证类不会被扩展，使这个类成为final类;或者让类的所有构造器变成私有的/包级私有的，并添加公有的静态工厂\n\n3、使所有的域都是final的\n\n4、使所有的域都是私有的(虽然技术上允许public, 但是以后不能再将public降级为private)\n\n5、确保对于任何可变组件的互斥访问\n\n> 如果类具有指向可变对象的域，必须确保客户端无法获得指向这些对象的引用；永远不要用客户端提供的对象引用来初始化这样的域；永远不要从任何方法中返回该对象引用。\n\n> 在构造器、访问方法、readObject中使用保护性拷贝\n\n\n注意：\n> 实际上，许多不可变类拥有一个或多个非final的域，它们在第一次被请求执行这些计算时，把开销昂贵的计算结果缓存在这些域。例如String的延迟初始化\n> \n> 如果让自定义的不可变类实现Serializable接口，并且包含一个或多个指向可变对象的域，就必须提供一个显式的readObject/readResolve方法\n\n>不要为每个get方法编写一个相应的set方法，\n\n>构造器应该创建完全初始化的对象，并建立起所有的约束关系，不要在构造器或者静态工厂之外再提供公有的初始化方法。\n\n函数的\n\n过程的\n\n命令式的\n\n不可变对象的优点：\n\n1、不可变对象比较简单\n\n2、不可变对象本质上是线程安全的，它们不要求同步，所以可以被自由共享\n\npublic static final Complex ZERO = new Complex(0, 0);\n\n可以提供一些静态工厂，把频繁被请求的实例缓存起来，例如BigInteger、基本类型包装类\n\n不需要为不可变类提供clone方法、拷贝构造器\n\n3、不仅可以共享不可变对象，甚至可以共享它们的内部信息。例如：BigInteger类内部使用了符号数值表示法\n\n4、不可变对象为其它对象提供了大量的构件。一旦不可变对象进入映射或集合中，尽管这破坏了映射或者集合的不可变性约束，但是也不用担心它们的值会发生变化\n\n不可变类的缺点：\n\n1、不可变对象对于每个不同的值都需要一个单独的对象。例如：String的可变配套类StringBuilder，Big Integer的BitSet\n\n为了潜在的性能问题，java.util.Date、java.awt.Point本应该是不可变的，实际上却不是\n\n#### 第16条\n\n该条讨论的继承指的是class extends class,而不是class implements interface、interface extends interface\n\n包内使用继承非常安全，跨包使用继承则非常危险。\n\n复合代替继承，使用转发类代替接口实现类实现接口\n\n注意：\n\n> 包装类不适\n> 合用在回调框架中\n\n> 在Java类库中，违反复合原则的有:Stack并不是Vector，Properties也不是HashTable\n\n> 在使用继承而不是复合之前，要确定将要扩展的类中API有没有缺陷\n\n\n#### 第17条\n\n接口优于实现类\n\n骨架实现类(结合接口和抽象类的优点)。例如：AbstractCollection、AbstractSet、AbstractList、AbstractMap\n\n抽象类的演变比接口的演变容易的多\n\n\n#### 第19条\n\n常量接口是一种不良使用，接口应该只被用来定义类型\n\n导出常量的三种方式：\n\n> 直接放在类、接口中\n\n> 枚举类型\n\n> 工具类，如果工具类常量太多，可以通过静态导入机制实现\n\n#### 第20条\n\n标签类：如何定义\n\n改进：\n\n类层次\n\n","slug":"class-interface","published":1,"updated":"2018-07-24T08:45:36.343Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde05000dv0f0gzqef7x2","content":"<h4 id=\"第14条\"><a href=\"#第14条\" class=\"headerlink\" title=\"第14条\"></a>第14条</h4><p>退化类：</p>\n<p>改进：</p>\n<p>(1)如果类可以在它所在的包外部进行访问，就提供访问方法，以保留将来改变该类的内部表示法的灵活性(但是如果域是不可变的final,直接public暴露)</p>\n<p>反例：java.awt.Point/Dimension类</p>\n<p>(2)如果类是包级私有的，或是私有的嵌套类，可以直接暴露它的数据域</p>\n<a id=\"more\"></a>\n<h4 id=\"第15条\"><a href=\"#第15条\" class=\"headerlink\" title=\"第15条\"></a>第15条</h4><p>不可变类：实例所包含的信息在创建时被提供，并在整个生命周期内固定不变。例如：String、基本类型的封装类、BigInteger、BegDecimal</p>\n<p>不可变类的五条原则：</p>\n<p>1、不要提供任何会修改对象状态的方法</p>\n<p>2、保证类不会被扩展，使这个类成为final类;或者让类的所有构造器变成私有的/包级私有的，并添加公有的静态工厂</p>\n<p>3、使所有的域都是final的</p>\n<p>4、使所有的域都是私有的(虽然技术上允许public, 但是以后不能再将public降级为private)</p>\n<p>5、确保对于任何可变组件的互斥访问</p>\n<blockquote>\n<p>如果类具有指向可变对象的域，必须确保客户端无法获得指向这些对象的引用；永远不要用客户端提供的对象引用来初始化这样的域；永远不要从任何方法中返回该对象引用。</p>\n</blockquote>\n<blockquote>\n<p>在构造器、访问方法、readObject中使用保护性拷贝</p>\n</blockquote>\n<p>注意：</p>\n<blockquote>\n<p>实际上，许多不可变类拥有一个或多个非final的域，它们在第一次被请求执行这些计算时，把开销昂贵的计算结果缓存在这些域。例如String的延迟初始化</p>\n<p>如果让自定义的不可变类实现Serializable接口，并且包含一个或多个指向可变对象的域，就必须提供一个显式的readObject/readResolve方法</p>\n</blockquote>\n<blockquote>\n<p>不要为每个get方法编写一个相应的set方法，</p>\n</blockquote>\n<blockquote>\n<p>构造器应该创建完全初始化的对象，并建立起所有的约束关系，不要在构造器或者静态工厂之外再提供公有的初始化方法。</p>\n</blockquote>\n<p>函数的</p>\n<p>过程的</p>\n<p>命令式的</p>\n<p>不可变对象的优点：</p>\n<p>1、不可变对象比较简单</p>\n<p>2、不可变对象本质上是线程安全的，它们不要求同步，所以可以被自由共享</p>\n<p>public static final Complex ZERO = new Complex(0, 0);</p>\n<p>可以提供一些静态工厂，把频繁被请求的实例缓存起来，例如BigInteger、基本类型包装类</p>\n<p>不需要为不可变类提供clone方法、拷贝构造器</p>\n<p>3、不仅可以共享不可变对象，甚至可以共享它们的内部信息。例如：BigInteger类内部使用了符号数值表示法</p>\n<p>4、不可变对象为其它对象提供了大量的构件。一旦不可变对象进入映射或集合中，尽管这破坏了映射或者集合的不可变性约束，但是也不用担心它们的值会发生变化</p>\n<p>不可变类的缺点：</p>\n<p>1、不可变对象对于每个不同的值都需要一个单独的对象。例如：String的可变配套类StringBuilder，Big Integer的BitSet</p>\n<p>为了潜在的性能问题，java.util.Date、java.awt.Point本应该是不可变的，实际上却不是</p>\n<h4 id=\"第16条\"><a href=\"#第16条\" class=\"headerlink\" title=\"第16条\"></a>第16条</h4><p>该条讨论的继承指的是class extends class,而不是class implements interface、interface extends interface</p>\n<p>包内使用继承非常安全，跨包使用继承则非常危险。</p>\n<p>复合代替继承，使用转发类代替接口实现类实现接口</p>\n<p>注意：</p>\n<blockquote>\n<p>包装类不适<br>合用在回调框架中</p>\n</blockquote>\n<blockquote>\n<p>在Java类库中，违反复合原则的有:Stack并不是Vector，Properties也不是HashTable</p>\n</blockquote>\n<blockquote>\n<p>在使用继承而不是复合之前，要确定将要扩展的类中API有没有缺陷</p>\n</blockquote>\n<h4 id=\"第17条\"><a href=\"#第17条\" class=\"headerlink\" title=\"第17条\"></a>第17条</h4><p>接口优于实现类</p>\n<p>骨架实现类(结合接口和抽象类的优点)。例如：AbstractCollection、AbstractSet、AbstractList、AbstractMap</p>\n<p>抽象类的演变比接口的演变容易的多</p>\n<h4 id=\"第19条\"><a href=\"#第19条\" class=\"headerlink\" title=\"第19条\"></a>第19条</h4><p>常量接口是一种不良使用，接口应该只被用来定义类型</p>\n<p>导出常量的三种方式：</p>\n<blockquote>\n<p>直接放在类、接口中</p>\n</blockquote>\n<blockquote>\n<p>枚举类型</p>\n</blockquote>\n<blockquote>\n<p>工具类，如果工具类常量太多，可以通过静态导入机制实现</p>\n</blockquote>\n<h4 id=\"第20条\"><a href=\"#第20条\" class=\"headerlink\" title=\"第20条\"></a>第20条</h4><p>标签类：如何定义</p>\n<p>改进：</p>\n<p>类层次</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"第14条\"><a href=\"#第14条\" class=\"headerlink\" title=\"第14条\"></a>第14条</h4><p>退化类：</p>\n<p>改进：</p>\n<p>(1)如果类可以在它所在的包外部进行访问，就提供访问方法，以保留将来改变该类的内部表示法的灵活性(但是如果域是不可变的final,直接public暴露)</p>\n<p>反例：java.awt.Point/Dimension类</p>\n<p>(2)如果类是包级私有的，或是私有的嵌套类，可以直接暴露它的数据域</p>","more":"<h4 id=\"第15条\"><a href=\"#第15条\" class=\"headerlink\" title=\"第15条\"></a>第15条</h4><p>不可变类：实例所包含的信息在创建时被提供，并在整个生命周期内固定不变。例如：String、基本类型的封装类、BigInteger、BegDecimal</p>\n<p>不可变类的五条原则：</p>\n<p>1、不要提供任何会修改对象状态的方法</p>\n<p>2、保证类不会被扩展，使这个类成为final类;或者让类的所有构造器变成私有的/包级私有的，并添加公有的静态工厂</p>\n<p>3、使所有的域都是final的</p>\n<p>4、使所有的域都是私有的(虽然技术上允许public, 但是以后不能再将public降级为private)</p>\n<p>5、确保对于任何可变组件的互斥访问</p>\n<blockquote>\n<p>如果类具有指向可变对象的域，必须确保客户端无法获得指向这些对象的引用；永远不要用客户端提供的对象引用来初始化这样的域；永远不要从任何方法中返回该对象引用。</p>\n</blockquote>\n<blockquote>\n<p>在构造器、访问方法、readObject中使用保护性拷贝</p>\n</blockquote>\n<p>注意：</p>\n<blockquote>\n<p>实际上，许多不可变类拥有一个或多个非final的域，它们在第一次被请求执行这些计算时，把开销昂贵的计算结果缓存在这些域。例如String的延迟初始化</p>\n<p>如果让自定义的不可变类实现Serializable接口，并且包含一个或多个指向可变对象的域，就必须提供一个显式的readObject/readResolve方法</p>\n</blockquote>\n<blockquote>\n<p>不要为每个get方法编写一个相应的set方法，</p>\n</blockquote>\n<blockquote>\n<p>构造器应该创建完全初始化的对象，并建立起所有的约束关系，不要在构造器或者静态工厂之外再提供公有的初始化方法。</p>\n</blockquote>\n<p>函数的</p>\n<p>过程的</p>\n<p>命令式的</p>\n<p>不可变对象的优点：</p>\n<p>1、不可变对象比较简单</p>\n<p>2、不可变对象本质上是线程安全的，它们不要求同步，所以可以被自由共享</p>\n<p>public static final Complex ZERO = new Complex(0, 0);</p>\n<p>可以提供一些静态工厂，把频繁被请求的实例缓存起来，例如BigInteger、基本类型包装类</p>\n<p>不需要为不可变类提供clone方法、拷贝构造器</p>\n<p>3、不仅可以共享不可变对象，甚至可以共享它们的内部信息。例如：BigInteger类内部使用了符号数值表示法</p>\n<p>4、不可变对象为其它对象提供了大量的构件。一旦不可变对象进入映射或集合中，尽管这破坏了映射或者集合的不可变性约束，但是也不用担心它们的值会发生变化</p>\n<p>不可变类的缺点：</p>\n<p>1、不可变对象对于每个不同的值都需要一个单独的对象。例如：String的可变配套类StringBuilder，Big Integer的BitSet</p>\n<p>为了潜在的性能问题，java.util.Date、java.awt.Point本应该是不可变的，实际上却不是</p>\n<h4 id=\"第16条\"><a href=\"#第16条\" class=\"headerlink\" title=\"第16条\"></a>第16条</h4><p>该条讨论的继承指的是class extends class,而不是class implements interface、interface extends interface</p>\n<p>包内使用继承非常安全，跨包使用继承则非常危险。</p>\n<p>复合代替继承，使用转发类代替接口实现类实现接口</p>\n<p>注意：</p>\n<blockquote>\n<p>包装类不适<br>合用在回调框架中</p>\n</blockquote>\n<blockquote>\n<p>在Java类库中，违反复合原则的有:Stack并不是Vector，Properties也不是HashTable</p>\n</blockquote>\n<blockquote>\n<p>在使用继承而不是复合之前，要确定将要扩展的类中API有没有缺陷</p>\n</blockquote>\n<h4 id=\"第17条\"><a href=\"#第17条\" class=\"headerlink\" title=\"第17条\"></a>第17条</h4><p>接口优于实现类</p>\n<p>骨架实现类(结合接口和抽象类的优点)。例如：AbstractCollection、AbstractSet、AbstractList、AbstractMap</p>\n<p>抽象类的演变比接口的演变容易的多</p>\n<h4 id=\"第19条\"><a href=\"#第19条\" class=\"headerlink\" title=\"第19条\"></a>第19条</h4><p>常量接口是一种不良使用，接口应该只被用来定义类型</p>\n<p>导出常量的三种方式：</p>\n<blockquote>\n<p>直接放在类、接口中</p>\n</blockquote>\n<blockquote>\n<p>枚举类型</p>\n</blockquote>\n<blockquote>\n<p>工具类，如果工具类常量太多，可以通过静态导入机制实现</p>\n</blockquote>\n<h4 id=\"第20条\"><a href=\"#第20条\" class=\"headerlink\" title=\"第20条\"></a>第20条</h4><p>标签类：如何定义</p>\n<p>改进：</p>\n<p>类层次</p>"},{"title":"求一个数组中重复出现次数最多的数字以及出现次数","date":"2018-08-14T03:00:24.000Z","_content":"## java语言实现 ##\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n<!-- more -->\n\n\tpublic static void main(String[] args){  \n        int[] arr = { 7, 1, 3, 5, 4, 6, 6, 8, 8, 9, 2, 8, 3 , 8};\n\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i=0; i < arr.length; i++) {\n            if(map.containsKey(arr[i])) {\n                map.put(arr[i], map.get(arr[i]) + 1);\n            } else {\n                map.put(arr[i], 1);\n            }\n        }\n\n        int count = -1;\n        int max = Integer.MIN_VALUE;\n        Iterator<Map.Entry<Integer, Integer>> iter = map.entrySet().iterator();\n        while(iter.hasNext()){\n            Map.Entry<Integer, Integer> entry = iter.next();\n            if(entry.getValue() > count) {\n                count = entry.getValue();\n                max = entry.getKey();\n            }\n        }\n\n        System.out.println(\"出现次数最多的元素：\" + max +\"--出现次数：\" + count);\n    }\n\n## go语言实现 ##\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n\tpackage main\n\t\n\timport (\n\t\t\"fmt\"\n\t)\n\t\n\tfunc main() {\n\t\tarr := []int{ 7, 1, 3, 5, 4, 6, 6, 8, 8, 9, 2, 8, 3 , 8}\n\t\n\t\t// 创建map类型key(数值)--value(出现次数)\n\t\tmaps := make(map[int]int)\n\t\tfor _, v := range arr {\n\t\t\tif maps[v] != 0 {\n\t\t\t\tmaps[v]++\n\t\t\t} else {\n\t\t\t\tmaps[v] = 1\n\t\t\t}\n\t\t}\n\t\n\t\tmax, count := maxInMap(maps)\n\t\n\t\tfmt.Printf(\"出现次数最多的数字： %d， 次数： %d\", max, count)\n\t}\n\t\n\tfunc maxInMap(maps map[int]int) (int, int) {\n\t\tcount := -1\n\t\tvar max int \n\t\tfor k, v := range maps {\n\t\t\tif v > count {\n\t\t\t\tcount = v\n\t\t\t\tmax = k\n\t\t\t}\n\t\t}\n\t\n\t\treturn max, count\n\t}","source":"_posts/algorithms-1.md","raw":"---\ntitle: 求一个数组中重复出现次数最多的数字以及出现次数\ndate: 2018-08-14 11:00:24\ntags: algorithms, java, go\ncategories: algorithms\n---\n## java语言实现 ##\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n<!-- more -->\n\n\tpublic static void main(String[] args){  \n        int[] arr = { 7, 1, 3, 5, 4, 6, 6, 8, 8, 9, 2, 8, 3 , 8};\n\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i=0; i < arr.length; i++) {\n            if(map.containsKey(arr[i])) {\n                map.put(arr[i], map.get(arr[i]) + 1);\n            } else {\n                map.put(arr[i], 1);\n            }\n        }\n\n        int count = -1;\n        int max = Integer.MIN_VALUE;\n        Iterator<Map.Entry<Integer, Integer>> iter = map.entrySet().iterator();\n        while(iter.hasNext()){\n            Map.Entry<Integer, Integer> entry = iter.next();\n            if(entry.getValue() > count) {\n                count = entry.getValue();\n                max = entry.getKey();\n            }\n        }\n\n        System.out.println(\"出现次数最多的元素：\" + max +\"--出现次数：\" + count);\n    }\n\n## go语言实现 ##\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n\tpackage main\n\t\n\timport (\n\t\t\"fmt\"\n\t)\n\t\n\tfunc main() {\n\t\tarr := []int{ 7, 1, 3, 5, 4, 6, 6, 8, 8, 9, 2, 8, 3 , 8}\n\t\n\t\t// 创建map类型key(数值)--value(出现次数)\n\t\tmaps := make(map[int]int)\n\t\tfor _, v := range arr {\n\t\t\tif maps[v] != 0 {\n\t\t\t\tmaps[v]++\n\t\t\t} else {\n\t\t\t\tmaps[v] = 1\n\t\t\t}\n\t\t}\n\t\n\t\tmax, count := maxInMap(maps)\n\t\n\t\tfmt.Printf(\"出现次数最多的数字： %d， 次数： %d\", max, count)\n\t}\n\t\n\tfunc maxInMap(maps map[int]int) (int, int) {\n\t\tcount := -1\n\t\tvar max int \n\t\tfor k, v := range maps {\n\t\t\tif v > count {\n\t\t\t\tcount = v\n\t\t\t\tmax = k\n\t\t\t}\n\t\t}\n\t\n\t\treturn max, count\n\t}","slug":"algorithms-1","published":1,"updated":"2018-08-14T03:27:15.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde0a000fv0f0ing955cj","content":"<h2 id=\"java语言实现\"><a href=\"#java语言实现\" class=\"headerlink\" title=\"java语言实现\"></a>java语言实现</h2><p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(n)</p>\n<a id=\"more\"></a>\n<pre><code>public static void main(String[] args){  \n    int[] arr = { 7, 1, 3, 5, 4, 6, 6, 8, 8, 9, 2, 8, 3 , 8};\n\n    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n    for(int i=0; i &lt; arr.length; i++) {\n        if(map.containsKey(arr[i])) {\n            map.put(arr[i], map.get(arr[i]) + 1);\n        } else {\n            map.put(arr[i], 1);\n        }\n    }\n\n    int count = -1;\n    int max = Integer.MIN_VALUE;\n    Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iter = map.entrySet().iterator();\n    while(iter.hasNext()){\n        Map.Entry&lt;Integer, Integer&gt; entry = iter.next();\n        if(entry.getValue() &gt; count) {\n            count = entry.getValue();\n            max = entry.getKey();\n        }\n    }\n\n    System.out.println(&quot;出现次数最多的元素：&quot; + max +&quot;--出现次数：&quot; + count);\n}\n</code></pre><h2 id=\"go语言实现\"><a href=\"#go语言实现\" class=\"headerlink\" title=\"go语言实现\"></a>go语言实现</h2><p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(n)</p>\n<pre><code>package main\n\nimport (\n    &quot;fmt&quot;\n)\n\nfunc main() {\n    arr := []int{ 7, 1, 3, 5, 4, 6, 6, 8, 8, 9, 2, 8, 3 , 8}\n\n    // 创建map类型key(数值)--value(出现次数)\n    maps := make(map[int]int)\n    for _, v := range arr {\n        if maps[v] != 0 {\n            maps[v]++\n        } else {\n            maps[v] = 1\n        }\n    }\n\n    max, count := maxInMap(maps)\n\n    fmt.Printf(&quot;出现次数最多的数字： %d， 次数： %d&quot;, max, count)\n}\n\nfunc maxInMap(maps map[int]int) (int, int) {\n    count := -1\n    var max int \n    for k, v := range maps {\n        if v &gt; count {\n            count = v\n            max = k\n        }\n    }\n\n    return max, count\n}\n</code></pre>","site":{"data":{}},"excerpt":"<h2 id=\"java语言实现\"><a href=\"#java语言实现\" class=\"headerlink\" title=\"java语言实现\"></a>java语言实现</h2><p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(n)</p>","more":"<pre><code>public static void main(String[] args){  \n    int[] arr = { 7, 1, 3, 5, 4, 6, 6, 8, 8, 9, 2, 8, 3 , 8};\n\n    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n    for(int i=0; i &lt; arr.length; i++) {\n        if(map.containsKey(arr[i])) {\n            map.put(arr[i], map.get(arr[i]) + 1);\n        } else {\n            map.put(arr[i], 1);\n        }\n    }\n\n    int count = -1;\n    int max = Integer.MIN_VALUE;\n    Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iter = map.entrySet().iterator();\n    while(iter.hasNext()){\n        Map.Entry&lt;Integer, Integer&gt; entry = iter.next();\n        if(entry.getValue() &gt; count) {\n            count = entry.getValue();\n            max = entry.getKey();\n        }\n    }\n\n    System.out.println(&quot;出现次数最多的元素：&quot; + max +&quot;--出现次数：&quot; + count);\n}\n</code></pre><h2 id=\"go语言实现\"><a href=\"#go语言实现\" class=\"headerlink\" title=\"go语言实现\"></a>go语言实现</h2><p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(n)</p>\n<pre><code>package main\n\nimport (\n    &quot;fmt&quot;\n)\n\nfunc main() {\n    arr := []int{ 7, 1, 3, 5, 4, 6, 6, 8, 8, 9, 2, 8, 3 , 8}\n\n    // 创建map类型key(数值)--value(出现次数)\n    maps := make(map[int]int)\n    for _, v := range arr {\n        if maps[v] != 0 {\n            maps[v]++\n        } else {\n            maps[v] = 1\n        }\n    }\n\n    max, count := maxInMap(maps)\n\n    fmt.Printf(&quot;出现次数最多的数字： %d， 次数： %d&quot;, max, count)\n}\n\nfunc maxInMap(maps map[int]int) (int, int) {\n    count := -1\n    var max int \n    for k, v := range maps {\n        if v &gt; count {\n            count = v\n            max = k\n        }\n    }\n\n    return max, count\n}\n</code></pre>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=444267928&auto=1&height=66\"></iframe>\n\n### 新建博客\n\n``` bash\n$ hexo new \"My New Post\"/hexo new post go-base\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### 运行服务\n\n``` bash\n$ hexo server/hexo s\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### 生成静态文件\n\n``` bash\n$ hexo generate/hexo g\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### 发布博客到github\n\n``` bash\n$ hexo deploy/hexo d\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=444267928&auto=1&height=66\"></iframe>\n\n### 新建博客\n\n``` bash\n$ hexo new \"My New Post\"/hexo new post go-base\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### 运行服务\n\n``` bash\n$ hexo server/hexo s\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### 生成静态文件\n\n``` bash\n$ hexo generate/hexo g\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### 发布博客到github\n\n``` bash\n$ hexo deploy/hexo d\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-08-15T13:37:34.048Z","updated":"2018-08-08T15:02:07.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde0h000iv0f007bfqpjp","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=444267928&auto=1&height=66\"></iframe>\n\n<h3 id=\"新建博客\"><a href=\"#新建博客\" class=\"headerlink\" title=\"新建博客\"></a>新建博客</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span>/hexo new post go-base</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"运行服务\"><a href=\"#运行服务\" class=\"headerlink\" title=\"运行服务\"></a>运行服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server/hexo s</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"生成静态文件\"><a href=\"#生成静态文件\" class=\"headerlink\" title=\"生成静态文件\"></a>生成静态文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate/hexo g</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"发布博客到github\"><a href=\"#发布博客到github\" class=\"headerlink\" title=\"发布博客到github\"></a>发布博客到github</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy/hexo d</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=444267928&auto=1&height=66\"></iframe>\n\n<h3 id=\"新建博客\"><a href=\"#新建博客\" class=\"headerlink\" title=\"新建博客\"></a>新建博客</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span>/hexo new post go-base</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"运行服务\"><a href=\"#运行服务\" class=\"headerlink\" title=\"运行服务\"></a>运行服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server/hexo s</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"生成静态文件\"><a href=\"#生成静态文件\" class=\"headerlink\" title=\"生成静态文件\"></a>生成静态文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate/hexo g</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"发布博客到github\"><a href=\"#发布博客到github\" class=\"headerlink\" title=\"发布博客到github\"></a>发布博客到github</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy/hexo d</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"Go语言基础入门","date":"2018-07-25T06:12:45.000Z","_content":"一段时间不写Go,很多东西都忘了，还是记录一下吧！\n## 一、基础入门 ##\n\n`go run hello.go`\n\n行分隔符：一行代表一个语句结束，不需要分号';'，多个语句在一行使用';'，类似于Scala\n\n25个关键字：\n\nbreak  default\tfunc  interface\t select\ncase\tdefer\tgo\tmap\tstruct\nchan\telse\tgoto\tpackage\tswitch\nconst\tfallthrough\tif\trange\ttype\ncontinue\tfor\timport\treturn\tvar\n\n<!-- more -->\n\n36个预定义标识符:\n\nappend \tbool \tbyte \tcap \tclose \tcomplex \tcomplex64 \tcomplex128 \tuint16\ncopy \tfalse \tfloat32 \tfloat64 \timag \tint \tint8 \tint16 \tuint32\nint32 \tint64 \tiota \tlen \tmake \tnew \tnil \tpanic \tuint64\nprint \tprintln \treal \trecover \tstring \ttrue \tuint \tuint8 \tuintptr\n\n## 二、数据类型 ##\n\n1、布尔类型\n\n2、数字类型\n\n>uint8 无符号 8 位整型 (0 到 255)\n>\n>uint16 无符号 16 位整型 (0 到 65535)\n>\n>uint32 无符号 32 位整型 (0 到 4294967295)\n>\n>uint64 无符号 64 位整型 (0 到 18446744073709551615)\n>\n>int8 有符号 8 位整型 (-128 到 127)\n>\n>int16 有符号 16 位整型 (-32768 到 32767)\n>\n>int32 有符号 32 位整型 (-2147483648 到 2147483647)\n>\n>int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)\n\nbyte 类似 uint8\nrune 类似 int32\nuint 32 或 64 位\nint 与 uint 一样大小\nuintptr 无符号整型，用于存放一个指针\n\n3、字符串类型\n\n4、派生类型：\n\t(a) 指针类型（Pointer）\n\t(b) 数组类型\n\t(c) 结构化类型(struct)\n\t(d) Channel 类型\n\t(e) 函数类型\n\t(f) 切片类型\n\t(g) 接口类型（interface）\n\t(h) Map 类型 \n\n## 三、变量与常量 ##\n\n| 数据类型 \t| 初始化默认值   |\n|-| :-:|\n| int \t\t| 0             |\n| float32 \t| 0             |\n| pointer \t| nil           |\n\n\n1、var 声明变量\n\n`var identifier type  //声明后若不赋值，则使用默认值\n\nvar v_name = value  //不声明类型时，执行类型推断，类似于Scala\n\nv_name := value`\n\n多变量声明：var a, b, c = a1, b1, c1\n\n2、const 声明常量\nconst可以用于枚举\n\n`const( \n\n  Unkonwn = 0\n\n  Female = 1\n\n  Male = 2\n\n)\n`\n\n常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过\n\n`\nconst(\n\ta = \"abc\"\n\tb = len(a)\n)\n`\n\n3、**iota 特殊常量**\n\n\n\t\n空白标识符'_'用于抛弃值，类似于Scala\n\t\n## 四、 ##\nGo语言循环中有：break、continue、goto\n\n\n\n## 五、函数 ##\n\nGo语言中全局变量和局部变量可以相同，函数内变量优先考虑\n\nGo函数可以返回多个值，这个比Java好很多\n\n`func swap(x, y string) (string, string){\n\treturn y, x\n}`\n\t\n值传递: 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\n\n引用传递: 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n\n**默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。**\n\n函数作为值传递，类似于Scala高阶函数\ngetSquareRoot := func(x float64) float64 {  //类似于Scala匿名函数\n    return math.Sqrt(x)\n}\n\n*Go支持匿名函数可以作为闭包，和Scala的闭包有什么区别？*\n\nGo语言中函数不同于方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。\n\n**接口类型(interface)**\n\n**方法集**\n\n\t\n## 六、 ##\n1、数组\n\n`\nvar array [size] arr_type\nvar array = [5]int{1,2,3,4,5}\n`\n\n2、切片：切片是对数组的抽象，数组长度不可变，切片是动态数组\n`\nvar slice [] slice_type\nvar slice [] slice_type = make([]slice_type, len)\nslice := make([]slice_type, len)\n`\n\n3、范围range 类似于Java在for-Each，Scala中<-遍历\nGo 语言中 range 关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。\n在数组和切片中它返回元素的索引值，在集合中返回 key-value 对的 key 值。 \n\n4、Map声明后必须make初始化，否则为nil，类似于Java的null\n\n`var cmap map[string]string\ncmap = make(map[string]string) `\n\n5、类型转换，不同于Java的向上向下转型\n\n`\nvar i int = 10\nfloat32(i)\n`\n\n\n结构体：类似于c语言的结构体\n\n结构体指针\n\n## 七、错误处理 ##\n\nGo语言通过内置的错误接口(error)提供了非常简单的错误处理机制。\n\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t","source":"_posts/go-base.md","raw":"---\ntitle: Go语言基础入门\ndate: 2018-07-25 14:12:45\ntags: 语言, go\ncategories: Go\n---\n一段时间不写Go,很多东西都忘了，还是记录一下吧！\n## 一、基础入门 ##\n\n`go run hello.go`\n\n行分隔符：一行代表一个语句结束，不需要分号';'，多个语句在一行使用';'，类似于Scala\n\n25个关键字：\n\nbreak  default\tfunc  interface\t select\ncase\tdefer\tgo\tmap\tstruct\nchan\telse\tgoto\tpackage\tswitch\nconst\tfallthrough\tif\trange\ttype\ncontinue\tfor\timport\treturn\tvar\n\n<!-- more -->\n\n36个预定义标识符:\n\nappend \tbool \tbyte \tcap \tclose \tcomplex \tcomplex64 \tcomplex128 \tuint16\ncopy \tfalse \tfloat32 \tfloat64 \timag \tint \tint8 \tint16 \tuint32\nint32 \tint64 \tiota \tlen \tmake \tnew \tnil \tpanic \tuint64\nprint \tprintln \treal \trecover \tstring \ttrue \tuint \tuint8 \tuintptr\n\n## 二、数据类型 ##\n\n1、布尔类型\n\n2、数字类型\n\n>uint8 无符号 8 位整型 (0 到 255)\n>\n>uint16 无符号 16 位整型 (0 到 65535)\n>\n>uint32 无符号 32 位整型 (0 到 4294967295)\n>\n>uint64 无符号 64 位整型 (0 到 18446744073709551615)\n>\n>int8 有符号 8 位整型 (-128 到 127)\n>\n>int16 有符号 16 位整型 (-32768 到 32767)\n>\n>int32 有符号 32 位整型 (-2147483648 到 2147483647)\n>\n>int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)\n\nbyte 类似 uint8\nrune 类似 int32\nuint 32 或 64 位\nint 与 uint 一样大小\nuintptr 无符号整型，用于存放一个指针\n\n3、字符串类型\n\n4、派生类型：\n\t(a) 指针类型（Pointer）\n\t(b) 数组类型\n\t(c) 结构化类型(struct)\n\t(d) Channel 类型\n\t(e) 函数类型\n\t(f) 切片类型\n\t(g) 接口类型（interface）\n\t(h) Map 类型 \n\n## 三、变量与常量 ##\n\n| 数据类型 \t| 初始化默认值   |\n|-| :-:|\n| int \t\t| 0             |\n| float32 \t| 0             |\n| pointer \t| nil           |\n\n\n1、var 声明变量\n\n`var identifier type  //声明后若不赋值，则使用默认值\n\nvar v_name = value  //不声明类型时，执行类型推断，类似于Scala\n\nv_name := value`\n\n多变量声明：var a, b, c = a1, b1, c1\n\n2、const 声明常量\nconst可以用于枚举\n\n`const( \n\n  Unkonwn = 0\n\n  Female = 1\n\n  Male = 2\n\n)\n`\n\n常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过\n\n`\nconst(\n\ta = \"abc\"\n\tb = len(a)\n)\n`\n\n3、**iota 特殊常量**\n\n\n\t\n空白标识符'_'用于抛弃值，类似于Scala\n\t\n## 四、 ##\nGo语言循环中有：break、continue、goto\n\n\n\n## 五、函数 ##\n\nGo语言中全局变量和局部变量可以相同，函数内变量优先考虑\n\nGo函数可以返回多个值，这个比Java好很多\n\n`func swap(x, y string) (string, string){\n\treturn y, x\n}`\n\t\n值传递: 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\n\n引用传递: 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n\n**默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。**\n\n函数作为值传递，类似于Scala高阶函数\ngetSquareRoot := func(x float64) float64 {  //类似于Scala匿名函数\n    return math.Sqrt(x)\n}\n\n*Go支持匿名函数可以作为闭包，和Scala的闭包有什么区别？*\n\nGo语言中函数不同于方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。\n\n**接口类型(interface)**\n\n**方法集**\n\n\t\n## 六、 ##\n1、数组\n\n`\nvar array [size] arr_type\nvar array = [5]int{1,2,3,4,5}\n`\n\n2、切片：切片是对数组的抽象，数组长度不可变，切片是动态数组\n`\nvar slice [] slice_type\nvar slice [] slice_type = make([]slice_type, len)\nslice := make([]slice_type, len)\n`\n\n3、范围range 类似于Java在for-Each，Scala中<-遍历\nGo 语言中 range 关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。\n在数组和切片中它返回元素的索引值，在集合中返回 key-value 对的 key 值。 \n\n4、Map声明后必须make初始化，否则为nil，类似于Java的null\n\n`var cmap map[string]string\ncmap = make(map[string]string) `\n\n5、类型转换，不同于Java的向上向下转型\n\n`\nvar i int = 10\nfloat32(i)\n`\n\n\n结构体：类似于c语言的结构体\n\n结构体指针\n\n## 七、错误处理 ##\n\nGo语言通过内置的错误接口(error)提供了非常简单的错误处理机制。\n\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t","slug":"go-base","published":1,"updated":"2018-07-25T07:37:18.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde0k000kv0f0mus972b5","content":"<p>一段时间不写Go,很多东西都忘了，还是记录一下吧！</p>\n<h2 id=\"一、基础入门\"><a href=\"#一、基础入门\" class=\"headerlink\" title=\"一、基础入门\"></a>一、基础入门</h2><p><code>go run hello.go</code></p>\n<p>行分隔符：一行代表一个语句结束，不需要分号’;’，多个语句在一行使用’;’，类似于Scala</p>\n<p>25个关键字：</p>\n<p>break  default    func  interface     select<br>case    defer    go    map    struct<br>chan    else    goto    package    switch<br>const    fallthrough    if    range    type<br>continue    for    import    return    var</p>\n<a id=\"more\"></a>\n<p>36个预定义标识符:</p>\n<p>append     bool     byte     cap     close     complex     complex64     complex128     uint16<br>copy     false     float32     float64     imag     int     int8     int16     uint32<br>int32     int64     iota     len     make     new     nil     panic     uint64<br>print     println     real     recover     string     true     uint     uint8     uintptr</p>\n<h2 id=\"二、数据类型\"><a href=\"#二、数据类型\" class=\"headerlink\" title=\"二、数据类型\"></a>二、数据类型</h2><p>1、布尔类型</p>\n<p>2、数字类型</p>\n<blockquote>\n<p>uint8 无符号 8 位整型 (0 到 255)</p>\n<p>uint16 无符号 16 位整型 (0 到 65535)</p>\n<p>uint32 无符号 32 位整型 (0 到 4294967295)</p>\n<p>uint64 无符号 64 位整型 (0 到 18446744073709551615)</p>\n<p>int8 有符号 8 位整型 (-128 到 127)</p>\n<p>int16 有符号 16 位整型 (-32768 到 32767)</p>\n<p>int32 有符号 32 位整型 (-2147483648 到 2147483647)</p>\n<p>int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</p>\n</blockquote>\n<p>byte 类似 uint8<br>rune 类似 int32<br>uint 32 或 64 位<br>int 与 uint 一样大小<br>uintptr 无符号整型，用于存放一个指针</p>\n<p>3、字符串类型</p>\n<p>4、派生类型：<br>    (a) 指针类型（Pointer）<br>    (b) 数组类型<br>    (c) 结构化类型(struct)<br>    (d) Channel 类型<br>    (e) 函数类型<br>    (f) 切片类型<br>    (g) 接口类型（interface）<br>    (h) Map 类型 </p>\n<h2 id=\"三、变量与常量\"><a href=\"#三、变量与常量\" class=\"headerlink\" title=\"三、变量与常量\"></a>三、变量与常量</h2><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th style=\"text-align:center\">初始化默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td>float32</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td>pointer</td>\n<td style=\"text-align:center\">nil</td>\n</tr>\n</tbody>\n</table>\n<p>1、var 声明变量</p>\n<p>`var identifier type  //声明后若不赋值，则使用默认值</p>\n<p>var v_name = value  //不声明类型时，执行类型推断，类似于Scala</p>\n<p>v_name := value`</p>\n<p>多变量声明：var a, b, c = a1, b1, c1</p>\n<p>2、const 声明常量<br>const可以用于枚举</p>\n<p>`const( </p>\n<p>  Unkonwn = 0</p>\n<p>  Female = 1</p>\n<p>  Male = 2</p>\n<p>)<br>`</p>\n<p>常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过</p>\n<p><code>const(\n    a = &quot;abc&quot;\n    b = len(a)\n)</code></p>\n<p>3、<strong>iota 特殊常量</strong></p>\n<p>空白标识符’_’用于抛弃值，类似于Scala</p>\n<h2 id=\"四、\"><a href=\"#四、\" class=\"headerlink\" title=\"四、\"></a>四、</h2><p>Go语言循环中有：break、continue、goto</p>\n<h2 id=\"五、函数\"><a href=\"#五、函数\" class=\"headerlink\" title=\"五、函数\"></a>五、函数</h2><p>Go语言中全局变量和局部变量可以相同，函数内变量优先考虑</p>\n<p>Go函数可以返回多个值，这个比Java好很多</p>\n<p><code>func swap(x, y string) (string, string){\n    return y, x\n}</code></p>\n<p>值传递: 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>\n<p>引用传递: 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>\n<p><strong>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</strong></p>\n<p>函数作为值传递，类似于Scala高阶函数<br>getSquareRoot := func(x float64) float64 {  //类似于Scala匿名函数<br>    return math.Sqrt(x)<br>}</p>\n<p><em>Go支持匿名函数可以作为闭包，和Scala的闭包有什么区别？</em></p>\n<p>Go语言中函数不同于方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。</p>\n<p><strong>接口类型(interface)</strong></p>\n<p><strong>方法集</strong></p>\n<h2 id=\"六、\"><a href=\"#六、\" class=\"headerlink\" title=\"六、\"></a>六、</h2><p>1、数组</p>\n<p><code>var array [size] arr_type\nvar array = [5]int{1,2,3,4,5}</code></p>\n<p>2、切片：切片是对数组的抽象，数组长度不可变，切片是动态数组<br><code>var slice [] slice_type\nvar slice [] slice_type = make([]slice_type, len)\nslice := make([]slice_type, len)</code></p>\n<p>3、范围range 类似于Java在for-Each，Scala中&lt;-遍历<br>Go 语言中 range 关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。<br>在数组和切片中它返回元素的索引值，在集合中返回 key-value 对的 key 值。 </p>\n<p>4、Map声明后必须make初始化，否则为nil，类似于Java的null</p>\n<p><code>var cmap map[string]string\ncmap = make(map[string]string)</code></p>\n<p>5、类型转换，不同于Java的向上向下转型</p>\n<p><code>var i int = 10\nfloat32(i)</code></p>\n<p>结构体：类似于c语言的结构体</p>\n<p>结构体指针</p>\n<h2 id=\"七、错误处理\"><a href=\"#七、错误处理\" class=\"headerlink\" title=\"七、错误处理\"></a>七、错误处理</h2><p>Go语言通过内置的错误接口(error)提供了非常简单的错误处理机制。</p>\n","site":{"data":{}},"excerpt":"<p>一段时间不写Go,很多东西都忘了，还是记录一下吧！</p>\n<h2 id=\"一、基础入门\"><a href=\"#一、基础入门\" class=\"headerlink\" title=\"一、基础入门\"></a>一、基础入门</h2><p><code>go run hello.go</code></p>\n<p>行分隔符：一行代表一个语句结束，不需要分号’;’，多个语句在一行使用’;’，类似于Scala</p>\n<p>25个关键字：</p>\n<p>break  default    func  interface     select<br>case    defer    go    map    struct<br>chan    else    goto    package    switch<br>const    fallthrough    if    range    type<br>continue    for    import    return    var</p>","more":"<p>36个预定义标识符:</p>\n<p>append     bool     byte     cap     close     complex     complex64     complex128     uint16<br>copy     false     float32     float64     imag     int     int8     int16     uint32<br>int32     int64     iota     len     make     new     nil     panic     uint64<br>print     println     real     recover     string     true     uint     uint8     uintptr</p>\n<h2 id=\"二、数据类型\"><a href=\"#二、数据类型\" class=\"headerlink\" title=\"二、数据类型\"></a>二、数据类型</h2><p>1、布尔类型</p>\n<p>2、数字类型</p>\n<blockquote>\n<p>uint8 无符号 8 位整型 (0 到 255)</p>\n<p>uint16 无符号 16 位整型 (0 到 65535)</p>\n<p>uint32 无符号 32 位整型 (0 到 4294967295)</p>\n<p>uint64 无符号 64 位整型 (0 到 18446744073709551615)</p>\n<p>int8 有符号 8 位整型 (-128 到 127)</p>\n<p>int16 有符号 16 位整型 (-32768 到 32767)</p>\n<p>int32 有符号 32 位整型 (-2147483648 到 2147483647)</p>\n<p>int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</p>\n</blockquote>\n<p>byte 类似 uint8<br>rune 类似 int32<br>uint 32 或 64 位<br>int 与 uint 一样大小<br>uintptr 无符号整型，用于存放一个指针</p>\n<p>3、字符串类型</p>\n<p>4、派生类型：<br>    (a) 指针类型（Pointer）<br>    (b) 数组类型<br>    (c) 结构化类型(struct)<br>    (d) Channel 类型<br>    (e) 函数类型<br>    (f) 切片类型<br>    (g) 接口类型（interface）<br>    (h) Map 类型 </p>\n<h2 id=\"三、变量与常量\"><a href=\"#三、变量与常量\" class=\"headerlink\" title=\"三、变量与常量\"></a>三、变量与常量</h2><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th style=\"text-align:center\">初始化默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td>float32</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td>pointer</td>\n<td style=\"text-align:center\">nil</td>\n</tr>\n</tbody>\n</table>\n<p>1、var 声明变量</p>\n<p>`var identifier type  //声明后若不赋值，则使用默认值</p>\n<p>var v_name = value  //不声明类型时，执行类型推断，类似于Scala</p>\n<p>v_name := value`</p>\n<p>多变量声明：var a, b, c = a1, b1, c1</p>\n<p>2、const 声明常量<br>const可以用于枚举</p>\n<p>`const( </p>\n<p>  Unkonwn = 0</p>\n<p>  Female = 1</p>\n<p>  Male = 2</p>\n<p>)<br>`</p>\n<p>常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过</p>\n<p><code>const(\n    a = &quot;abc&quot;\n    b = len(a)\n)</code></p>\n<p>3、<strong>iota 特殊常量</strong></p>\n<p>空白标识符’_’用于抛弃值，类似于Scala</p>\n<h2 id=\"四、\"><a href=\"#四、\" class=\"headerlink\" title=\"四、\"></a>四、</h2><p>Go语言循环中有：break、continue、goto</p>\n<h2 id=\"五、函数\"><a href=\"#五、函数\" class=\"headerlink\" title=\"五、函数\"></a>五、函数</h2><p>Go语言中全局变量和局部变量可以相同，函数内变量优先考虑</p>\n<p>Go函数可以返回多个值，这个比Java好很多</p>\n<p><code>func swap(x, y string) (string, string){\n    return y, x\n}</code></p>\n<p>值传递: 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>\n<p>引用传递: 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>\n<p><strong>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</strong></p>\n<p>函数作为值传递，类似于Scala高阶函数<br>getSquareRoot := func(x float64) float64 {  //类似于Scala匿名函数<br>    return math.Sqrt(x)<br>}</p>\n<p><em>Go支持匿名函数可以作为闭包，和Scala的闭包有什么区别？</em></p>\n<p>Go语言中函数不同于方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。</p>\n<p><strong>接口类型(interface)</strong></p>\n<p><strong>方法集</strong></p>\n<h2 id=\"六、\"><a href=\"#六、\" class=\"headerlink\" title=\"六、\"></a>六、</h2><p>1、数组</p>\n<p><code>var array [size] arr_type\nvar array = [5]int{1,2,3,4,5}</code></p>\n<p>2、切片：切片是对数组的抽象，数组长度不可变，切片是动态数组<br><code>var slice [] slice_type\nvar slice [] slice_type = make([]slice_type, len)\nslice := make([]slice_type, len)</code></p>\n<p>3、范围range 类似于Java在for-Each，Scala中&lt;-遍历<br>Go 语言中 range 关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。<br>在数组和切片中它返回元素的索引值，在集合中返回 key-value 对的 key 值。 </p>\n<p>4、Map声明后必须make初始化，否则为nil，类似于Java的null</p>\n<p><code>var cmap map[string]string\ncmap = make(map[string]string)</code></p>\n<p>5、类型转换，不同于Java的向上向下转型</p>\n<p><code>var i int = 10\nfloat32(i)</code></p>\n<p>结构体：类似于c语言的结构体</p>\n<p>结构体指针</p>\n<h2 id=\"七、错误处理\"><a href=\"#七、错误处理\" class=\"headerlink\" title=\"七、错误处理\"></a>七、错误处理</h2><p>Go语言通过内置的错误接口(error)提供了非常简单的错误处理机制。</p>"},{"title":"java集合之ConcurrentHashMap","date":"2018-08-14T15:32:43.000Z","_content":"不同于HashMap,ConcurrentHashMap是线程安全的。\n\nput(K, V)\n\nget(Object)\n\ncontainsKey(Object)\n\nsize()\n\n<!-- more -->\n\n## put(K, V) ##\n\n \t@SuppressWarnings(\"unchecked\")\n    public V put(K key, V value) {\n        Segment<K,V> s;\n        if (value == null)\n            throw new NullPointerException();\n        // 第一次hash\n        int hash = hash(key);\n\n        // 第二次hash,得到segment的索引j\n        int j = (hash >>> segmentShift) & segmentMask;\n\n        // 用unsafe的方式获取segments[j]元素 (unsafe类提供原子操作)\n        if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck\n             (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment\n            s = ensureSegment(j);\n        \n        // 在segment.put中进行第三次hash\n        return s.put(key, hash, value, false);\n    }\n\nSegment中加锁\n\n\tfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\n        \t// 加锁，ReentrantLock的tryLock()\n            HashEntry<K,V> node = tryLock() ? null :\n                scanAndLockForPut(key, hash, value);\n            V oldValue;\n            try {\n                HashEntry<K,V>[] tab = table;\n                int index = (tab.length - 1) & hash;\n                HashEntry<K,V> first = entryAt(tab, index);\n                \n                // 遍历\n                for (HashEntry<K,V> e = first;;) {\n                    if (e != null) {\n                        K k;\n                        if ((k = e.key) == key ||\n                            (e.hash == hash && key.equals(k))) {\n                            oldValue = e.value;\n                            if (!onlyIfAbsent) {\n                                e.value = value;\n                                ++modCount;\n                            }\n                            break;\n                        }\n                        e = e.next;\n                    }\n                    else {\n                        if (node != null)\n                            node.setNext(first);\n                        else\n                            node = new HashEntry<K,V>(hash, key, value, first);\n                        int c = count + 1;\n                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                            rehash(node);\n                        else\n                            setEntryAt(tab, index, node);\n                        ++modCount;\n                        count = c;\n                        oldValue = null;\n                        break;\n                    }\n                }\n            } finally {\n            \t// 解锁\n                unlock();\n            }\n            return oldValue;\n        }\n\n## get(Object) ##\n\n\tpublic V get(Object key) {\n        Segment<K,V> s; // manually integrate access methods to reduce overhead\n        HashEntry<K,V>[] tab;\n        int h = hash(key);\n        long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n\n\t\t// UNSAFE原子获取\n        if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n            (tab = s.table) != null) {\n            for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                     (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n                 e != null; e = e.next) {\n                K k;\n                if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                    return e.value;\n            }\n        }\n        return null;\n    }\n\n## containsKey(Object) ##\n\n\t@SuppressWarnings(\"unchecked\")\n    public boolean containsKey(Object key) {\n        Segment<K,V> s; // same as get() except no need for volatile value read\n        HashEntry<K,V>[] tab;\n        int h = hash(key);\n        long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n        if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n            (tab = s.table) != null) {\n            for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                     (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n                 e != null; e = e.next) {\n                K k;\n                if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n可以看到其实containsKey(Object)和get(Object)实现是一致的\n\n## size() ##\n\n\tpublic int size() {\n        // Try a few times to get accurate count. On failure due to\n        // continuous async changes in table, resort to locking.\n        final Segment<K,V>[] segments = this.segments;\n        int size;\n        boolean overflow; // true if size overflows 32 bits\n        long sum;         // sum of modCounts\n        long last = 0L;   // previous sum\n        int retries = -1; // first iteration isn't retry\n        try {\n            for (;;) {\n                if (retries++ == RETRIES_BEFORE_LOCK) {\n                    for (int j = 0; j < segments.length; ++j)\n                        ensureSegment(j).lock(); // force creation\n                }\n                sum = 0L;\n                size = 0;\n                overflow = false;\n                for (int j = 0; j < segments.length; ++j) {\n                    Segment<K,V> seg = segmentAt(segments, j);\n                    if (seg != null) {\n                        sum += seg.modCount;\n                        int c = seg.count;\n                        if (c < 0 || (size += c) < 0)\n                            overflow = true;\n                    }\n                }\n                if (sum == last)\n                    break;\n                last = sum;\n            }\n        } finally {\n            if (retries > RETRIES_BEFORE_LOCK) {\n                for (int j = 0; j < segments.length; ++j)\n                    segmentAt(segments, j).unlock();\n            }\n        }\n        return overflow ? Integer.MAX_VALUE : size;\n    }\n\n可以看到当retries++ == RETRIES_BEFORE_LOCK = 2的时候，也就是说会重试3次，然后对每一个segment进行加锁。\n\nsum用来统计seg.modCount的个数，last用来记录上一次统计时sum的值。\n\n第一次统计：last=0, \n\n>如果sum=last=0，跳出for循环；\n>\n>如果sum不等于last，则last=sum；\n\n第二次统计：\n\n>如果sum=last，跳出for循环；\n>\n>如果sum不等于last，则last=sum；\n\n\t@SuppressWarnings(\"unchecked\")\n    private Segment<K,V> ensureSegment(int k) {\n        final Segment<K,V>[] ss = this.segments;\n        long u = (k << SSHIFT) + SBASE; // raw offset\n        Segment<K,V> seg;\n        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {\n            Segment<K,V> proto = ss[0]; // use segment 0 as prototype\n            int cap = proto.table.length;\n            float lf = proto.loadFactor;\n            int threshold = (int)(cap * lf);\n            HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];\n            if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n                == null) { // recheck\n                Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);\n                while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n                       == null) {\n\n\t\t\t\t\t// CAS算法\n                    if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                        break;\n                }\n            }\n        }\n        return seg;\n    }\n\n\n\t\t\t\t\t\n","source":"_posts/java-concurrenthashmap.md","raw":"---\ntitle: java集合之ConcurrentHashMap\ndate: 2018-08-14 23:32:43\ntags: java, 集合\ncategories: java\n---\n不同于HashMap,ConcurrentHashMap是线程安全的。\n\nput(K, V)\n\nget(Object)\n\ncontainsKey(Object)\n\nsize()\n\n<!-- more -->\n\n## put(K, V) ##\n\n \t@SuppressWarnings(\"unchecked\")\n    public V put(K key, V value) {\n        Segment<K,V> s;\n        if (value == null)\n            throw new NullPointerException();\n        // 第一次hash\n        int hash = hash(key);\n\n        // 第二次hash,得到segment的索引j\n        int j = (hash >>> segmentShift) & segmentMask;\n\n        // 用unsafe的方式获取segments[j]元素 (unsafe类提供原子操作)\n        if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck\n             (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment\n            s = ensureSegment(j);\n        \n        // 在segment.put中进行第三次hash\n        return s.put(key, hash, value, false);\n    }\n\nSegment中加锁\n\n\tfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\n        \t// 加锁，ReentrantLock的tryLock()\n            HashEntry<K,V> node = tryLock() ? null :\n                scanAndLockForPut(key, hash, value);\n            V oldValue;\n            try {\n                HashEntry<K,V>[] tab = table;\n                int index = (tab.length - 1) & hash;\n                HashEntry<K,V> first = entryAt(tab, index);\n                \n                // 遍历\n                for (HashEntry<K,V> e = first;;) {\n                    if (e != null) {\n                        K k;\n                        if ((k = e.key) == key ||\n                            (e.hash == hash && key.equals(k))) {\n                            oldValue = e.value;\n                            if (!onlyIfAbsent) {\n                                e.value = value;\n                                ++modCount;\n                            }\n                            break;\n                        }\n                        e = e.next;\n                    }\n                    else {\n                        if (node != null)\n                            node.setNext(first);\n                        else\n                            node = new HashEntry<K,V>(hash, key, value, first);\n                        int c = count + 1;\n                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                            rehash(node);\n                        else\n                            setEntryAt(tab, index, node);\n                        ++modCount;\n                        count = c;\n                        oldValue = null;\n                        break;\n                    }\n                }\n            } finally {\n            \t// 解锁\n                unlock();\n            }\n            return oldValue;\n        }\n\n## get(Object) ##\n\n\tpublic V get(Object key) {\n        Segment<K,V> s; // manually integrate access methods to reduce overhead\n        HashEntry<K,V>[] tab;\n        int h = hash(key);\n        long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n\n\t\t// UNSAFE原子获取\n        if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n            (tab = s.table) != null) {\n            for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                     (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n                 e != null; e = e.next) {\n                K k;\n                if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                    return e.value;\n            }\n        }\n        return null;\n    }\n\n## containsKey(Object) ##\n\n\t@SuppressWarnings(\"unchecked\")\n    public boolean containsKey(Object key) {\n        Segment<K,V> s; // same as get() except no need for volatile value read\n        HashEntry<K,V>[] tab;\n        int h = hash(key);\n        long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n        if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n            (tab = s.table) != null) {\n            for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                     (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n                 e != null; e = e.next) {\n                K k;\n                if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n可以看到其实containsKey(Object)和get(Object)实现是一致的\n\n## size() ##\n\n\tpublic int size() {\n        // Try a few times to get accurate count. On failure due to\n        // continuous async changes in table, resort to locking.\n        final Segment<K,V>[] segments = this.segments;\n        int size;\n        boolean overflow; // true if size overflows 32 bits\n        long sum;         // sum of modCounts\n        long last = 0L;   // previous sum\n        int retries = -1; // first iteration isn't retry\n        try {\n            for (;;) {\n                if (retries++ == RETRIES_BEFORE_LOCK) {\n                    for (int j = 0; j < segments.length; ++j)\n                        ensureSegment(j).lock(); // force creation\n                }\n                sum = 0L;\n                size = 0;\n                overflow = false;\n                for (int j = 0; j < segments.length; ++j) {\n                    Segment<K,V> seg = segmentAt(segments, j);\n                    if (seg != null) {\n                        sum += seg.modCount;\n                        int c = seg.count;\n                        if (c < 0 || (size += c) < 0)\n                            overflow = true;\n                    }\n                }\n                if (sum == last)\n                    break;\n                last = sum;\n            }\n        } finally {\n            if (retries > RETRIES_BEFORE_LOCK) {\n                for (int j = 0; j < segments.length; ++j)\n                    segmentAt(segments, j).unlock();\n            }\n        }\n        return overflow ? Integer.MAX_VALUE : size;\n    }\n\n可以看到当retries++ == RETRIES_BEFORE_LOCK = 2的时候，也就是说会重试3次，然后对每一个segment进行加锁。\n\nsum用来统计seg.modCount的个数，last用来记录上一次统计时sum的值。\n\n第一次统计：last=0, \n\n>如果sum=last=0，跳出for循环；\n>\n>如果sum不等于last，则last=sum；\n\n第二次统计：\n\n>如果sum=last，跳出for循环；\n>\n>如果sum不等于last，则last=sum；\n\n\t@SuppressWarnings(\"unchecked\")\n    private Segment<K,V> ensureSegment(int k) {\n        final Segment<K,V>[] ss = this.segments;\n        long u = (k << SSHIFT) + SBASE; // raw offset\n        Segment<K,V> seg;\n        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {\n            Segment<K,V> proto = ss[0]; // use segment 0 as prototype\n            int cap = proto.table.length;\n            float lf = proto.loadFactor;\n            int threshold = (int)(cap * lf);\n            HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];\n            if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n                == null) { // recheck\n                Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);\n                while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n                       == null) {\n\n\t\t\t\t\t// CAS算法\n                    if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                        break;\n                }\n            }\n        }\n        return seg;\n    }\n\n\n\t\t\t\t\t\n","slug":"java-concurrenthashmap","published":1,"updated":"2018-08-14T16:18:51.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde0p000nv0f09vauho5d","content":"<p>不同于HashMap,ConcurrentHashMap是线程安全的。</p>\n<p>put(K, V)</p>\n<p>get(Object)</p>\n<p>containsKey(Object)</p>\n<p>size()</p>\n<a id=\"more\"></a>\n<h2 id=\"put-K-V\"><a href=\"#put-K-V\" class=\"headerlink\" title=\"put(K, V)\"></a>put(K, V)</h2><pre><code> @SuppressWarnings(&quot;unchecked&quot;)\npublic V put(K key, V value) {\n    Segment&lt;K,V&gt; s;\n    if (value == null)\n        throw new NullPointerException();\n    // 第一次hash\n    int hash = hash(key);\n\n    // 第二次hash,得到segment的索引j\n    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;\n\n    // 用unsafe的方式获取segments[j]元素 (unsafe类提供原子操作)\n    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck\n         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment\n        s = ensureSegment(j);\n\n    // 在segment.put中进行第三次hash\n    return s.put(key, hash, value, false);\n}\n</code></pre><p>Segment中加锁</p>\n<pre><code>final V put(K key, int hash, V value, boolean onlyIfAbsent) {\n        // 加锁，ReentrantLock的tryLock()\n        HashEntry&lt;K,V&gt; node = tryLock() ? null :\n            scanAndLockForPut(key, hash, value);\n        V oldValue;\n        try {\n            HashEntry&lt;K,V&gt;[] tab = table;\n            int index = (tab.length - 1) &amp; hash;\n            HashEntry&lt;K,V&gt; first = entryAt(tab, index);\n\n            // 遍历\n            for (HashEntry&lt;K,V&gt; e = first;;) {\n                if (e != null) {\n                    K k;\n                    if ((k = e.key) == key ||\n                        (e.hash == hash &amp;&amp; key.equals(k))) {\n                        oldValue = e.value;\n                        if (!onlyIfAbsent) {\n                            e.value = value;\n                            ++modCount;\n                        }\n                        break;\n                    }\n                    e = e.next;\n                }\n                else {\n                    if (node != null)\n                        node.setNext(first);\n                    else\n                        node = new HashEntry&lt;K,V&gt;(hash, key, value, first);\n                    int c = count + 1;\n                    if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)\n                        rehash(node);\n                    else\n                        setEntryAt(tab, index, node);\n                    ++modCount;\n                    count = c;\n                    oldValue = null;\n                    break;\n                }\n            }\n        } finally {\n            // 解锁\n            unlock();\n        }\n        return oldValue;\n    }\n</code></pre><h2 id=\"get-Object\"><a href=\"#get-Object\" class=\"headerlink\" title=\"get(Object)\"></a>get(Object)</h2><pre><code>public V get(Object key) {\n    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead\n    HashEntry&lt;K,V&gt;[] tab;\n    int h = hash(key);\n    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;\n\n    // UNSAFE原子获取\n    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;\n        (tab = s.table) != null) {\n        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            K k;\n            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}\n</code></pre><h2 id=\"containsKey-Object\"><a href=\"#containsKey-Object\" class=\"headerlink\" title=\"containsKey(Object)\"></a>containsKey(Object)</h2><pre><code>@SuppressWarnings(&quot;unchecked&quot;)\npublic boolean containsKey(Object key) {\n    Segment&lt;K,V&gt; s; // same as get() except no need for volatile value read\n    HashEntry&lt;K,V&gt;[] tab;\n    int h = hash(key);\n    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;\n    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;\n        (tab = s.table) != null) {\n        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            K k;\n            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre><p>可以看到其实containsKey(Object)和get(Object)实现是一致的</p>\n<h2 id=\"size\"><a href=\"#size\" class=\"headerlink\" title=\"size()\"></a>size()</h2><pre><code>public int size() {\n    // Try a few times to get accurate count. On failure due to\n    // continuous async changes in table, resort to locking.\n    final Segment&lt;K,V&gt;[] segments = this.segments;\n    int size;\n    boolean overflow; // true if size overflows 32 bits\n    long sum;         // sum of modCounts\n    long last = 0L;   // previous sum\n    int retries = -1; // first iteration isn&apos;t retry\n    try {\n        for (;;) {\n            if (retries++ == RETRIES_BEFORE_LOCK) {\n                for (int j = 0; j &lt; segments.length; ++j)\n                    ensureSegment(j).lock(); // force creation\n            }\n            sum = 0L;\n            size = 0;\n            overflow = false;\n            for (int j = 0; j &lt; segments.length; ++j) {\n                Segment&lt;K,V&gt; seg = segmentAt(segments, j);\n                if (seg != null) {\n                    sum += seg.modCount;\n                    int c = seg.count;\n                    if (c &lt; 0 || (size += c) &lt; 0)\n                        overflow = true;\n                }\n            }\n            if (sum == last)\n                break;\n            last = sum;\n        }\n    } finally {\n        if (retries &gt; RETRIES_BEFORE_LOCK) {\n            for (int j = 0; j &lt; segments.length; ++j)\n                segmentAt(segments, j).unlock();\n        }\n    }\n    return overflow ? Integer.MAX_VALUE : size;\n}\n</code></pre><p>可以看到当retries++ == RETRIES_BEFORE_LOCK = 2的时候，也就是说会重试3次，然后对每一个segment进行加锁。</p>\n<p>sum用来统计seg.modCount的个数，last用来记录上一次统计时sum的值。</p>\n<p>第一次统计：last=0, </p>\n<blockquote>\n<p>如果sum=last=0，跳出for循环；</p>\n<p>如果sum不等于last，则last=sum；</p>\n</blockquote>\n<p>第二次统计：</p>\n<blockquote>\n<p>如果sum=last，跳出for循环；</p>\n<p>如果sum不等于last，则last=sum；</p>\n</blockquote>\n<pre><code>@SuppressWarnings(&quot;unchecked&quot;)\nprivate Segment&lt;K,V&gt; ensureSegment(int k) {\n    final Segment&lt;K,V&gt;[] ss = this.segments;\n    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset\n    Segment&lt;K,V&gt; seg;\n    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {\n        Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype\n        int cap = proto.table.length;\n        float lf = proto.loadFactor;\n        int threshold = (int)(cap * lf);\n        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];\n        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))\n            == null) { // recheck\n            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);\n            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))\n                   == null) {\n\n                // CAS算法\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}\n</code></pre>","site":{"data":{}},"excerpt":"<p>不同于HashMap,ConcurrentHashMap是线程安全的。</p>\n<p>put(K, V)</p>\n<p>get(Object)</p>\n<p>containsKey(Object)</p>\n<p>size()</p>","more":"<h2 id=\"put-K-V\"><a href=\"#put-K-V\" class=\"headerlink\" title=\"put(K, V)\"></a>put(K, V)</h2><pre><code> @SuppressWarnings(&quot;unchecked&quot;)\npublic V put(K key, V value) {\n    Segment&lt;K,V&gt; s;\n    if (value == null)\n        throw new NullPointerException();\n    // 第一次hash\n    int hash = hash(key);\n\n    // 第二次hash,得到segment的索引j\n    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;\n\n    // 用unsafe的方式获取segments[j]元素 (unsafe类提供原子操作)\n    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck\n         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment\n        s = ensureSegment(j);\n\n    // 在segment.put中进行第三次hash\n    return s.put(key, hash, value, false);\n}\n</code></pre><p>Segment中加锁</p>\n<pre><code>final V put(K key, int hash, V value, boolean onlyIfAbsent) {\n        // 加锁，ReentrantLock的tryLock()\n        HashEntry&lt;K,V&gt; node = tryLock() ? null :\n            scanAndLockForPut(key, hash, value);\n        V oldValue;\n        try {\n            HashEntry&lt;K,V&gt;[] tab = table;\n            int index = (tab.length - 1) &amp; hash;\n            HashEntry&lt;K,V&gt; first = entryAt(tab, index);\n\n            // 遍历\n            for (HashEntry&lt;K,V&gt; e = first;;) {\n                if (e != null) {\n                    K k;\n                    if ((k = e.key) == key ||\n                        (e.hash == hash &amp;&amp; key.equals(k))) {\n                        oldValue = e.value;\n                        if (!onlyIfAbsent) {\n                            e.value = value;\n                            ++modCount;\n                        }\n                        break;\n                    }\n                    e = e.next;\n                }\n                else {\n                    if (node != null)\n                        node.setNext(first);\n                    else\n                        node = new HashEntry&lt;K,V&gt;(hash, key, value, first);\n                    int c = count + 1;\n                    if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)\n                        rehash(node);\n                    else\n                        setEntryAt(tab, index, node);\n                    ++modCount;\n                    count = c;\n                    oldValue = null;\n                    break;\n                }\n            }\n        } finally {\n            // 解锁\n            unlock();\n        }\n        return oldValue;\n    }\n</code></pre><h2 id=\"get-Object\"><a href=\"#get-Object\" class=\"headerlink\" title=\"get(Object)\"></a>get(Object)</h2><pre><code>public V get(Object key) {\n    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead\n    HashEntry&lt;K,V&gt;[] tab;\n    int h = hash(key);\n    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;\n\n    // UNSAFE原子获取\n    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;\n        (tab = s.table) != null) {\n        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            K k;\n            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}\n</code></pre><h2 id=\"containsKey-Object\"><a href=\"#containsKey-Object\" class=\"headerlink\" title=\"containsKey(Object)\"></a>containsKey(Object)</h2><pre><code>@SuppressWarnings(&quot;unchecked&quot;)\npublic boolean containsKey(Object key) {\n    Segment&lt;K,V&gt; s; // same as get() except no need for volatile value read\n    HashEntry&lt;K,V&gt;[] tab;\n    int h = hash(key);\n    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;\n    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;\n        (tab = s.table) != null) {\n        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            K k;\n            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre><p>可以看到其实containsKey(Object)和get(Object)实现是一致的</p>\n<h2 id=\"size\"><a href=\"#size\" class=\"headerlink\" title=\"size()\"></a>size()</h2><pre><code>public int size() {\n    // Try a few times to get accurate count. On failure due to\n    // continuous async changes in table, resort to locking.\n    final Segment&lt;K,V&gt;[] segments = this.segments;\n    int size;\n    boolean overflow; // true if size overflows 32 bits\n    long sum;         // sum of modCounts\n    long last = 0L;   // previous sum\n    int retries = -1; // first iteration isn&apos;t retry\n    try {\n        for (;;) {\n            if (retries++ == RETRIES_BEFORE_LOCK) {\n                for (int j = 0; j &lt; segments.length; ++j)\n                    ensureSegment(j).lock(); // force creation\n            }\n            sum = 0L;\n            size = 0;\n            overflow = false;\n            for (int j = 0; j &lt; segments.length; ++j) {\n                Segment&lt;K,V&gt; seg = segmentAt(segments, j);\n                if (seg != null) {\n                    sum += seg.modCount;\n                    int c = seg.count;\n                    if (c &lt; 0 || (size += c) &lt; 0)\n                        overflow = true;\n                }\n            }\n            if (sum == last)\n                break;\n            last = sum;\n        }\n    } finally {\n        if (retries &gt; RETRIES_BEFORE_LOCK) {\n            for (int j = 0; j &lt; segments.length; ++j)\n                segmentAt(segments, j).unlock();\n        }\n    }\n    return overflow ? Integer.MAX_VALUE : size;\n}\n</code></pre><p>可以看到当retries++ == RETRIES_BEFORE_LOCK = 2的时候，也就是说会重试3次，然后对每一个segment进行加锁。</p>\n<p>sum用来统计seg.modCount的个数，last用来记录上一次统计时sum的值。</p>\n<p>第一次统计：last=0, </p>\n<blockquote>\n<p>如果sum=last=0，跳出for循环；</p>\n<p>如果sum不等于last，则last=sum；</p>\n</blockquote>\n<p>第二次统计：</p>\n<blockquote>\n<p>如果sum=last，跳出for循环；</p>\n<p>如果sum不等于last，则last=sum；</p>\n</blockquote>\n<pre><code>@SuppressWarnings(&quot;unchecked&quot;)\nprivate Segment&lt;K,V&gt; ensureSegment(int k) {\n    final Segment&lt;K,V&gt;[] ss = this.segments;\n    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset\n    Segment&lt;K,V&gt; seg;\n    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {\n        Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype\n        int cap = proto.table.length;\n        float lf = proto.loadFactor;\n        int threshold = (int)(cap * lf);\n        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];\n        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))\n            == null) { // recheck\n            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);\n            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))\n                   == null) {\n\n                // CAS算法\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}\n</code></pre>"},{"title":"java-jvm","date":"2018-08-07T09:31:33.000Z","_content":"","source":"_posts/java-jvm.md","raw":"---\ntitle: java-jvm\ndate: 2018-08-07 17:31:33\ntags:\n---\n","slug":"java-jvm","published":1,"updated":"2018-08-07T09:31:33.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde0s000pv0f0r6nnqbhi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java注解","date":"2018-08-13T11:33:36.000Z","_content":"Spring Boot封装了很多的注解类，所以回顾一下注解\n\n## java内置注解 ##\n\n### 3种标准注解： ###\n\n@Override\n\n@Desprecated\n\n@Suppress Warnings\n\n<!-- more -->\n\n### 4种元注解： ###\n\n@Target: 表示注解用于什么地方\n\n\tElementType.CONSTRUCTOR\n\tElementType.FIELD\n\tElementType.LOCAL_VARIABLE\n\tElementType.METHOD\n\tElementType.PACKAGE\n\tElementType.PARAMETER\n\tElementType.TYPE\n\n@Retention: 表示需要在什么级别保存该注解信息\n\t\n\tRetentionPolicy.SOURCE\n\tRetentionPolicy.CLASS\n\tRetentionPolicy.RUNTIME\n\n@Documented: 将此注解包含在Javadoc中\n\n@Inherited: 允许子类继承父类中的注解\n\n标记注解：没有元素的注解\n\n例如：\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface Test{}\n\n\n注解元素的种类：\n\n> 所有基本类型\n> \n> String\n> \n> Class\n> \n> enum\n> \n> Annotation\n> \n> 以上所有类型的数组\n\n\n**注意:**不允许使用任何包装类型\n\n注解的一些默认规则：\n\n1、元素不能有不确认的值\n\n2、对于非基本类型的值，无论在源代码中声明，或者在注解接口中定义默认值都不能以null作为其值\n\n例如：\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface Test{\n\t\tpublic int id() default -1;\n\t\tpublic String description() default \"\";\n\t}\n\n### 注解嵌套：注解作为注解的元素 ###\n\n例如：\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface Test{\n\t\tpublic int id() default -1;\n\t\tpublic String description() default \"\";\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface Test2{\n\t\tpublic int sid() default -1;\n\t\tpublic Test test() default @Test;\n\t}\n\t\n\t@Test2(sid = 10, test = @Test(description=\"test\"))\n\tString testAnnotation;\n\n### 组合注解：注解上除了元注解，还会有其他的注解 ###\n\n例如：\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\t@Inherited\n\t@SpringBootConfiguration\n\t@EnableAutoConfiguration\n\t@ComponentScan(excludeFilters = {\n\t\t@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\n\tpublic @interface SpringBootApplication {\n\t\t...\n\t}\n\n可以看到SpringBootApplication注解除了元注解，还有@SpringBootConfiguration、@EnableAutoCOnfiguration、@ComponentScan注解\n\n\n### 条件注解 ###","source":"_posts/java-annotation.md","raw":"---\ntitle: java注解\ndate: 2018-08-13 19:33:36\ntags: java, annotation\ncategories: java\n---\nSpring Boot封装了很多的注解类，所以回顾一下注解\n\n## java内置注解 ##\n\n### 3种标准注解： ###\n\n@Override\n\n@Desprecated\n\n@Suppress Warnings\n\n<!-- more -->\n\n### 4种元注解： ###\n\n@Target: 表示注解用于什么地方\n\n\tElementType.CONSTRUCTOR\n\tElementType.FIELD\n\tElementType.LOCAL_VARIABLE\n\tElementType.METHOD\n\tElementType.PACKAGE\n\tElementType.PARAMETER\n\tElementType.TYPE\n\n@Retention: 表示需要在什么级别保存该注解信息\n\t\n\tRetentionPolicy.SOURCE\n\tRetentionPolicy.CLASS\n\tRetentionPolicy.RUNTIME\n\n@Documented: 将此注解包含在Javadoc中\n\n@Inherited: 允许子类继承父类中的注解\n\n标记注解：没有元素的注解\n\n例如：\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface Test{}\n\n\n注解元素的种类：\n\n> 所有基本类型\n> \n> String\n> \n> Class\n> \n> enum\n> \n> Annotation\n> \n> 以上所有类型的数组\n\n\n**注意:**不允许使用任何包装类型\n\n注解的一些默认规则：\n\n1、元素不能有不确认的值\n\n2、对于非基本类型的值，无论在源代码中声明，或者在注解接口中定义默认值都不能以null作为其值\n\n例如：\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface Test{\n\t\tpublic int id() default -1;\n\t\tpublic String description() default \"\";\n\t}\n\n### 注解嵌套：注解作为注解的元素 ###\n\n例如：\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface Test{\n\t\tpublic int id() default -1;\n\t\tpublic String description() default \"\";\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface Test2{\n\t\tpublic int sid() default -1;\n\t\tpublic Test test() default @Test;\n\t}\n\t\n\t@Test2(sid = 10, test = @Test(description=\"test\"))\n\tString testAnnotation;\n\n### 组合注解：注解上除了元注解，还会有其他的注解 ###\n\n例如：\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\t@Inherited\n\t@SpringBootConfiguration\n\t@EnableAutoConfiguration\n\t@ComponentScan(excludeFilters = {\n\t\t@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\n\tpublic @interface SpringBootApplication {\n\t\t...\n\t}\n\n可以看到SpringBootApplication注解除了元注解，还有@SpringBootConfiguration、@EnableAutoCOnfiguration、@ComponentScan注解\n\n\n### 条件注解 ###","slug":"java-annotation","published":1,"updated":"2018-08-13T12:15:15.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde0w000tv0f0i9itrhnq","content":"<p>Spring Boot封装了很多的注解类，所以回顾一下注解</p>\n<h2 id=\"java内置注解\"><a href=\"#java内置注解\" class=\"headerlink\" title=\"java内置注解\"></a>java内置注解</h2><h3 id=\"3种标准注解：\"><a href=\"#3种标准注解：\" class=\"headerlink\" title=\"3种标准注解：\"></a>3种标准注解：</h3><p>@Override</p>\n<p>@Desprecated</p>\n<p>@Suppress Warnings</p>\n<a id=\"more\"></a>\n<h3 id=\"4种元注解：\"><a href=\"#4种元注解：\" class=\"headerlink\" title=\"4种元注解：\"></a>4种元注解：</h3><p>@Target: 表示注解用于什么地方</p>\n<pre><code>ElementType.CONSTRUCTOR\nElementType.FIELD\nElementType.LOCAL_VARIABLE\nElementType.METHOD\nElementType.PACKAGE\nElementType.PARAMETER\nElementType.TYPE\n</code></pre><p>@Retention: 表示需要在什么级别保存该注解信息</p>\n<pre><code>RetentionPolicy.SOURCE\nRetentionPolicy.CLASS\nRetentionPolicy.RUNTIME\n</code></pre><p>@Documented: 将此注解包含在Javadoc中</p>\n<p>@Inherited: 允许子类继承父类中的注解</p>\n<p>标记注解：没有元素的注解</p>\n<p>例如：</p>\n<pre><code>@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test{}\n</code></pre><p>注解元素的种类：</p>\n<blockquote>\n<p>所有基本类型</p>\n<p>String</p>\n<p>Class</p>\n<p>enum</p>\n<p>Annotation</p>\n<p>以上所有类型的数组</p>\n</blockquote>\n<p><strong>注意:</strong>不允许使用任何包装类型</p>\n<p>注解的一些默认规则：</p>\n<p>1、元素不能有不确认的值</p>\n<p>2、对于非基本类型的值，无论在源代码中声明，或者在注解接口中定义默认值都不能以null作为其值</p>\n<p>例如：</p>\n<pre><code>@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test{\n    public int id() default -1;\n    public String description() default &quot;&quot;;\n}\n</code></pre><h3 id=\"注解嵌套：注解作为注解的元素\"><a href=\"#注解嵌套：注解作为注解的元素\" class=\"headerlink\" title=\"注解嵌套：注解作为注解的元素\"></a>注解嵌套：注解作为注解的元素</h3><p>例如：<br>    @Target(ElementType.METHOD)<br>    @Retention(RetentionPolicy.RUNTIME)<br>    public @interface Test{<br>        public int id() default -1;<br>        public String description() default “”;<br>    }</p>\n<pre><code>@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test2{\n    public int sid() default -1;\n    public Test test() default @Test;\n}\n\n@Test2(sid = 10, test = @Test(description=&quot;test&quot;))\nString testAnnotation;\n</code></pre><h3 id=\"组合注解：注解上除了元注解，还会有其他的注解\"><a href=\"#组合注解：注解上除了元注解，还会有其他的注解\" class=\"headerlink\" title=\"组合注解：注解上除了元注解，还会有其他的注解\"></a>组合注解：注解上除了元注解，还会有其他的注解</h3><p>例如：</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n    @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n    @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n    ...\n}\n</code></pre><p>可以看到SpringBootApplication注解除了元注解，还有@SpringBootConfiguration、@EnableAutoCOnfiguration、@ComponentScan注解</p>\n<h3 id=\"条件注解\"><a href=\"#条件注解\" class=\"headerlink\" title=\"条件注解\"></a>条件注解</h3>","site":{"data":{}},"excerpt":"<p>Spring Boot封装了很多的注解类，所以回顾一下注解</p>\n<h2 id=\"java内置注解\"><a href=\"#java内置注解\" class=\"headerlink\" title=\"java内置注解\"></a>java内置注解</h2><h3 id=\"3种标准注解：\"><a href=\"#3种标准注解：\" class=\"headerlink\" title=\"3种标准注解：\"></a>3种标准注解：</h3><p>@Override</p>\n<p>@Desprecated</p>\n<p>@Suppress Warnings</p>","more":"<h3 id=\"4种元注解：\"><a href=\"#4种元注解：\" class=\"headerlink\" title=\"4种元注解：\"></a>4种元注解：</h3><p>@Target: 表示注解用于什么地方</p>\n<pre><code>ElementType.CONSTRUCTOR\nElementType.FIELD\nElementType.LOCAL_VARIABLE\nElementType.METHOD\nElementType.PACKAGE\nElementType.PARAMETER\nElementType.TYPE\n</code></pre><p>@Retention: 表示需要在什么级别保存该注解信息</p>\n<pre><code>RetentionPolicy.SOURCE\nRetentionPolicy.CLASS\nRetentionPolicy.RUNTIME\n</code></pre><p>@Documented: 将此注解包含在Javadoc中</p>\n<p>@Inherited: 允许子类继承父类中的注解</p>\n<p>标记注解：没有元素的注解</p>\n<p>例如：</p>\n<pre><code>@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test{}\n</code></pre><p>注解元素的种类：</p>\n<blockquote>\n<p>所有基本类型</p>\n<p>String</p>\n<p>Class</p>\n<p>enum</p>\n<p>Annotation</p>\n<p>以上所有类型的数组</p>\n</blockquote>\n<p><strong>注意:</strong>不允许使用任何包装类型</p>\n<p>注解的一些默认规则：</p>\n<p>1、元素不能有不确认的值</p>\n<p>2、对于非基本类型的值，无论在源代码中声明，或者在注解接口中定义默认值都不能以null作为其值</p>\n<p>例如：</p>\n<pre><code>@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test{\n    public int id() default -1;\n    public String description() default &quot;&quot;;\n}\n</code></pre><h3 id=\"注解嵌套：注解作为注解的元素\"><a href=\"#注解嵌套：注解作为注解的元素\" class=\"headerlink\" title=\"注解嵌套：注解作为注解的元素\"></a>注解嵌套：注解作为注解的元素</h3><p>例如：<br>    @Target(ElementType.METHOD)<br>    @Retention(RetentionPolicy.RUNTIME)<br>    public @interface Test{<br>        public int id() default -1;<br>        public String description() default “”;<br>    }</p>\n<pre><code>@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test2{\n    public int sid() default -1;\n    public Test test() default @Test;\n}\n\n@Test2(sid = 10, test = @Test(description=&quot;test&quot;))\nString testAnnotation;\n</code></pre><h3 id=\"组合注解：注解上除了元注解，还会有其他的注解\"><a href=\"#组合注解：注解上除了元注解，还会有其他的注解\" class=\"headerlink\" title=\"组合注解：注解上除了元注解，还会有其他的注解\"></a>组合注解：注解上除了元注解，还会有其他的注解</h3><p>例如：</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n    @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n    @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n    ...\n}\n</code></pre><p>可以看到SpringBootApplication注解除了元注解，还有@SpringBootConfiguration、@EnableAutoCOnfiguration、@ComponentScan注解</p>\n<h3 id=\"条件注解\"><a href=\"#条件注解\" class=\"headerlink\" title=\"条件注解\"></a>条件注解</h3>"},{"title":"java集合之HashMap","date":"2018-08-09T09:26:39.000Z","_content":"基于平常很少会看底层的实现，又频繁用到这些，所以简单看一下HashMap中几个主要方法的底层实现：\n\nput(K, V)\n\nresize(int)\n\nget(Object)\n\ncontainsKey(Object)\n\nsize()\n\n<!-- more -->\n\n## put(K, V)方法 ##\n\tpublic V put(K key, V value) {\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n        if (key == null)\n            return putForNullKey(value);\n\t\t// 先对map做一次查找，查看是否包含该元组，如果存在，则直接返回\n        int hash = hash(key);\n        // 返回 h & (table.length-1)\n        int i = indexFor(hash, table.length);\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\t\t// 每次对map修改一次，modCount加1\n        modCount++;\n\t\t// i：bucketIndex\n        addEntry(hash, key, value, i);\n        return null;\n    }\n\t\n\t// 添加\n\tvoid addEntry(int hash, K key, V value, int bucketIndex) {\n        if ((size >= threshold) && (null != table[bucketIndex])) {\n\t\t\t//自动扩容，并重新哈希\n            resize(2 * table.length);\n            hash = (null != key) ? hash(key) : 0;\n            bucketIndex = indexFor(hash, table.length);\n        }\n\n        createEntry(hash, key, value, bucketIndex);\n    }\n\n\t// 在冲突链表头部插入新的entry\n    void createEntry(int hash, K key, V value, int bucketIndex) {\n        Entry<K,V> e = table[bucketIndex];\n        table[bucketIndex] = new Entry<>(hash, key, value, e);\n        size++;\n    }\n\n\tstatic class Entry<K,V> implements Map.Entry<K,V> {\n        final K key;\n        V value;\n        Entry<K,V> next;\n        int hash;\n\n\t\t...\n\t}\n\n可以看到先通过hash(key)和table.length求得一个下标i，然后去遍历table[i]后面的Entry<K,V>链表,查找是否已经存储过该对象，如果存储过，则返回存储的e.value，并且重新赋值新的value；否则添加Entry\n\n扩容机制可以看到，如果size > threshold，则执行resize(2 * table.length)，\n\n1. 在new HashMap()中默认threashold = DEFAULT_INITIAL_CAPACITY=16，否则为自定义值\n2. 在put(K,V)的时候先执行了inflateTable(threshold)，inflateTable中int capacity = roundUpToPowerOf2(toSize)，\n3. 所以inflateTable后现在threshold = capacity*0.75；\n\n同时可以看到在createEntry中size++，即当元素个数>=0.75capacity时，扩容为2table.length = 2capacity\n\n\tprivate void inflateTable(int toSize) {\n        // Find a power of 2 >= toSize\n        int capacity = roundUpToPowerOf2(toSize);\n\n        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n        table = new Entry[capacity];\n        initHashSeedAsNeeded(capacity);\n    }\n\n\tprivate static int roundUpToPowerOf2(int number) {\n        // assert number >= 0 : \"number must be non-negative\";\n        return number >= MAXIMUM_CAPACITY\n                ? MAXIMUM_CAPACITY\n                : (number > 1) ? Integer.highestOneBit((number - 1) << 1) : 1;\n    }\n\n\t\n## resize(int)方法 ##\n\n\tvoid resize(int newCapacity) {\n        Entry[] oldTable = table;\n        int oldCapacity = oldTable.length;\n            threshold = Integer.MAX_VALUE;\n            if (oldCapacity == MAXIMUM_CAPACITY) {\n            return;\n        }\n\n        Entry[] newTable = new Entry[newCapacity];\n\t\t\n\t\t// 扩容后进行重hash操作\n        transfer(newTable, initHashSeedAsNeeded(newCapacity));\n        table = newTable;\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    }\n\n\tvoid transfer(Entry[] newTable, boolean rehash) {\n        int newCapacity = newTable.length;\n\t\t\n\t\t// 遍历元素重hash\n        for (Entry<K,V> e : table) {\n            while(null != e) {\n                Entry<K,V> next = e.next;\n                if (rehash) {\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                }\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            }\n        }\n    }\n\n可以看到在resize后，要对所有的元素重hash进行存储\n\n## get(Object) ##\n\n\tpublic V get(Object key) {\n        if (key == null)\n            return getForNullKey();\n        Entry<K,V> entry = getEntry(key);\n\n        return null == entry ? null : entry.getValue();\n    }\n\n\tfinal Entry<K,V> getEntry(Object key) {\n        if (size == 0) {\n            return null;\n        }\n\n\t\t//先通过hash()函数得到key对应buckets的下标，然后依次遍历冲突链表\n        int hash = (key == null) ? 0 : hash(key);\n        for (Entry<K,V> e = table[indexFor(hash, table.length)];\n             e != null;\n             e = e.next) {\n            Object k;\n            if (e.hash == hash &&\n                ((k = e.key) == key || (key != null && key.equals(k))))\n                return e;\n        }\n        return null;\n    }\n可以看到其实查找元素就是先通过hash(key)定位到数组，然后再去遍历数组后的链表\n\n## containsKey(Object) ##\n\n\tpublic boolean containsKey(Object key) {\n        return getEntry(key) != null;\n    }\n\n可以看到其实containsKey(Object)走的也是一个get(Object)\n\n## size() ##\n\n\tpublic int size() {\n        return size;\n    }\n可以看到HashMap查找长度，其实就是返回了一个属性，Java集合中大多都是返回size属性，不同的是ConcurrentHashMap需要实时去查找。因为ConcurrentHashMap是线程安全的","source":"_posts/java-hashmap.md","raw":"---\ntitle: java集合之HashMap\ndate: 2018-08-09 17:26:39\ntags: java, 集合\ncategories: java\n---\n基于平常很少会看底层的实现，又频繁用到这些，所以简单看一下HashMap中几个主要方法的底层实现：\n\nput(K, V)\n\nresize(int)\n\nget(Object)\n\ncontainsKey(Object)\n\nsize()\n\n<!-- more -->\n\n## put(K, V)方法 ##\n\tpublic V put(K key, V value) {\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n        if (key == null)\n            return putForNullKey(value);\n\t\t// 先对map做一次查找，查看是否包含该元组，如果存在，则直接返回\n        int hash = hash(key);\n        // 返回 h & (table.length-1)\n        int i = indexFor(hash, table.length);\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\t\t// 每次对map修改一次，modCount加1\n        modCount++;\n\t\t// i：bucketIndex\n        addEntry(hash, key, value, i);\n        return null;\n    }\n\t\n\t// 添加\n\tvoid addEntry(int hash, K key, V value, int bucketIndex) {\n        if ((size >= threshold) && (null != table[bucketIndex])) {\n\t\t\t//自动扩容，并重新哈希\n            resize(2 * table.length);\n            hash = (null != key) ? hash(key) : 0;\n            bucketIndex = indexFor(hash, table.length);\n        }\n\n        createEntry(hash, key, value, bucketIndex);\n    }\n\n\t// 在冲突链表头部插入新的entry\n    void createEntry(int hash, K key, V value, int bucketIndex) {\n        Entry<K,V> e = table[bucketIndex];\n        table[bucketIndex] = new Entry<>(hash, key, value, e);\n        size++;\n    }\n\n\tstatic class Entry<K,V> implements Map.Entry<K,V> {\n        final K key;\n        V value;\n        Entry<K,V> next;\n        int hash;\n\n\t\t...\n\t}\n\n可以看到先通过hash(key)和table.length求得一个下标i，然后去遍历table[i]后面的Entry<K,V>链表,查找是否已经存储过该对象，如果存储过，则返回存储的e.value，并且重新赋值新的value；否则添加Entry\n\n扩容机制可以看到，如果size > threshold，则执行resize(2 * table.length)，\n\n1. 在new HashMap()中默认threashold = DEFAULT_INITIAL_CAPACITY=16，否则为自定义值\n2. 在put(K,V)的时候先执行了inflateTable(threshold)，inflateTable中int capacity = roundUpToPowerOf2(toSize)，\n3. 所以inflateTable后现在threshold = capacity*0.75；\n\n同时可以看到在createEntry中size++，即当元素个数>=0.75capacity时，扩容为2table.length = 2capacity\n\n\tprivate void inflateTable(int toSize) {\n        // Find a power of 2 >= toSize\n        int capacity = roundUpToPowerOf2(toSize);\n\n        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n        table = new Entry[capacity];\n        initHashSeedAsNeeded(capacity);\n    }\n\n\tprivate static int roundUpToPowerOf2(int number) {\n        // assert number >= 0 : \"number must be non-negative\";\n        return number >= MAXIMUM_CAPACITY\n                ? MAXIMUM_CAPACITY\n                : (number > 1) ? Integer.highestOneBit((number - 1) << 1) : 1;\n    }\n\n\t\n## resize(int)方法 ##\n\n\tvoid resize(int newCapacity) {\n        Entry[] oldTable = table;\n        int oldCapacity = oldTable.length;\n            threshold = Integer.MAX_VALUE;\n            if (oldCapacity == MAXIMUM_CAPACITY) {\n            return;\n        }\n\n        Entry[] newTable = new Entry[newCapacity];\n\t\t\n\t\t// 扩容后进行重hash操作\n        transfer(newTable, initHashSeedAsNeeded(newCapacity));\n        table = newTable;\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    }\n\n\tvoid transfer(Entry[] newTable, boolean rehash) {\n        int newCapacity = newTable.length;\n\t\t\n\t\t// 遍历元素重hash\n        for (Entry<K,V> e : table) {\n            while(null != e) {\n                Entry<K,V> next = e.next;\n                if (rehash) {\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                }\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            }\n        }\n    }\n\n可以看到在resize后，要对所有的元素重hash进行存储\n\n## get(Object) ##\n\n\tpublic V get(Object key) {\n        if (key == null)\n            return getForNullKey();\n        Entry<K,V> entry = getEntry(key);\n\n        return null == entry ? null : entry.getValue();\n    }\n\n\tfinal Entry<K,V> getEntry(Object key) {\n        if (size == 0) {\n            return null;\n        }\n\n\t\t//先通过hash()函数得到key对应buckets的下标，然后依次遍历冲突链表\n        int hash = (key == null) ? 0 : hash(key);\n        for (Entry<K,V> e = table[indexFor(hash, table.length)];\n             e != null;\n             e = e.next) {\n            Object k;\n            if (e.hash == hash &&\n                ((k = e.key) == key || (key != null && key.equals(k))))\n                return e;\n        }\n        return null;\n    }\n可以看到其实查找元素就是先通过hash(key)定位到数组，然后再去遍历数组后的链表\n\n## containsKey(Object) ##\n\n\tpublic boolean containsKey(Object key) {\n        return getEntry(key) != null;\n    }\n\n可以看到其实containsKey(Object)走的也是一个get(Object)\n\n## size() ##\n\n\tpublic int size() {\n        return size;\n    }\n可以看到HashMap查找长度，其实就是返回了一个属性，Java集合中大多都是返回size属性，不同的是ConcurrentHashMap需要实时去查找。因为ConcurrentHashMap是线程安全的","slug":"java-hashmap","published":1,"updated":"2018-08-14T15:35:22.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde0y000vv0f0yypfc0bd","content":"<p>基于平常很少会看底层的实现，又频繁用到这些，所以简单看一下HashMap中几个主要方法的底层实现：</p>\n<p>put(K, V)</p>\n<p>resize(int)</p>\n<p>get(Object)</p>\n<p>containsKey(Object)</p>\n<p>size()</p>\n<a id=\"more\"></a>\n<h2 id=\"put-K-V-方法\"><a href=\"#put-K-V-方法\" class=\"headerlink\" title=\"put(K, V)方法\"></a>put(K, V)方法</h2><pre><code>public V put(K key, V value) {\n    if (table == EMPTY_TABLE) {\n        inflateTable(threshold);\n    }\n    if (key == null)\n        return putForNullKey(value);\n    // 先对map做一次查找，查看是否包含该元组，如果存在，则直接返回\n    int hash = hash(key);\n    // 返回 h &amp; (table.length-1)\n    int i = indexFor(hash, table.length);\n    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    // 每次对map修改一次，modCount加1\n    modCount++;\n    // i：bucketIndex\n    addEntry(hash, key, value, i);\n    return null;\n}\n\n// 添加\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {\n        //自动扩容，并重新哈希\n        resize(2 * table.length);\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = indexFor(hash, table.length);\n    }\n\n    createEntry(hash, key, value, bucketIndex);\n}\n\n// 在冲突链表头部插入新的entry\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n    Entry&lt;K,V&gt; e = table[bucketIndex];\n    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);\n    size++;\n}\n\nstatic class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n    final K key;\n    V value;\n    Entry&lt;K,V&gt; next;\n    int hash;\n\n    ...\n}\n</code></pre><p>可以看到先通过hash(key)和table.length求得一个下标i，然后去遍历table[i]后面的Entry&lt;K,V&gt;链表,查找是否已经存储过该对象，如果存储过，则返回存储的e.value，并且重新赋值新的value；否则添加Entry</p>\n<p>扩容机制可以看到，如果size &gt; threshold，则执行resize(2 * table.length)，</p>\n<ol>\n<li>在new HashMap()中默认threashold = DEFAULT_INITIAL_CAPACITY=16，否则为自定义值</li>\n<li>在put(K,V)的时候先执行了inflateTable(threshold)，inflateTable中int capacity = roundUpToPowerOf2(toSize)，</li>\n<li>所以inflateTable后现在threshold = capacity*0.75；</li>\n</ol>\n<p>同时可以看到在createEntry中size++，即当元素个数&gt;=0.75capacity时，扩容为2table.length = 2capacity</p>\n<pre><code>private void inflateTable(int toSize) {\n    // Find a power of 2 &gt;= toSize\n    int capacity = roundUpToPowerOf2(toSize);\n\n    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    table = new Entry[capacity];\n    initHashSeedAsNeeded(capacity);\n}\n\nprivate static int roundUpToPowerOf2(int number) {\n    // assert number &gt;= 0 : &quot;number must be non-negative&quot;;\n    return number &gt;= MAXIMUM_CAPACITY\n            ? MAXIMUM_CAPACITY\n            : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;\n}\n</code></pre><h2 id=\"resize-int-方法\"><a href=\"#resize-int-方法\" class=\"headerlink\" title=\"resize(int)方法\"></a>resize(int)方法</h2><pre><code>void resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n        threshold = Integer.MAX_VALUE;\n        if (oldCapacity == MAXIMUM_CAPACITY) {\n        return;\n    }\n\n    Entry[] newTable = new Entry[newCapacity];\n\n    // 扩容后进行重hash操作\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table = newTable;\n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n\nvoid transfer(Entry[] newTable, boolean rehash) {\n    int newCapacity = newTable.length;\n\n    // 遍历元素重hash\n    for (Entry&lt;K,V&gt; e : table) {\n        while(null != e) {\n            Entry&lt;K,V&gt; next = e.next;\n            if (rehash) {\n                e.hash = null == e.key ? 0 : hash(e.key);\n            }\n            int i = indexFor(e.hash, newCapacity);\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n</code></pre><p>可以看到在resize后，要对所有的元素重hash进行存储</p>\n<h2 id=\"get-Object\"><a href=\"#get-Object\" class=\"headerlink\" title=\"get(Object)\"></a>get(Object)</h2><pre><code>public V get(Object key) {\n    if (key == null)\n        return getForNullKey();\n    Entry&lt;K,V&gt; entry = getEntry(key);\n\n    return null == entry ? null : entry.getValue();\n}\n\nfinal Entry&lt;K,V&gt; getEntry(Object key) {\n    if (size == 0) {\n        return null;\n    }\n\n    //先通过hash()函数得到key对应buckets的下标，然后依次遍历冲突链表\n    int hash = (key == null) ? 0 : hash(key);\n    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];\n         e != null;\n         e = e.next) {\n        Object k;\n        if (e.hash == hash &amp;&amp;\n            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n            return e;\n    }\n    return null;\n}\n</code></pre><p>可以看到其实查找元素就是先通过hash(key)定位到数组，然后再去遍历数组后的链表</p>\n<h2 id=\"containsKey-Object\"><a href=\"#containsKey-Object\" class=\"headerlink\" title=\"containsKey(Object)\"></a>containsKey(Object)</h2><pre><code>public boolean containsKey(Object key) {\n    return getEntry(key) != null;\n}\n</code></pre><p>可以看到其实containsKey(Object)走的也是一个get(Object)</p>\n<h2 id=\"size\"><a href=\"#size\" class=\"headerlink\" title=\"size()\"></a>size()</h2><pre><code>public int size() {\n    return size;\n}\n</code></pre><p>可以看到HashMap查找长度，其实就是返回了一个属性，Java集合中大多都是返回size属性，不同的是ConcurrentHashMap需要实时去查找。因为ConcurrentHashMap是线程安全的</p>\n","site":{"data":{}},"excerpt":"<p>基于平常很少会看底层的实现，又频繁用到这些，所以简单看一下HashMap中几个主要方法的底层实现：</p>\n<p>put(K, V)</p>\n<p>resize(int)</p>\n<p>get(Object)</p>\n<p>containsKey(Object)</p>\n<p>size()</p>","more":"<h2 id=\"put-K-V-方法\"><a href=\"#put-K-V-方法\" class=\"headerlink\" title=\"put(K, V)方法\"></a>put(K, V)方法</h2><pre><code>public V put(K key, V value) {\n    if (table == EMPTY_TABLE) {\n        inflateTable(threshold);\n    }\n    if (key == null)\n        return putForNullKey(value);\n    // 先对map做一次查找，查看是否包含该元组，如果存在，则直接返回\n    int hash = hash(key);\n    // 返回 h &amp; (table.length-1)\n    int i = indexFor(hash, table.length);\n    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    // 每次对map修改一次，modCount加1\n    modCount++;\n    // i：bucketIndex\n    addEntry(hash, key, value, i);\n    return null;\n}\n\n// 添加\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {\n        //自动扩容，并重新哈希\n        resize(2 * table.length);\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = indexFor(hash, table.length);\n    }\n\n    createEntry(hash, key, value, bucketIndex);\n}\n\n// 在冲突链表头部插入新的entry\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n    Entry&lt;K,V&gt; e = table[bucketIndex];\n    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);\n    size++;\n}\n\nstatic class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n    final K key;\n    V value;\n    Entry&lt;K,V&gt; next;\n    int hash;\n\n    ...\n}\n</code></pre><p>可以看到先通过hash(key)和table.length求得一个下标i，然后去遍历table[i]后面的Entry&lt;K,V&gt;链表,查找是否已经存储过该对象，如果存储过，则返回存储的e.value，并且重新赋值新的value；否则添加Entry</p>\n<p>扩容机制可以看到，如果size &gt; threshold，则执行resize(2 * table.length)，</p>\n<ol>\n<li>在new HashMap()中默认threashold = DEFAULT_INITIAL_CAPACITY=16，否则为自定义值</li>\n<li>在put(K,V)的时候先执行了inflateTable(threshold)，inflateTable中int capacity = roundUpToPowerOf2(toSize)，</li>\n<li>所以inflateTable后现在threshold = capacity*0.75；</li>\n</ol>\n<p>同时可以看到在createEntry中size++，即当元素个数&gt;=0.75capacity时，扩容为2table.length = 2capacity</p>\n<pre><code>private void inflateTable(int toSize) {\n    // Find a power of 2 &gt;= toSize\n    int capacity = roundUpToPowerOf2(toSize);\n\n    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    table = new Entry[capacity];\n    initHashSeedAsNeeded(capacity);\n}\n\nprivate static int roundUpToPowerOf2(int number) {\n    // assert number &gt;= 0 : &quot;number must be non-negative&quot;;\n    return number &gt;= MAXIMUM_CAPACITY\n            ? MAXIMUM_CAPACITY\n            : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;\n}\n</code></pre><h2 id=\"resize-int-方法\"><a href=\"#resize-int-方法\" class=\"headerlink\" title=\"resize(int)方法\"></a>resize(int)方法</h2><pre><code>void resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n        threshold = Integer.MAX_VALUE;\n        if (oldCapacity == MAXIMUM_CAPACITY) {\n        return;\n    }\n\n    Entry[] newTable = new Entry[newCapacity];\n\n    // 扩容后进行重hash操作\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table = newTable;\n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n\nvoid transfer(Entry[] newTable, boolean rehash) {\n    int newCapacity = newTable.length;\n\n    // 遍历元素重hash\n    for (Entry&lt;K,V&gt; e : table) {\n        while(null != e) {\n            Entry&lt;K,V&gt; next = e.next;\n            if (rehash) {\n                e.hash = null == e.key ? 0 : hash(e.key);\n            }\n            int i = indexFor(e.hash, newCapacity);\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n</code></pre><p>可以看到在resize后，要对所有的元素重hash进行存储</p>\n<h2 id=\"get-Object\"><a href=\"#get-Object\" class=\"headerlink\" title=\"get(Object)\"></a>get(Object)</h2><pre><code>public V get(Object key) {\n    if (key == null)\n        return getForNullKey();\n    Entry&lt;K,V&gt; entry = getEntry(key);\n\n    return null == entry ? null : entry.getValue();\n}\n\nfinal Entry&lt;K,V&gt; getEntry(Object key) {\n    if (size == 0) {\n        return null;\n    }\n\n    //先通过hash()函数得到key对应buckets的下标，然后依次遍历冲突链表\n    int hash = (key == null) ? 0 : hash(key);\n    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];\n         e != null;\n         e = e.next) {\n        Object k;\n        if (e.hash == hash &amp;&amp;\n            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n            return e;\n    }\n    return null;\n}\n</code></pre><p>可以看到其实查找元素就是先通过hash(key)定位到数组，然后再去遍历数组后的链表</p>\n<h2 id=\"containsKey-Object\"><a href=\"#containsKey-Object\" class=\"headerlink\" title=\"containsKey(Object)\"></a>containsKey(Object)</h2><pre><code>public boolean containsKey(Object key) {\n    return getEntry(key) != null;\n}\n</code></pre><p>可以看到其实containsKey(Object)走的也是一个get(Object)</p>\n<h2 id=\"size\"><a href=\"#size\" class=\"headerlink\" title=\"size()\"></a>size()</h2><pre><code>public int size() {\n    return size;\n}\n</code></pre><p>可以看到HashMap查找长度，其实就是返回了一个属性，Java集合中大多都是返回size属性，不同的是ConcurrentHashMap需要实时去查找。因为ConcurrentHashMap是线程安全的</p>"},{"title":"JVM虚拟机命令详解","date":"2018-08-07T14:14:15.000Z","_content":"其实去年就一直在做这些东西，只是没有整理出来，这一段时间面试还是遇到很多问jvm的东西，特别整理以下\n## jvm的默认参数 ##\n\n安装完jdk后，先来看一看一些默认参数，以下统一以jdk1.8为例。\n\n\tjava -XX:+PrintFlagsFinal -version | grep :\n\n\"=\":表示jvm参数的默认值，\n\n\":=\":表示被用户或者jvm赋值的参数\n\n<!-- more -->\n\n     intx CICompilerCount                          := 2                                   {product}\n    uintx InitialHeapSize                          := 48234496                            {product}\n    uintx MaxHeapSize                              := 742391808                           {product}\n    uintx MaxNewSize                               := 247463936                           {product}\n    uintx MinHeapDeltaBytes                        := 524288                              {product}\n    uintx NewSize                                  := 15728640                            {product}\n    uintx OldSize                                  := 32505856                            {product}\n     bool PrintFlagsFinal                          := true                                {product}\n     bool UseCompressedClassPointers               := true                                {lp64_product}\n     bool UseCompressedOops                        := true                                {lp64_product}\n     bool UseParallelGC                            := true                                {product}\n\n\n查看参数配置：\n\n\tjava -XX:+PrintCommandLineFlags -version\n\n-XX:InitialHeapSize=46359872 \n-XX:MaxHeapSize=741757952 \n-XX:+PrintCommandLineFlags \n-XX:+UseCompressedClassPointers \n-XX:+UseCompressedOops \n-XX:+UseParallelGC \njava version \"1.8.0_161\"\nJava(TM) SE Runtime Environment (build 1.8.0_161-b12)\nJava HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)\n\n### 参数分析 ###\n\n-XX:+UseParallelGC参数可知，使用的收集器为Parallel Scavenge + Serial Old(PS MarkSweep)组合。\n\n## jstat: 统计信息监控 ##\n\njstat option vmid [interval] [count]\n\n#### 参数解释：####\n\nOptions — 选项，我们一般使用 -gcutil 查看gc 情况\n\nvmid — VM 的进程号，即当前运行的java 进程号\n\ninterval– 间隔时间，单位为秒或者毫秒\n\ncount — 打印次数，如果缺省则打印无数次\n\n#### 具体参数如下： ####\n\n-class：统计class loader行为信息\n\n-compile：统计编译行为信息\n\n-gc：统计jdk gc时heap信息\n\n-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况\n\n-gccause：统计gc的情况，（同-gcutil）和引起gc的事件\n\n-gcnew：统计gc时，新生代的情况\n\n-gcnewcapacity：统计gc时，新生代heap容量\n\n-gcold：统计gc时，老年区的情况\n\n-gcoldcapacity：统计gc时，老年区heap容量\n\n-gcpermcapacity：统计gc时，permanent区heap容量\n\n-gcutil：统计gc时，heap情况\n\n-printcompilation：不知道干什么的，一直没用过。\n\n#### 案例分析： ####\n\nS0 — Heap 上的 Survivor space 0 区已使用空间的百分比\n\nS1 — Heap 上的 Survivor space 1 区已使用空间的百分比\n\nE — Heap 上的 Eden space 区已使用空间的百分比\n\nO — Heap 上的 Old space 区已使用空间的百分比\n\nP — Perm space 区已使用空间的百分比\n\nYGC — 从应用程序启动到采样时发生 Young GC 的次数\n\nYGCT– 从应用程序启动到采样时 Young GC 所用的时间( 单位秒 )\n\nFGC — 从应用程序启动到采样时发生 Full GC 的次数\n\nFGCT– 从应用程序启动到采样时 Full GC 所用的时间( 单位秒 )\n\nGCT — 从应用程序启动到采样时用于垃圾回收的总时间( 单位秒)\n\njstat -gc 1909\n\n\tS0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU      CCSC   CCSU     YGC     YGCT    FGC    FGCT     GCT   \n\t\n\t3456.0 3456.0 3456.0  0.0   28224.0  23968.9   70124.0    66785.0   43264.0 42270.5 4864.0  4588.8    128    1.487    8    0.779    2.266\n\njstat -gccapacity 1909\n\n\tNGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC \n\t\n\t5440.0  83968.0  35136.0 3456.0 3456.0  28224.0    10944.0   167936.0    70124.0    70124.0      0.0 1087488.0  43264.0   0.0    1048576.0   4864.0  128     8\n\njstat -gcutil 1909\n\njstat -gcutil 1909 1000 100      #每1000ms打印一次，总共打印100次\n\n\tS0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   \n\t\n\t0.00   0.00   3.41  60.00  97.54  94.07    129    1.534     9    1.148    2.682\n\njstat -gcnew 1909\n\n\tS0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  \n\t\n\t3584.0 3584.0    0.0    0.0  1  15 1728.0  29248.0   2123.2    129    1.534\n\njstat -gcnewcapacity 1909\n\n\tNGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC \n\t\n\t5440.0    83968.0    36416.0   8384.0   3584.0   8384.0   3584.0    67200.0    29248.0   129     9\n\njstat -gcold pid\n\njstat -gcoldcapacity pid\n\njstat -gcpermcapacity pid\n\njstat -class 1909\n\n\tLoaded  Bytes  Unloaded  Bytes     Time   \n\t\n\t6688 13143.8       24    31.1      52.45\n\njstat -compiler 1909\n\n\tCompiled Failed Invalid   Time   FailedType FailedMethod\n\t\n\t7578      3       0    38.61          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run\n\n\n## jmap ##\n\njmap option vmid\n\n#### 具体参数如下： ####\n\n-dump\n\n-heap\n\n-histo\n\n-finalizeerinfo\n\n-permstat\n\n-F\n\n#### 案例分析： ####\n\n使用hprof二进制形式,输出jvm的heap内容到文件，.live子选项是可选的，假如指定live选项,那么只输出活的对象到文件. 【执行过程会暂停应用】\n\n记录堆内存快照文件，然后利用第三方工具mat分析整个Heap的对象关联情况 【如果添加参数:live，JVM会先触发gc，然后再统计信息。】\n\n\tjmap -dump:format=b,file=[filename][pid]\n\t\n\tjmap -dump:live,format=b,file=20170509.hprof 1909\n\n打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.\n\n\tjmap -heap 1909\n\n打印每个class的实例数目,内存占用,类全名信息。VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量. 【如果添加参数:live，JVM会先触发gc，然后再统计信息。】\n\n\tjmap -histo:live 1909 | head -n 100 > jmaphisto.log\n\n打印正等候回收的对象的信息\n\n\tjmap -finalizerinfo 1283\n\n\n打印classload和jvm heap永久层的信息. 【执行过程会暂停应用】\n\n包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来.\n \n\tjmap -permstat 1909\n\n结合MAT分析。\n\n#### 补充：保留现场，使用更快的gcore分析 ####\n\n1. Linux内核里面生成的core file文件相关的代码\n2. core dump file 相关的设置\n3. 如何在程序中调用代码生成 core dump file，程序又不用退出。\n4. 使用gdb分析 core dump file 文件\n5. 用gdb 生成core文件\n\n## jstack ##\n\n#### 具体参数如下： ####\n\n\n\n#### 案例分析： ####\n\n生成虚拟机当前时刻线程快照:\n\n\tjstack -l 1909\n\tjstack 1909 > jstack.log\n\n## jps ##\n\n\n## jinfo ##\n\n\n\n\n\n## jcmd: 新版jdk的命令，用于取代旧版本命令##\n\n#### 具体参数如下： ####\n\n\n\n#### 案例分析： ####\n\n查看jvm的pid,类似于jps命令\n\n\tjcmd -l\n\t1283 org.apache.catalina.startup.Bootstrap start\n\t2293 sun.tools.jcmd.JCmd -l\n\t27449 org.apache.activemq.apollo.boot.Apollo /usr/local/tbroker/lib\\;/usr/local/apollo-1.7.1/lib org.apache.activemq.apollo.cli.Apollo run\n\n\tjps\n\t1283 Bootstrap\n\t27449 Apollo\n\t2315 Jps\n\n查看 JVM 的启动时长：\n\n\tjcmd PID VM.uptime\n\n查看 JVM 的类信息：这个可以查看每个类的实例数量和占用空间大小。\n\n\tjcmd PID GC.class_histogram\n\n查看 JVM 的线程快照：\n\n\tjcmd PID Thread.print\n\n查看 JVM 的Heap Dump：\n\n\tjcmd PID GC.heap_dump FILE_NAME\n\n**注意**，如果只指定文件名，默认会生成在启动 JVM 的目录里。\n\n查看 JVM 的属性信息：\n\n\tjcmd 1283 VM.system_properties\n\t1283:\n\tjava.lang.OutOfMemoryError: Java heap space\n\n查看 JVM 的启动参数：注意，可以看到 -X 和 -XX 的参数信息，比较有用。\n\n\tjcmd 1283 VM.flags\n\t1283:\n\t-XX:CICompilerCount=2 -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=262144000 -XX:MaxNewSize=87359488 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=5570560 -XX:OldSize=11206656 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops \n\n查看 JVM 的启动命令行：\n\n\tjcmd 1283 VM.command_line\n\n对JVM执行 java.lang.System.runFinalization()：\n\n\tjcmd 1283 GC.run_finalization\n\n对JVM执行 java.lang.System.gc()：\n\n\tjcmd 1283 GC.run\n\n**注意：**告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的。\n\n查看 JVM 的性能：\n\njcmd PID PerfCounter.print\n\n\n\n\n**补充** \n\n常用命令\n\n\ttop\n\ttop -p 1909 -H\n\tfree \n\tfree -m\n\n高内存占用分析\n\n\tps -mp 1909 -o THREAD,tid,time,rss,size,%mem\n\n查看进程内存\n\n\tpmap -x 5454\n\tpmap -q 5454\n\tpmap -d -q 5454\n","source":"_posts/java-jvm-cmd.md","raw":"---\ntitle: JVM虚拟机命令详解\ndate: 2018-08-07 22:14:15\ntags: java, jvm\ncategories: java\n---\n其实去年就一直在做这些东西，只是没有整理出来，这一段时间面试还是遇到很多问jvm的东西，特别整理以下\n## jvm的默认参数 ##\n\n安装完jdk后，先来看一看一些默认参数，以下统一以jdk1.8为例。\n\n\tjava -XX:+PrintFlagsFinal -version | grep :\n\n\"=\":表示jvm参数的默认值，\n\n\":=\":表示被用户或者jvm赋值的参数\n\n<!-- more -->\n\n     intx CICompilerCount                          := 2                                   {product}\n    uintx InitialHeapSize                          := 48234496                            {product}\n    uintx MaxHeapSize                              := 742391808                           {product}\n    uintx MaxNewSize                               := 247463936                           {product}\n    uintx MinHeapDeltaBytes                        := 524288                              {product}\n    uintx NewSize                                  := 15728640                            {product}\n    uintx OldSize                                  := 32505856                            {product}\n     bool PrintFlagsFinal                          := true                                {product}\n     bool UseCompressedClassPointers               := true                                {lp64_product}\n     bool UseCompressedOops                        := true                                {lp64_product}\n     bool UseParallelGC                            := true                                {product}\n\n\n查看参数配置：\n\n\tjava -XX:+PrintCommandLineFlags -version\n\n-XX:InitialHeapSize=46359872 \n-XX:MaxHeapSize=741757952 \n-XX:+PrintCommandLineFlags \n-XX:+UseCompressedClassPointers \n-XX:+UseCompressedOops \n-XX:+UseParallelGC \njava version \"1.8.0_161\"\nJava(TM) SE Runtime Environment (build 1.8.0_161-b12)\nJava HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)\n\n### 参数分析 ###\n\n-XX:+UseParallelGC参数可知，使用的收集器为Parallel Scavenge + Serial Old(PS MarkSweep)组合。\n\n## jstat: 统计信息监控 ##\n\njstat option vmid [interval] [count]\n\n#### 参数解释：####\n\nOptions — 选项，我们一般使用 -gcutil 查看gc 情况\n\nvmid — VM 的进程号，即当前运行的java 进程号\n\ninterval– 间隔时间，单位为秒或者毫秒\n\ncount — 打印次数，如果缺省则打印无数次\n\n#### 具体参数如下： ####\n\n-class：统计class loader行为信息\n\n-compile：统计编译行为信息\n\n-gc：统计jdk gc时heap信息\n\n-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况\n\n-gccause：统计gc的情况，（同-gcutil）和引起gc的事件\n\n-gcnew：统计gc时，新生代的情况\n\n-gcnewcapacity：统计gc时，新生代heap容量\n\n-gcold：统计gc时，老年区的情况\n\n-gcoldcapacity：统计gc时，老年区heap容量\n\n-gcpermcapacity：统计gc时，permanent区heap容量\n\n-gcutil：统计gc时，heap情况\n\n-printcompilation：不知道干什么的，一直没用过。\n\n#### 案例分析： ####\n\nS0 — Heap 上的 Survivor space 0 区已使用空间的百分比\n\nS1 — Heap 上的 Survivor space 1 区已使用空间的百分比\n\nE — Heap 上的 Eden space 区已使用空间的百分比\n\nO — Heap 上的 Old space 区已使用空间的百分比\n\nP — Perm space 区已使用空间的百分比\n\nYGC — 从应用程序启动到采样时发生 Young GC 的次数\n\nYGCT– 从应用程序启动到采样时 Young GC 所用的时间( 单位秒 )\n\nFGC — 从应用程序启动到采样时发生 Full GC 的次数\n\nFGCT– 从应用程序启动到采样时 Full GC 所用的时间( 单位秒 )\n\nGCT — 从应用程序启动到采样时用于垃圾回收的总时间( 单位秒)\n\njstat -gc 1909\n\n\tS0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU      CCSC   CCSU     YGC     YGCT    FGC    FGCT     GCT   \n\t\n\t3456.0 3456.0 3456.0  0.0   28224.0  23968.9   70124.0    66785.0   43264.0 42270.5 4864.0  4588.8    128    1.487    8    0.779    2.266\n\njstat -gccapacity 1909\n\n\tNGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC \n\t\n\t5440.0  83968.0  35136.0 3456.0 3456.0  28224.0    10944.0   167936.0    70124.0    70124.0      0.0 1087488.0  43264.0   0.0    1048576.0   4864.0  128     8\n\njstat -gcutil 1909\n\njstat -gcutil 1909 1000 100      #每1000ms打印一次，总共打印100次\n\n\tS0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   \n\t\n\t0.00   0.00   3.41  60.00  97.54  94.07    129    1.534     9    1.148    2.682\n\njstat -gcnew 1909\n\n\tS0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  \n\t\n\t3584.0 3584.0    0.0    0.0  1  15 1728.0  29248.0   2123.2    129    1.534\n\njstat -gcnewcapacity 1909\n\n\tNGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC \n\t\n\t5440.0    83968.0    36416.0   8384.0   3584.0   8384.0   3584.0    67200.0    29248.0   129     9\n\njstat -gcold pid\n\njstat -gcoldcapacity pid\n\njstat -gcpermcapacity pid\n\njstat -class 1909\n\n\tLoaded  Bytes  Unloaded  Bytes     Time   \n\t\n\t6688 13143.8       24    31.1      52.45\n\njstat -compiler 1909\n\n\tCompiled Failed Invalid   Time   FailedType FailedMethod\n\t\n\t7578      3       0    38.61          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run\n\n\n## jmap ##\n\njmap option vmid\n\n#### 具体参数如下： ####\n\n-dump\n\n-heap\n\n-histo\n\n-finalizeerinfo\n\n-permstat\n\n-F\n\n#### 案例分析： ####\n\n使用hprof二进制形式,输出jvm的heap内容到文件，.live子选项是可选的，假如指定live选项,那么只输出活的对象到文件. 【执行过程会暂停应用】\n\n记录堆内存快照文件，然后利用第三方工具mat分析整个Heap的对象关联情况 【如果添加参数:live，JVM会先触发gc，然后再统计信息。】\n\n\tjmap -dump:format=b,file=[filename][pid]\n\t\n\tjmap -dump:live,format=b,file=20170509.hprof 1909\n\n打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.\n\n\tjmap -heap 1909\n\n打印每个class的实例数目,内存占用,类全名信息。VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量. 【如果添加参数:live，JVM会先触发gc，然后再统计信息。】\n\n\tjmap -histo:live 1909 | head -n 100 > jmaphisto.log\n\n打印正等候回收的对象的信息\n\n\tjmap -finalizerinfo 1283\n\n\n打印classload和jvm heap永久层的信息. 【执行过程会暂停应用】\n\n包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来.\n \n\tjmap -permstat 1909\n\n结合MAT分析。\n\n#### 补充：保留现场，使用更快的gcore分析 ####\n\n1. Linux内核里面生成的core file文件相关的代码\n2. core dump file 相关的设置\n3. 如何在程序中调用代码生成 core dump file，程序又不用退出。\n4. 使用gdb分析 core dump file 文件\n5. 用gdb 生成core文件\n\n## jstack ##\n\n#### 具体参数如下： ####\n\n\n\n#### 案例分析： ####\n\n生成虚拟机当前时刻线程快照:\n\n\tjstack -l 1909\n\tjstack 1909 > jstack.log\n\n## jps ##\n\n\n## jinfo ##\n\n\n\n\n\n## jcmd: 新版jdk的命令，用于取代旧版本命令##\n\n#### 具体参数如下： ####\n\n\n\n#### 案例分析： ####\n\n查看jvm的pid,类似于jps命令\n\n\tjcmd -l\n\t1283 org.apache.catalina.startup.Bootstrap start\n\t2293 sun.tools.jcmd.JCmd -l\n\t27449 org.apache.activemq.apollo.boot.Apollo /usr/local/tbroker/lib\\;/usr/local/apollo-1.7.1/lib org.apache.activemq.apollo.cli.Apollo run\n\n\tjps\n\t1283 Bootstrap\n\t27449 Apollo\n\t2315 Jps\n\n查看 JVM 的启动时长：\n\n\tjcmd PID VM.uptime\n\n查看 JVM 的类信息：这个可以查看每个类的实例数量和占用空间大小。\n\n\tjcmd PID GC.class_histogram\n\n查看 JVM 的线程快照：\n\n\tjcmd PID Thread.print\n\n查看 JVM 的Heap Dump：\n\n\tjcmd PID GC.heap_dump FILE_NAME\n\n**注意**，如果只指定文件名，默认会生成在启动 JVM 的目录里。\n\n查看 JVM 的属性信息：\n\n\tjcmd 1283 VM.system_properties\n\t1283:\n\tjava.lang.OutOfMemoryError: Java heap space\n\n查看 JVM 的启动参数：注意，可以看到 -X 和 -XX 的参数信息，比较有用。\n\n\tjcmd 1283 VM.flags\n\t1283:\n\t-XX:CICompilerCount=2 -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=262144000 -XX:MaxNewSize=87359488 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=5570560 -XX:OldSize=11206656 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops \n\n查看 JVM 的启动命令行：\n\n\tjcmd 1283 VM.command_line\n\n对JVM执行 java.lang.System.runFinalization()：\n\n\tjcmd 1283 GC.run_finalization\n\n对JVM执行 java.lang.System.gc()：\n\n\tjcmd 1283 GC.run\n\n**注意：**告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的。\n\n查看 JVM 的性能：\n\njcmd PID PerfCounter.print\n\n\n\n\n**补充** \n\n常用命令\n\n\ttop\n\ttop -p 1909 -H\n\tfree \n\tfree -m\n\n高内存占用分析\n\n\tps -mp 1909 -o THREAD,tid,time,rss,size,%mem\n\n查看进程内存\n\n\tpmap -x 5454\n\tpmap -q 5454\n\tpmap -d -q 5454\n","slug":"java-jvm-cmd","published":1,"updated":"2018-08-07T16:55:55.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde12000zv0f0jo87zaj4","content":"<p>其实去年就一直在做这些东西，只是没有整理出来，这一段时间面试还是遇到很多问jvm的东西，特别整理以下</p>\n<h2 id=\"jvm的默认参数\"><a href=\"#jvm的默认参数\" class=\"headerlink\" title=\"jvm的默认参数\"></a>jvm的默认参数</h2><p>安装完jdk后，先来看一看一些默认参数，以下统一以jdk1.8为例。</p>\n<pre><code>java -XX:+PrintFlagsFinal -version | grep :\n</code></pre><p>“=”:表示jvm参数的默认值，</p>\n<p>“:=”:表示被用户或者jvm赋值的参数</p>\n<a id=\"more\"></a>\n<pre><code> intx CICompilerCount                          := 2                                   {product}\nuintx InitialHeapSize                          := 48234496                            {product}\nuintx MaxHeapSize                              := 742391808                           {product}\nuintx MaxNewSize                               := 247463936                           {product}\nuintx MinHeapDeltaBytes                        := 524288                              {product}\nuintx NewSize                                  := 15728640                            {product}\nuintx OldSize                                  := 32505856                            {product}\n bool PrintFlagsFinal                          := true                                {product}\n bool UseCompressedClassPointers               := true                                {lp64_product}\n bool UseCompressedOops                        := true                                {lp64_product}\n bool UseParallelGC                            := true                                {product}\n</code></pre><p>查看参数配置：</p>\n<pre><code>java -XX:+PrintCommandLineFlags -version\n</code></pre><p>-XX:InitialHeapSize=46359872<br>-XX:MaxHeapSize=741757952<br>-XX:+PrintCommandLineFlags<br>-XX:+UseCompressedClassPointers<br>-XX:+UseCompressedOops<br>-XX:+UseParallelGC<br>java version “1.8.0_161”<br>Java(TM) SE Runtime Environment (build 1.8.0_161-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</p>\n<h3 id=\"参数分析\"><a href=\"#参数分析\" class=\"headerlink\" title=\"参数分析\"></a>参数分析</h3><p>-XX:+UseParallelGC参数可知，使用的收集器为Parallel Scavenge + Serial Old(PS MarkSweep)组合。</p>\n<h2 id=\"jstat-统计信息监控\"><a href=\"#jstat-统计信息监控\" class=\"headerlink\" title=\"jstat: 统计信息监控\"></a>jstat: 统计信息监控</h2><p>jstat option vmid [interval] [count]</p>\n<h4 id=\"参数解释：\"><a href=\"#参数解释：\" class=\"headerlink\" title=\"参数解释：\"></a>参数解释：</h4><p>Options — 选项，我们一般使用 -gcutil 查看gc 情况</p>\n<p>vmid — VM 的进程号，即当前运行的java 进程号</p>\n<p>interval– 间隔时间，单位为秒或者毫秒</p>\n<p>count — 打印次数，如果缺省则打印无数次</p>\n<h4 id=\"具体参数如下：\"><a href=\"#具体参数如下：\" class=\"headerlink\" title=\"具体参数如下：\"></a>具体参数如下：</h4><p>-class：统计class loader行为信息</p>\n<p>-compile：统计编译行为信息</p>\n<p>-gc：统计jdk gc时heap信息</p>\n<p>-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况</p>\n<p>-gccause：统计gc的情况，（同-gcutil）和引起gc的事件</p>\n<p>-gcnew：统计gc时，新生代的情况</p>\n<p>-gcnewcapacity：统计gc时，新生代heap容量</p>\n<p>-gcold：统计gc时，老年区的情况</p>\n<p>-gcoldcapacity：统计gc时，老年区heap容量</p>\n<p>-gcpermcapacity：统计gc时，permanent区heap容量</p>\n<p>-gcutil：统计gc时，heap情况</p>\n<p>-printcompilation：不知道干什么的，一直没用过。</p>\n<h4 id=\"案例分析：\"><a href=\"#案例分析：\" class=\"headerlink\" title=\"案例分析：\"></a>案例分析：</h4><p>S0 — Heap 上的 Survivor space 0 区已使用空间的百分比</p>\n<p>S1 — Heap 上的 Survivor space 1 区已使用空间的百分比</p>\n<p>E — Heap 上的 Eden space 区已使用空间的百分比</p>\n<p>O — Heap 上的 Old space 区已使用空间的百分比</p>\n<p>P — Perm space 区已使用空间的百分比</p>\n<p>YGC — 从应用程序启动到采样时发生 Young GC 的次数</p>\n<p>YGCT– 从应用程序启动到采样时 Young GC 所用的时间( 单位秒 )</p>\n<p>FGC — 从应用程序启动到采样时发生 Full GC 的次数</p>\n<p>FGCT– 从应用程序启动到采样时 Full GC 所用的时间( 单位秒 )</p>\n<p>GCT — 从应用程序启动到采样时用于垃圾回收的总时间( 单位秒)</p>\n<p>jstat -gc 1909</p>\n<pre><code>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU      CCSC   CCSU     YGC     YGCT    FGC    FGCT     GCT   \n\n3456.0 3456.0 3456.0  0.0   28224.0  23968.9   70124.0    66785.0   43264.0 42270.5 4864.0  4588.8    128    1.487    8    0.779    2.266\n</code></pre><p>jstat -gccapacity 1909</p>\n<pre><code>NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC \n\n5440.0  83968.0  35136.0 3456.0 3456.0  28224.0    10944.0   167936.0    70124.0    70124.0      0.0 1087488.0  43264.0   0.0    1048576.0   4864.0  128     8\n</code></pre><p>jstat -gcutil 1909</p>\n<p>jstat -gcutil 1909 1000 100      #每1000ms打印一次，总共打印100次</p>\n<pre><code>S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   \n\n0.00   0.00   3.41  60.00  97.54  94.07    129    1.534     9    1.148    2.682\n</code></pre><p>jstat -gcnew 1909</p>\n<pre><code>S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  \n\n3584.0 3584.0    0.0    0.0  1  15 1728.0  29248.0   2123.2    129    1.534\n</code></pre><p>jstat -gcnewcapacity 1909</p>\n<pre><code>NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC \n\n5440.0    83968.0    36416.0   8384.0   3584.0   8384.0   3584.0    67200.0    29248.0   129     9\n</code></pre><p>jstat -gcold pid</p>\n<p>jstat -gcoldcapacity pid</p>\n<p>jstat -gcpermcapacity pid</p>\n<p>jstat -class 1909</p>\n<pre><code>Loaded  Bytes  Unloaded  Bytes     Time   \n\n6688 13143.8       24    31.1      52.45\n</code></pre><p>jstat -compiler 1909</p>\n<pre><code>Compiled Failed Invalid   Time   FailedType FailedMethod\n\n7578      3       0    38.61          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run\n</code></pre><h2 id=\"jmap\"><a href=\"#jmap\" class=\"headerlink\" title=\"jmap\"></a>jmap</h2><p>jmap option vmid</p>\n<h4 id=\"具体参数如下：-1\"><a href=\"#具体参数如下：-1\" class=\"headerlink\" title=\"具体参数如下：\"></a>具体参数如下：</h4><p>-dump</p>\n<p>-heap</p>\n<p>-histo</p>\n<p>-finalizeerinfo</p>\n<p>-permstat</p>\n<p>-F</p>\n<h4 id=\"案例分析：-1\"><a href=\"#案例分析：-1\" class=\"headerlink\" title=\"案例分析：\"></a>案例分析：</h4><p>使用hprof二进制形式,输出jvm的heap内容到文件，.live子选项是可选的，假如指定live选项,那么只输出活的对象到文件. 【执行过程会暂停应用】</p>\n<p>记录堆内存快照文件，然后利用第三方工具mat分析整个Heap的对象关联情况 【如果添加参数:live，JVM会先触发gc，然后再统计信息。】</p>\n<pre><code>jmap -dump:format=b,file=[filename][pid]\n\njmap -dump:live,format=b,file=20170509.hprof 1909\n</code></pre><p>打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.</p>\n<pre><code>jmap -heap 1909\n</code></pre><p>打印每个class的实例数目,内存占用,类全名信息。VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量. 【如果添加参数:live，JVM会先触发gc，然后再统计信息。】</p>\n<pre><code>jmap -histo:live 1909 | head -n 100 &gt; jmaphisto.log\n</code></pre><p>打印正等候回收的对象的信息</p>\n<pre><code>jmap -finalizerinfo 1283\n</code></pre><p>打印classload和jvm heap永久层的信息. 【执行过程会暂停应用】</p>\n<p>包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来.</p>\n<pre><code>jmap -permstat 1909\n</code></pre><p>结合MAT分析。</p>\n<h4 id=\"补充：保留现场，使用更快的gcore分析\"><a href=\"#补充：保留现场，使用更快的gcore分析\" class=\"headerlink\" title=\"补充：保留现场，使用更快的gcore分析\"></a>补充：保留现场，使用更快的gcore分析</h4><ol>\n<li>Linux内核里面生成的core file文件相关的代码</li>\n<li>core dump file 相关的设置</li>\n<li>如何在程序中调用代码生成 core dump file，程序又不用退出。</li>\n<li>使用gdb分析 core dump file 文件</li>\n<li>用gdb 生成core文件</li>\n</ol>\n<h2 id=\"jstack\"><a href=\"#jstack\" class=\"headerlink\" title=\"jstack\"></a>jstack</h2><h4 id=\"具体参数如下：-2\"><a href=\"#具体参数如下：-2\" class=\"headerlink\" title=\"具体参数如下：\"></a>具体参数如下：</h4><h4 id=\"案例分析：-2\"><a href=\"#案例分析：-2\" class=\"headerlink\" title=\"案例分析：\"></a>案例分析：</h4><p>生成虚拟机当前时刻线程快照:</p>\n<pre><code>jstack -l 1909\njstack 1909 &gt; jstack.log\n</code></pre><h2 id=\"jps\"><a href=\"#jps\" class=\"headerlink\" title=\"jps\"></a>jps</h2><h2 id=\"jinfo\"><a href=\"#jinfo\" class=\"headerlink\" title=\"jinfo\"></a>jinfo</h2><h2 id=\"jcmd-新版jdk的命令，用于取代旧版本命令\"><a href=\"#jcmd-新版jdk的命令，用于取代旧版本命令\" class=\"headerlink\" title=\"jcmd: 新版jdk的命令，用于取代旧版本命令\"></a>jcmd: 新版jdk的命令，用于取代旧版本命令</h2><h4 id=\"具体参数如下：-3\"><a href=\"#具体参数如下：-3\" class=\"headerlink\" title=\"具体参数如下：\"></a>具体参数如下：</h4><h4 id=\"案例分析：-3\"><a href=\"#案例分析：-3\" class=\"headerlink\" title=\"案例分析：\"></a>案例分析：</h4><p>查看jvm的pid,类似于jps命令</p>\n<pre><code>jcmd -l\n1283 org.apache.catalina.startup.Bootstrap start\n2293 sun.tools.jcmd.JCmd -l\n27449 org.apache.activemq.apollo.boot.Apollo /usr/local/tbroker/lib\\;/usr/local/apollo-1.7.1/lib org.apache.activemq.apollo.cli.Apollo run\n\njps\n1283 Bootstrap\n27449 Apollo\n2315 Jps\n</code></pre><p>查看 JVM 的启动时长：</p>\n<pre><code>jcmd PID VM.uptime\n</code></pre><p>查看 JVM 的类信息：这个可以查看每个类的实例数量和占用空间大小。</p>\n<pre><code>jcmd PID GC.class_histogram\n</code></pre><p>查看 JVM 的线程快照：</p>\n<pre><code>jcmd PID Thread.print\n</code></pre><p>查看 JVM 的Heap Dump：</p>\n<pre><code>jcmd PID GC.heap_dump FILE_NAME\n</code></pre><p><strong>注意</strong>，如果只指定文件名，默认会生成在启动 JVM 的目录里。</p>\n<p>查看 JVM 的属性信息：</p>\n<pre><code>jcmd 1283 VM.system_properties\n1283:\njava.lang.OutOfMemoryError: Java heap space\n</code></pre><p>查看 JVM 的启动参数：注意，可以看到 -X 和 -XX 的参数信息，比较有用。</p>\n<pre><code>jcmd 1283 VM.flags\n1283:\n-XX:CICompilerCount=2 -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=262144000 -XX:MaxNewSize=87359488 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=5570560 -XX:OldSize=11206656 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops \n</code></pre><p>查看 JVM 的启动命令行：</p>\n<pre><code>jcmd 1283 VM.command_line\n</code></pre><p>对JVM执行 java.lang.System.runFinalization()：</p>\n<pre><code>jcmd 1283 GC.run_finalization\n</code></pre><p>对JVM执行 java.lang.System.gc()：</p>\n<pre><code>jcmd 1283 GC.run\n</code></pre><p><strong>注意：</strong>告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的。</p>\n<p>查看 JVM 的性能：</p>\n<p>jcmd PID PerfCounter.print</p>\n<p><strong>补充</strong> </p>\n<p>常用命令</p>\n<pre><code>top\ntop -p 1909 -H\nfree \nfree -m\n</code></pre><p>高内存占用分析</p>\n<pre><code>ps -mp 1909 -o THREAD,tid,time,rss,size,%mem\n</code></pre><p>查看进程内存</p>\n<pre><code>pmap -x 5454\npmap -q 5454\npmap -d -q 5454\n</code></pre>","site":{"data":{}},"excerpt":"<p>其实去年就一直在做这些东西，只是没有整理出来，这一段时间面试还是遇到很多问jvm的东西，特别整理以下</p>\n<h2 id=\"jvm的默认参数\"><a href=\"#jvm的默认参数\" class=\"headerlink\" title=\"jvm的默认参数\"></a>jvm的默认参数</h2><p>安装完jdk后，先来看一看一些默认参数，以下统一以jdk1.8为例。</p>\n<pre><code>java -XX:+PrintFlagsFinal -version | grep :\n</code></pre><p>“=”:表示jvm参数的默认值，</p>\n<p>“:=”:表示被用户或者jvm赋值的参数</p>","more":"<pre><code> intx CICompilerCount                          := 2                                   {product}\nuintx InitialHeapSize                          := 48234496                            {product}\nuintx MaxHeapSize                              := 742391808                           {product}\nuintx MaxNewSize                               := 247463936                           {product}\nuintx MinHeapDeltaBytes                        := 524288                              {product}\nuintx NewSize                                  := 15728640                            {product}\nuintx OldSize                                  := 32505856                            {product}\n bool PrintFlagsFinal                          := true                                {product}\n bool UseCompressedClassPointers               := true                                {lp64_product}\n bool UseCompressedOops                        := true                                {lp64_product}\n bool UseParallelGC                            := true                                {product}\n</code></pre><p>查看参数配置：</p>\n<pre><code>java -XX:+PrintCommandLineFlags -version\n</code></pre><p>-XX:InitialHeapSize=46359872<br>-XX:MaxHeapSize=741757952<br>-XX:+PrintCommandLineFlags<br>-XX:+UseCompressedClassPointers<br>-XX:+UseCompressedOops<br>-XX:+UseParallelGC<br>java version “1.8.0_161”<br>Java(TM) SE Runtime Environment (build 1.8.0_161-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</p>\n<h3 id=\"参数分析\"><a href=\"#参数分析\" class=\"headerlink\" title=\"参数分析\"></a>参数分析</h3><p>-XX:+UseParallelGC参数可知，使用的收集器为Parallel Scavenge + Serial Old(PS MarkSweep)组合。</p>\n<h2 id=\"jstat-统计信息监控\"><a href=\"#jstat-统计信息监控\" class=\"headerlink\" title=\"jstat: 统计信息监控\"></a>jstat: 统计信息监控</h2><p>jstat option vmid [interval] [count]</p>\n<h4 id=\"参数解释：\"><a href=\"#参数解释：\" class=\"headerlink\" title=\"参数解释：\"></a>参数解释：</h4><p>Options — 选项，我们一般使用 -gcutil 查看gc 情况</p>\n<p>vmid — VM 的进程号，即当前运行的java 进程号</p>\n<p>interval– 间隔时间，单位为秒或者毫秒</p>\n<p>count — 打印次数，如果缺省则打印无数次</p>\n<h4 id=\"具体参数如下：\"><a href=\"#具体参数如下：\" class=\"headerlink\" title=\"具体参数如下：\"></a>具体参数如下：</h4><p>-class：统计class loader行为信息</p>\n<p>-compile：统计编译行为信息</p>\n<p>-gc：统计jdk gc时heap信息</p>\n<p>-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况</p>\n<p>-gccause：统计gc的情况，（同-gcutil）和引起gc的事件</p>\n<p>-gcnew：统计gc时，新生代的情况</p>\n<p>-gcnewcapacity：统计gc时，新生代heap容量</p>\n<p>-gcold：统计gc时，老年区的情况</p>\n<p>-gcoldcapacity：统计gc时，老年区heap容量</p>\n<p>-gcpermcapacity：统计gc时，permanent区heap容量</p>\n<p>-gcutil：统计gc时，heap情况</p>\n<p>-printcompilation：不知道干什么的，一直没用过。</p>\n<h4 id=\"案例分析：\"><a href=\"#案例分析：\" class=\"headerlink\" title=\"案例分析：\"></a>案例分析：</h4><p>S0 — Heap 上的 Survivor space 0 区已使用空间的百分比</p>\n<p>S1 — Heap 上的 Survivor space 1 区已使用空间的百分比</p>\n<p>E — Heap 上的 Eden space 区已使用空间的百分比</p>\n<p>O — Heap 上的 Old space 区已使用空间的百分比</p>\n<p>P — Perm space 区已使用空间的百分比</p>\n<p>YGC — 从应用程序启动到采样时发生 Young GC 的次数</p>\n<p>YGCT– 从应用程序启动到采样时 Young GC 所用的时间( 单位秒 )</p>\n<p>FGC — 从应用程序启动到采样时发生 Full GC 的次数</p>\n<p>FGCT– 从应用程序启动到采样时 Full GC 所用的时间( 单位秒 )</p>\n<p>GCT — 从应用程序启动到采样时用于垃圾回收的总时间( 单位秒)</p>\n<p>jstat -gc 1909</p>\n<pre><code>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU      CCSC   CCSU     YGC     YGCT    FGC    FGCT     GCT   \n\n3456.0 3456.0 3456.0  0.0   28224.0  23968.9   70124.0    66785.0   43264.0 42270.5 4864.0  4588.8    128    1.487    8    0.779    2.266\n</code></pre><p>jstat -gccapacity 1909</p>\n<pre><code>NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC \n\n5440.0  83968.0  35136.0 3456.0 3456.0  28224.0    10944.0   167936.0    70124.0    70124.0      0.0 1087488.0  43264.0   0.0    1048576.0   4864.0  128     8\n</code></pre><p>jstat -gcutil 1909</p>\n<p>jstat -gcutil 1909 1000 100      #每1000ms打印一次，总共打印100次</p>\n<pre><code>S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   \n\n0.00   0.00   3.41  60.00  97.54  94.07    129    1.534     9    1.148    2.682\n</code></pre><p>jstat -gcnew 1909</p>\n<pre><code>S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  \n\n3584.0 3584.0    0.0    0.0  1  15 1728.0  29248.0   2123.2    129    1.534\n</code></pre><p>jstat -gcnewcapacity 1909</p>\n<pre><code>NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC \n\n5440.0    83968.0    36416.0   8384.0   3584.0   8384.0   3584.0    67200.0    29248.0   129     9\n</code></pre><p>jstat -gcold pid</p>\n<p>jstat -gcoldcapacity pid</p>\n<p>jstat -gcpermcapacity pid</p>\n<p>jstat -class 1909</p>\n<pre><code>Loaded  Bytes  Unloaded  Bytes     Time   \n\n6688 13143.8       24    31.1      52.45\n</code></pre><p>jstat -compiler 1909</p>\n<pre><code>Compiled Failed Invalid   Time   FailedType FailedMethod\n\n7578      3       0    38.61          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run\n</code></pre><h2 id=\"jmap\"><a href=\"#jmap\" class=\"headerlink\" title=\"jmap\"></a>jmap</h2><p>jmap option vmid</p>\n<h4 id=\"具体参数如下：-1\"><a href=\"#具体参数如下：-1\" class=\"headerlink\" title=\"具体参数如下：\"></a>具体参数如下：</h4><p>-dump</p>\n<p>-heap</p>\n<p>-histo</p>\n<p>-finalizeerinfo</p>\n<p>-permstat</p>\n<p>-F</p>\n<h4 id=\"案例分析：-1\"><a href=\"#案例分析：-1\" class=\"headerlink\" title=\"案例分析：\"></a>案例分析：</h4><p>使用hprof二进制形式,输出jvm的heap内容到文件，.live子选项是可选的，假如指定live选项,那么只输出活的对象到文件. 【执行过程会暂停应用】</p>\n<p>记录堆内存快照文件，然后利用第三方工具mat分析整个Heap的对象关联情况 【如果添加参数:live，JVM会先触发gc，然后再统计信息。】</p>\n<pre><code>jmap -dump:format=b,file=[filename][pid]\n\njmap -dump:live,format=b,file=20170509.hprof 1909\n</code></pre><p>打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.</p>\n<pre><code>jmap -heap 1909\n</code></pre><p>打印每个class的实例数目,内存占用,类全名信息。VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量. 【如果添加参数:live，JVM会先触发gc，然后再统计信息。】</p>\n<pre><code>jmap -histo:live 1909 | head -n 100 &gt; jmaphisto.log\n</code></pre><p>打印正等候回收的对象的信息</p>\n<pre><code>jmap -finalizerinfo 1283\n</code></pre><p>打印classload和jvm heap永久层的信息. 【执行过程会暂停应用】</p>\n<p>包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来.</p>\n<pre><code>jmap -permstat 1909\n</code></pre><p>结合MAT分析。</p>\n<h4 id=\"补充：保留现场，使用更快的gcore分析\"><a href=\"#补充：保留现场，使用更快的gcore分析\" class=\"headerlink\" title=\"补充：保留现场，使用更快的gcore分析\"></a>补充：保留现场，使用更快的gcore分析</h4><ol>\n<li>Linux内核里面生成的core file文件相关的代码</li>\n<li>core dump file 相关的设置</li>\n<li>如何在程序中调用代码生成 core dump file，程序又不用退出。</li>\n<li>使用gdb分析 core dump file 文件</li>\n<li>用gdb 生成core文件</li>\n</ol>\n<h2 id=\"jstack\"><a href=\"#jstack\" class=\"headerlink\" title=\"jstack\"></a>jstack</h2><h4 id=\"具体参数如下：-2\"><a href=\"#具体参数如下：-2\" class=\"headerlink\" title=\"具体参数如下：\"></a>具体参数如下：</h4><h4 id=\"案例分析：-2\"><a href=\"#案例分析：-2\" class=\"headerlink\" title=\"案例分析：\"></a>案例分析：</h4><p>生成虚拟机当前时刻线程快照:</p>\n<pre><code>jstack -l 1909\njstack 1909 &gt; jstack.log\n</code></pre><h2 id=\"jps\"><a href=\"#jps\" class=\"headerlink\" title=\"jps\"></a>jps</h2><h2 id=\"jinfo\"><a href=\"#jinfo\" class=\"headerlink\" title=\"jinfo\"></a>jinfo</h2><h2 id=\"jcmd-新版jdk的命令，用于取代旧版本命令\"><a href=\"#jcmd-新版jdk的命令，用于取代旧版本命令\" class=\"headerlink\" title=\"jcmd: 新版jdk的命令，用于取代旧版本命令\"></a>jcmd: 新版jdk的命令，用于取代旧版本命令</h2><h4 id=\"具体参数如下：-3\"><a href=\"#具体参数如下：-3\" class=\"headerlink\" title=\"具体参数如下：\"></a>具体参数如下：</h4><h4 id=\"案例分析：-3\"><a href=\"#案例分析：-3\" class=\"headerlink\" title=\"案例分析：\"></a>案例分析：</h4><p>查看jvm的pid,类似于jps命令</p>\n<pre><code>jcmd -l\n1283 org.apache.catalina.startup.Bootstrap start\n2293 sun.tools.jcmd.JCmd -l\n27449 org.apache.activemq.apollo.boot.Apollo /usr/local/tbroker/lib\\;/usr/local/apollo-1.7.1/lib org.apache.activemq.apollo.cli.Apollo run\n\njps\n1283 Bootstrap\n27449 Apollo\n2315 Jps\n</code></pre><p>查看 JVM 的启动时长：</p>\n<pre><code>jcmd PID VM.uptime\n</code></pre><p>查看 JVM 的类信息：这个可以查看每个类的实例数量和占用空间大小。</p>\n<pre><code>jcmd PID GC.class_histogram\n</code></pre><p>查看 JVM 的线程快照：</p>\n<pre><code>jcmd PID Thread.print\n</code></pre><p>查看 JVM 的Heap Dump：</p>\n<pre><code>jcmd PID GC.heap_dump FILE_NAME\n</code></pre><p><strong>注意</strong>，如果只指定文件名，默认会生成在启动 JVM 的目录里。</p>\n<p>查看 JVM 的属性信息：</p>\n<pre><code>jcmd 1283 VM.system_properties\n1283:\njava.lang.OutOfMemoryError: Java heap space\n</code></pre><p>查看 JVM 的启动参数：注意，可以看到 -X 和 -XX 的参数信息，比较有用。</p>\n<pre><code>jcmd 1283 VM.flags\n1283:\n-XX:CICompilerCount=2 -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=262144000 -XX:MaxNewSize=87359488 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=5570560 -XX:OldSize=11206656 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops \n</code></pre><p>查看 JVM 的启动命令行：</p>\n<pre><code>jcmd 1283 VM.command_line\n</code></pre><p>对JVM执行 java.lang.System.runFinalization()：</p>\n<pre><code>jcmd 1283 GC.run_finalization\n</code></pre><p>对JVM执行 java.lang.System.gc()：</p>\n<pre><code>jcmd 1283 GC.run\n</code></pre><p><strong>注意：</strong>告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的。</p>\n<p>查看 JVM 的性能：</p>\n<p>jcmd PID PerfCounter.print</p>\n<p><strong>补充</strong> </p>\n<p>常用命令</p>\n<pre><code>top\ntop -p 1909 -H\nfree \nfree -m\n</code></pre><p>高内存占用分析</p>\n<pre><code>ps -mp 1909 -o THREAD,tid,time,rss,size,%mem\n</code></pre><p>查看进程内存</p>\n<pre><code>pmap -x 5454\npmap -q 5454\npmap -d -q 5454\n</code></pre>"},{"title":"jvm垃圾回收器","date":"2018-08-07T14:09:54.000Z","_content":"\n## gc算法 ##\n\n1.标记-清除算法(Mark-Sweep):\n\n\n缺点：\n\n> 效率不高\n> \n> 产生大量不连续的内存碎片\n\n<!-- more -->\n\n2.复制算法\n\n优点：\n\n> 实现简单，运行高效\n\n缺点：\n\n> 内存浪费\n\n商业用例：\n\n\tEden:Survivor = 8:1\n\n\n3.标记-整理算法/标记-压缩算法\n\n4.分代收集算法\n\n> 新生代：复制算法\n> \n> 老年代：标记-清除/标记-整理\n\n\n### 案例分析：HotSpot的实现 ###\n\n1.枚举根节点\n\n2.安全点\n\n3.安全区域\n\n\n\n## gc回收器 ##\n\n常用的参数\n\n|参数  |描述 |\n|-  |:----:|\n|UseSerialGC      | client模式下的默认值，Serial + Serial Old收集器                 |\n|UseParallelGC    | Server模式下的默认值，Parallel Scavenge + Serial Old收集器      |\n\n1.Serial\n\n2.ParNew\n\n\n3.Parallel Scavenge\n\n4.Serial Old\n\n5.Parallel Old\n\n6.CMS(并发低停顿收集器), 基于标记-清除算法\n\n目标：以获取最短回收停顿时间\n\n原理：\n\n>初始标记\n>\n>并发标记\n>\n>重新标记\n>\n>并发清除\n\n优点：\n\n缺点：\n\n> 对CPU资源非常敏感\n> \n> 无法处理浮动垃圾\n> \n> 产生大量空间碎片\n\n\n7.G1\n\n目标：\n\n原理：\n\n> 概念：\n> 优先列表\n> \n> Region\n> \n> Remembered Set\n> \n> Write Barrier\n> \n> CarTable\n\n\n> 初始标记\n> \n> 并发标记\n> \n> 最终标记\n> \n> 筛选回收\n\n\n优点：\n\n> 并行与并发\n> \n> 分代收集\n> \n> 空间整合：与CMS的标记-清除算法不同，G1整理看是标记-整理算法，局部(Region)看则是复制算法，不会产生内存碎片。\n> \n> 可预测的停顿：这是G1相比CMS的一大优势，降低停顿时间时G1和CMS共同的关注点，但G1除了追求低停顿，还能建立可预测的停顿时间模型\n\n缺点：\n\n\n\n## 内存分配、回收策略 ##\n\nMinor GC: 指发生在新生代的垃圾回收动作\n\nFull GC/Major GC: 指发生在老年代的GC，出现Full GC，经常会伴随至少一次Minor GC;\n\n1、对象优先在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC\n\n2、大对象直接进入老年代。大对象典型的就是那些很长的字符串、数组\n\n参数-XX:PretenureSizeThreshold可以设定大对象的标准\n\n3、长期存活的对象将进入老年代(默认是15岁)\n\nEden区对象经过Minor GC后，年龄增1，然后在Survivor每经历一次Minor GC，年龄增长1，达到指定年龄，进入老年代\n\n参数-XX:MaxTenuringThreshold\n\n4、动态年龄判定\n\n如果在Survivor区，相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于等于该年龄的对象可以直接进入老年代。【可以破坏规则3】\n\n5、空间分配担保\n\n### GC触发 ###\n\nMinor GC触发条件：\n\n> Eden区没有足够空间分配时，触发\n\nFull GC触发条件：\n\n>显式调用System.gc()时\n>\n>方法区空间不足\n>\n>老年代空间不足\n>\n>Eden区对象执行Minor GC后，进入老年代的所有对象和大于老年代可用内存时，触发Full GC\n>\n>Eden + From执行Minor GC时，如果存活对象大于To内存区，则直接进入老年代，如果老年代的可用内存小于该对象，则触发Full GC\n\n**注意:**jdk1.6_24之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会执行Minor GC,否则进行Full GC","source":"_posts/java-jvm-gc.md","raw":"---\ntitle: jvm垃圾回收器\ndate: 2018-08-07 22:09:54\ntags: java, jvm\ncategories: java\n---\n\n## gc算法 ##\n\n1.标记-清除算法(Mark-Sweep):\n\n\n缺点：\n\n> 效率不高\n> \n> 产生大量不连续的内存碎片\n\n<!-- more -->\n\n2.复制算法\n\n优点：\n\n> 实现简单，运行高效\n\n缺点：\n\n> 内存浪费\n\n商业用例：\n\n\tEden:Survivor = 8:1\n\n\n3.标记-整理算法/标记-压缩算法\n\n4.分代收集算法\n\n> 新生代：复制算法\n> \n> 老年代：标记-清除/标记-整理\n\n\n### 案例分析：HotSpot的实现 ###\n\n1.枚举根节点\n\n2.安全点\n\n3.安全区域\n\n\n\n## gc回收器 ##\n\n常用的参数\n\n|参数  |描述 |\n|-  |:----:|\n|UseSerialGC      | client模式下的默认值，Serial + Serial Old收集器                 |\n|UseParallelGC    | Server模式下的默认值，Parallel Scavenge + Serial Old收集器      |\n\n1.Serial\n\n2.ParNew\n\n\n3.Parallel Scavenge\n\n4.Serial Old\n\n5.Parallel Old\n\n6.CMS(并发低停顿收集器), 基于标记-清除算法\n\n目标：以获取最短回收停顿时间\n\n原理：\n\n>初始标记\n>\n>并发标记\n>\n>重新标记\n>\n>并发清除\n\n优点：\n\n缺点：\n\n> 对CPU资源非常敏感\n> \n> 无法处理浮动垃圾\n> \n> 产生大量空间碎片\n\n\n7.G1\n\n目标：\n\n原理：\n\n> 概念：\n> 优先列表\n> \n> Region\n> \n> Remembered Set\n> \n> Write Barrier\n> \n> CarTable\n\n\n> 初始标记\n> \n> 并发标记\n> \n> 最终标记\n> \n> 筛选回收\n\n\n优点：\n\n> 并行与并发\n> \n> 分代收集\n> \n> 空间整合：与CMS的标记-清除算法不同，G1整理看是标记-整理算法，局部(Region)看则是复制算法，不会产生内存碎片。\n> \n> 可预测的停顿：这是G1相比CMS的一大优势，降低停顿时间时G1和CMS共同的关注点，但G1除了追求低停顿，还能建立可预测的停顿时间模型\n\n缺点：\n\n\n\n## 内存分配、回收策略 ##\n\nMinor GC: 指发生在新生代的垃圾回收动作\n\nFull GC/Major GC: 指发生在老年代的GC，出现Full GC，经常会伴随至少一次Minor GC;\n\n1、对象优先在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC\n\n2、大对象直接进入老年代。大对象典型的就是那些很长的字符串、数组\n\n参数-XX:PretenureSizeThreshold可以设定大对象的标准\n\n3、长期存活的对象将进入老年代(默认是15岁)\n\nEden区对象经过Minor GC后，年龄增1，然后在Survivor每经历一次Minor GC，年龄增长1，达到指定年龄，进入老年代\n\n参数-XX:MaxTenuringThreshold\n\n4、动态年龄判定\n\n如果在Survivor区，相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于等于该年龄的对象可以直接进入老年代。【可以破坏规则3】\n\n5、空间分配担保\n\n### GC触发 ###\n\nMinor GC触发条件：\n\n> Eden区没有足够空间分配时，触发\n\nFull GC触发条件：\n\n>显式调用System.gc()时\n>\n>方法区空间不足\n>\n>老年代空间不足\n>\n>Eden区对象执行Minor GC后，进入老年代的所有对象和大于老年代可用内存时，触发Full GC\n>\n>Eden + From执行Minor GC时，如果存活对象大于To内存区，则直接进入老年代，如果老年代的可用内存小于该对象，则触发Full GC\n\n**注意:**jdk1.6_24之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会执行Minor GC,否则进行Full GC","slug":"java-jvm-gc","published":1,"updated":"2018-08-09T09:17:28.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde150011v0f0r3xpoxx0","content":"<h2 id=\"gc算法\"><a href=\"#gc算法\" class=\"headerlink\" title=\"gc算法\"></a>gc算法</h2><p>1.标记-清除算法(Mark-Sweep):</p>\n<p>缺点：</p>\n<blockquote>\n<p>效率不高</p>\n<p>产生大量不连续的内存碎片</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>2.复制算法</p>\n<p>优点：</p>\n<blockquote>\n<p>实现简单，运行高效</p>\n</blockquote>\n<p>缺点：</p>\n<blockquote>\n<p>内存浪费</p>\n</blockquote>\n<p>商业用例：</p>\n<pre><code>Eden:Survivor = 8:1\n</code></pre><p>3.标记-整理算法/标记-压缩算法</p>\n<p>4.分代收集算法</p>\n<blockquote>\n<p>新生代：复制算法</p>\n<p>老年代：标记-清除/标记-整理</p>\n</blockquote>\n<h3 id=\"案例分析：HotSpot的实现\"><a href=\"#案例分析：HotSpot的实现\" class=\"headerlink\" title=\"案例分析：HotSpot的实现\"></a>案例分析：HotSpot的实现</h3><p>1.枚举根节点</p>\n<p>2.安全点</p>\n<p>3.安全区域</p>\n<h2 id=\"gc回收器\"><a href=\"#gc回收器\" class=\"headerlink\" title=\"gc回收器\"></a>gc回收器</h2><p>常用的参数</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UseSerialGC</td>\n<td style=\"text-align:center\">client模式下的默认值，Serial + Serial Old收集器</td>\n</tr>\n<tr>\n<td>UseParallelGC</td>\n<td style=\"text-align:center\">Server模式下的默认值，Parallel Scavenge + Serial Old收集器</td>\n</tr>\n</tbody>\n</table>\n<p>1.Serial</p>\n<p>2.ParNew</p>\n<p>3.Parallel Scavenge</p>\n<p>4.Serial Old</p>\n<p>5.Parallel Old</p>\n<p>6.CMS(并发低停顿收集器), 基于标记-清除算法</p>\n<p>目标：以获取最短回收停顿时间</p>\n<p>原理：</p>\n<blockquote>\n<p>初始标记</p>\n<p>并发标记</p>\n<p>重新标记</p>\n<p>并发清除</p>\n</blockquote>\n<p>优点：</p>\n<p>缺点：</p>\n<blockquote>\n<p>对CPU资源非常敏感</p>\n<p>无法处理浮动垃圾</p>\n<p>产生大量空间碎片</p>\n</blockquote>\n<p>7.G1</p>\n<p>目标：</p>\n<p>原理：</p>\n<blockquote>\n<p>概念：<br>优先列表</p>\n<p>Region</p>\n<p>Remembered Set</p>\n<p>Write Barrier</p>\n<p>CarTable</p>\n</blockquote>\n<blockquote>\n<p>初始标记</p>\n<p>并发标记</p>\n<p>最终标记</p>\n<p>筛选回收</p>\n</blockquote>\n<p>优点：</p>\n<blockquote>\n<p>并行与并发</p>\n<p>分代收集</p>\n<p>空间整合：与CMS的标记-清除算法不同，G1整理看是标记-整理算法，局部(Region)看则是复制算法，不会产生内存碎片。</p>\n<p>可预测的停顿：这是G1相比CMS的一大优势，降低停顿时间时G1和CMS共同的关注点，但G1除了追求低停顿，还能建立可预测的停顿时间模型</p>\n</blockquote>\n<p>缺点：</p>\n<h2 id=\"内存分配、回收策略\"><a href=\"#内存分配、回收策略\" class=\"headerlink\" title=\"内存分配、回收策略\"></a>内存分配、回收策略</h2><p>Minor GC: 指发生在新生代的垃圾回收动作</p>\n<p>Full GC/Major GC: 指发生在老年代的GC，出现Full GC，经常会伴随至少一次Minor GC;</p>\n<p>1、对象优先在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</p>\n<p>2、大对象直接进入老年代。大对象典型的就是那些很长的字符串、数组</p>\n<p>参数-XX:PretenureSizeThreshold可以设定大对象的标准</p>\n<p>3、长期存活的对象将进入老年代(默认是15岁)</p>\n<p>Eden区对象经过Minor GC后，年龄增1，然后在Survivor每经历一次Minor GC，年龄增长1，达到指定年龄，进入老年代</p>\n<p>参数-XX:MaxTenuringThreshold</p>\n<p>4、动态年龄判定</p>\n<p>如果在Survivor区，相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于等于该年龄的对象可以直接进入老年代。【可以破坏规则3】</p>\n<p>5、空间分配担保</p>\n<h3 id=\"GC触发\"><a href=\"#GC触发\" class=\"headerlink\" title=\"GC触发\"></a>GC触发</h3><p>Minor GC触发条件：</p>\n<blockquote>\n<p>Eden区没有足够空间分配时，触发</p>\n</blockquote>\n<p>Full GC触发条件：</p>\n<blockquote>\n<p>显式调用System.gc()时</p>\n<p>方法区空间不足</p>\n<p>老年代空间不足</p>\n<p>Eden区对象执行Minor GC后，进入老年代的所有对象和大于老年代可用内存时，触发Full GC</p>\n<p>Eden + From执行Minor GC时，如果存活对象大于To内存区，则直接进入老年代，如果老年代的可用内存小于该对象，则触发Full GC</p>\n</blockquote>\n<p><strong>注意:</strong>jdk1.6_24之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会执行Minor GC,否则进行Full GC</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"gc算法\"><a href=\"#gc算法\" class=\"headerlink\" title=\"gc算法\"></a>gc算法</h2><p>1.标记-清除算法(Mark-Sweep):</p>\n<p>缺点：</p>\n<blockquote>\n<p>效率不高</p>\n<p>产生大量不连续的内存碎片</p>\n</blockquote>","more":"<p>2.复制算法</p>\n<p>优点：</p>\n<blockquote>\n<p>实现简单，运行高效</p>\n</blockquote>\n<p>缺点：</p>\n<blockquote>\n<p>内存浪费</p>\n</blockquote>\n<p>商业用例：</p>\n<pre><code>Eden:Survivor = 8:1\n</code></pre><p>3.标记-整理算法/标记-压缩算法</p>\n<p>4.分代收集算法</p>\n<blockquote>\n<p>新生代：复制算法</p>\n<p>老年代：标记-清除/标记-整理</p>\n</blockquote>\n<h3 id=\"案例分析：HotSpot的实现\"><a href=\"#案例分析：HotSpot的实现\" class=\"headerlink\" title=\"案例分析：HotSpot的实现\"></a>案例分析：HotSpot的实现</h3><p>1.枚举根节点</p>\n<p>2.安全点</p>\n<p>3.安全区域</p>\n<h2 id=\"gc回收器\"><a href=\"#gc回收器\" class=\"headerlink\" title=\"gc回收器\"></a>gc回收器</h2><p>常用的参数</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UseSerialGC</td>\n<td style=\"text-align:center\">client模式下的默认值，Serial + Serial Old收集器</td>\n</tr>\n<tr>\n<td>UseParallelGC</td>\n<td style=\"text-align:center\">Server模式下的默认值，Parallel Scavenge + Serial Old收集器</td>\n</tr>\n</tbody>\n</table>\n<p>1.Serial</p>\n<p>2.ParNew</p>\n<p>3.Parallel Scavenge</p>\n<p>4.Serial Old</p>\n<p>5.Parallel Old</p>\n<p>6.CMS(并发低停顿收集器), 基于标记-清除算法</p>\n<p>目标：以获取最短回收停顿时间</p>\n<p>原理：</p>\n<blockquote>\n<p>初始标记</p>\n<p>并发标记</p>\n<p>重新标记</p>\n<p>并发清除</p>\n</blockquote>\n<p>优点：</p>\n<p>缺点：</p>\n<blockquote>\n<p>对CPU资源非常敏感</p>\n<p>无法处理浮动垃圾</p>\n<p>产生大量空间碎片</p>\n</blockquote>\n<p>7.G1</p>\n<p>目标：</p>\n<p>原理：</p>\n<blockquote>\n<p>概念：<br>优先列表</p>\n<p>Region</p>\n<p>Remembered Set</p>\n<p>Write Barrier</p>\n<p>CarTable</p>\n</blockquote>\n<blockquote>\n<p>初始标记</p>\n<p>并发标记</p>\n<p>最终标记</p>\n<p>筛选回收</p>\n</blockquote>\n<p>优点：</p>\n<blockquote>\n<p>并行与并发</p>\n<p>分代收集</p>\n<p>空间整合：与CMS的标记-清除算法不同，G1整理看是标记-整理算法，局部(Region)看则是复制算法，不会产生内存碎片。</p>\n<p>可预测的停顿：这是G1相比CMS的一大优势，降低停顿时间时G1和CMS共同的关注点，但G1除了追求低停顿，还能建立可预测的停顿时间模型</p>\n</blockquote>\n<p>缺点：</p>\n<h2 id=\"内存分配、回收策略\"><a href=\"#内存分配、回收策略\" class=\"headerlink\" title=\"内存分配、回收策略\"></a>内存分配、回收策略</h2><p>Minor GC: 指发生在新生代的垃圾回收动作</p>\n<p>Full GC/Major GC: 指发生在老年代的GC，出现Full GC，经常会伴随至少一次Minor GC;</p>\n<p>1、对象优先在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</p>\n<p>2、大对象直接进入老年代。大对象典型的就是那些很长的字符串、数组</p>\n<p>参数-XX:PretenureSizeThreshold可以设定大对象的标准</p>\n<p>3、长期存活的对象将进入老年代(默认是15岁)</p>\n<p>Eden区对象经过Minor GC后，年龄增1，然后在Survivor每经历一次Minor GC，年龄增长1，达到指定年龄，进入老年代</p>\n<p>参数-XX:MaxTenuringThreshold</p>\n<p>4、动态年龄判定</p>\n<p>如果在Survivor区，相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于等于该年龄的对象可以直接进入老年代。【可以破坏规则3】</p>\n<p>5、空间分配担保</p>\n<h3 id=\"GC触发\"><a href=\"#GC触发\" class=\"headerlink\" title=\"GC触发\"></a>GC触发</h3><p>Minor GC触发条件：</p>\n<blockquote>\n<p>Eden区没有足够空间分配时，触发</p>\n</blockquote>\n<p>Full GC触发条件：</p>\n<blockquote>\n<p>显式调用System.gc()时</p>\n<p>方法区空间不足</p>\n<p>老年代空间不足</p>\n<p>Eden区对象执行Minor GC后，进入老年代的所有对象和大于老年代可用内存时，触发Full GC</p>\n<p>Eden + From执行Minor GC时，如果存活对象大于To内存区，则直接进入老年代，如果老年代的可用内存小于该对象，则触发Full GC</p>\n</blockquote>\n<p><strong>注意:</strong>jdk1.6_24之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会执行Minor GC,否则进行Full GC</p>"},{"title":"java-nio","date":"2018-08-14T04:14:12.000Z","_content":"","source":"_posts/java-nio.md","raw":"---\ntitle: java-nio\ndate: 2018-08-14 12:14:12\ntags:\n---\n","slug":"java-nio","published":1,"updated":"2018-08-14T04:14:12.504Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde180014v0f0of5y1qig","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java集合之ArrayList和LinkedList","date":"2018-08-15T10:15:54.000Z","_content":"集合的东西是很常用的类，今天抽时间看看源码，加深印象\n\n<!-- more -->\n\n# ArrayList #\n\n可以看到ArrayList的默认初始化大小为10，\n\n\tprivate static final int DEFAULT_CAPACITY = 10;\n\n## 插入元素 ##\n\n### add(E e) ###\n\n\tpublic boolean add(E e) {\n\t\t// 扩容机制，\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n\t\t\n\t\t// 直接在数组末尾插入元素\n        elementData[size++] = e;\n        return true;\n    }\n\t\n\t// 扩容\n\tprivate void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n\n\tprivate void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n\n\tprivate void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n\n\t\n### add(int index, E element) ###\n\n\tpublic void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n\n可以看到在指定位置index插入元素的时候才会导致元素的移动\n\n## 查找元素 ##\n\n\tpublic E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n\t@SuppressWarnings(\"unchecked\")\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n\n时间复杂度为O(1)\n\n## 删除元素 ##\n\n### remove(int index) ###\n\n\tpublic E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n        \n        // 向前移动的元素的位置\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n\t\n\t// 原生方法\n\tpublic static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n可以看到删除指定index的元素后，后面的所有元素向前移动。时间复杂度为O(n)\n\n### remove(Object o) ###\n\n\tpublic boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n\tprivate void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n    }\n\n删除指定对象Object的元素，也会导致后面的元素向前移动，只不过中间多了对象的比较过程，时间复杂度为O(n)\n\n\n# LinkedList #\n\n## 插入元素 ##\n\n### add(E e) ###\n\n\t// 在链表末尾插入元素\n    public boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n\t\n\t// 尾插法\n\tvoid linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n\t\t\t//初始链表为空，这是插入第一个元素\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n插入元素默认为尾插法，所以时间复杂度为O(1)\n\n### add(int index, E element) ###\n\tpublic void add(int index, E element) {\n\t\t// 检查插入位置是否合法\n        checkPositionIndex(index);\n\n        if (index == size)\n\t\t\t// 插入位置是末尾，包括列表为空的情况\n            linkLast(element);\n        else\n            linkBefore(element, node(index));\n    }\n\n\tvoid linkBefore(E e, Node<E> succ) {\n        // 先根据index找到要插入的位置，再修改引用，完成插入操作\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n\t\t// 插入位置为0，即插入第一个节点\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n如果指定index，仍然需要去遍历链表，时间复杂度为O(n)\n\n## 修改元素 ##\n\n\tpublic E set(int index, E element) {\n        checkElementIndex(index);\n\t\t\n\t\t// 先找到指定位置节点\n        Node<E> x = node(index);\n        E oldVal = x.item;\n        x.item = element;\n\t\t\n\t\t// 修改元素后返回旧值\n        return oldVal;\n    }\n修改元素也是先找到节点，然后修改value，时间复杂度为O(n)\n\n## 查找元素 ##\n\t\n\tpublic E get(int index) {\n        checkElementIndex(index);\n        return node(index).item;\n    }\n\t\n\t// 因为链表是双向的，具体从开始往后找还是从后往前找需要判断\n\tNode<E> node(int index) {\n        // assert isElementIndex(index);\n\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n\n查找index的元素，需要遍历链表，时间复杂度为O(n)\n\n## 删除元素 ##\n\n### remove(int index) ###\n\n\tpublic E remove(int index) {\n        checkElementIndex(index);\n        return unlink(node(index));\n    }\n\n\tE unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;\n        final Node<E> prev = x.prev;\n\n        if (prev == null) {\n            first = next;\n        } else {\n            prev.next = next;\n            x.prev = null;\n        }\n\n        if (next == null) {\n            last = prev;\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n\n### remove(Object o) ###\n\n\tpublic boolean remove(Object o) {\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n可以看到删除元素，也会先遍历查找到节点，然后再删除，时间复杂度为O(n)。\n\n\n## 总结： ##\n\n从源码可以看出\n1、 get(int index)、set(int index, E element)，ArrayList明显快于LinkedList，因为LinkedList需要移动指针\n\n2、add(E) ArrayList和LinkedList都是直接插入尾部\n\n3、add(int index, E element) ArrayList需要移动后面的元素，LinkedList需要遍历指针(需要具体分析)\n\n4、remove(int index)/remove(Object o) ArrayList需要移动后面的元素，LinkedList需要遍历指针(需要具体分析)","source":"_posts/java-list.md","raw":"---\ntitle: java集合之ArrayList和LinkedList\ndate: 2018-08-15 18:15:54\ntags: java, 集合\ncategories: java\n---\n集合的东西是很常用的类，今天抽时间看看源码，加深印象\n\n<!-- more -->\n\n# ArrayList #\n\n可以看到ArrayList的默认初始化大小为10，\n\n\tprivate static final int DEFAULT_CAPACITY = 10;\n\n## 插入元素 ##\n\n### add(E e) ###\n\n\tpublic boolean add(E e) {\n\t\t// 扩容机制，\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n\t\t\n\t\t// 直接在数组末尾插入元素\n        elementData[size++] = e;\n        return true;\n    }\n\t\n\t// 扩容\n\tprivate void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n\n\tprivate void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n\n\tprivate void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n\n\t\n### add(int index, E element) ###\n\n\tpublic void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n\n可以看到在指定位置index插入元素的时候才会导致元素的移动\n\n## 查找元素 ##\n\n\tpublic E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n\t@SuppressWarnings(\"unchecked\")\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n\n时间复杂度为O(1)\n\n## 删除元素 ##\n\n### remove(int index) ###\n\n\tpublic E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n        \n        // 向前移动的元素的位置\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n\t\n\t// 原生方法\n\tpublic static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n可以看到删除指定index的元素后，后面的所有元素向前移动。时间复杂度为O(n)\n\n### remove(Object o) ###\n\n\tpublic boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n\tprivate void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n    }\n\n删除指定对象Object的元素，也会导致后面的元素向前移动，只不过中间多了对象的比较过程，时间复杂度为O(n)\n\n\n# LinkedList #\n\n## 插入元素 ##\n\n### add(E e) ###\n\n\t// 在链表末尾插入元素\n    public boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n\t\n\t// 尾插法\n\tvoid linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n\t\t\t//初始链表为空，这是插入第一个元素\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n插入元素默认为尾插法，所以时间复杂度为O(1)\n\n### add(int index, E element) ###\n\tpublic void add(int index, E element) {\n\t\t// 检查插入位置是否合法\n        checkPositionIndex(index);\n\n        if (index == size)\n\t\t\t// 插入位置是末尾，包括列表为空的情况\n            linkLast(element);\n        else\n            linkBefore(element, node(index));\n    }\n\n\tvoid linkBefore(E e, Node<E> succ) {\n        // 先根据index找到要插入的位置，再修改引用，完成插入操作\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n\t\t// 插入位置为0，即插入第一个节点\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n如果指定index，仍然需要去遍历链表，时间复杂度为O(n)\n\n## 修改元素 ##\n\n\tpublic E set(int index, E element) {\n        checkElementIndex(index);\n\t\t\n\t\t// 先找到指定位置节点\n        Node<E> x = node(index);\n        E oldVal = x.item;\n        x.item = element;\n\t\t\n\t\t// 修改元素后返回旧值\n        return oldVal;\n    }\n修改元素也是先找到节点，然后修改value，时间复杂度为O(n)\n\n## 查找元素 ##\n\t\n\tpublic E get(int index) {\n        checkElementIndex(index);\n        return node(index).item;\n    }\n\t\n\t// 因为链表是双向的，具体从开始往后找还是从后往前找需要判断\n\tNode<E> node(int index) {\n        // assert isElementIndex(index);\n\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n\n查找index的元素，需要遍历链表，时间复杂度为O(n)\n\n## 删除元素 ##\n\n### remove(int index) ###\n\n\tpublic E remove(int index) {\n        checkElementIndex(index);\n        return unlink(node(index));\n    }\n\n\tE unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;\n        final Node<E> prev = x.prev;\n\n        if (prev == null) {\n            first = next;\n        } else {\n            prev.next = next;\n            x.prev = null;\n        }\n\n        if (next == null) {\n            last = prev;\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n\n### remove(Object o) ###\n\n\tpublic boolean remove(Object o) {\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n可以看到删除元素，也会先遍历查找到节点，然后再删除，时间复杂度为O(n)。\n\n\n## 总结： ##\n\n从源码可以看出\n1、 get(int index)、set(int index, E element)，ArrayList明显快于LinkedList，因为LinkedList需要移动指针\n\n2、add(E) ArrayList和LinkedList都是直接插入尾部\n\n3、add(int index, E element) ArrayList需要移动后面的元素，LinkedList需要遍历指针(需要具体分析)\n\n4、remove(int index)/remove(Object o) ArrayList需要移动后面的元素，LinkedList需要遍历指针(需要具体分析)","slug":"java-list","published":1,"updated":"2018-08-15T14:58:09.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde1c0017v0f0cxl87p87","content":"<p>集合的东西是很常用的类，今天抽时间看看源码，加深印象</p>\n<a id=\"more\"></a>\n<h1 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h1><p>可以看到ArrayList的默认初始化大小为10，</p>\n<pre><code>private static final int DEFAULT_CAPACITY = 10;\n</code></pre><h2 id=\"插入元素\"><a href=\"#插入元素\" class=\"headerlink\" title=\"插入元素\"></a>插入元素</h2><h3 id=\"add-E-e\"><a href=\"#add-E-e\" class=\"headerlink\" title=\"add(E e)\"></a>add(E e)</h3><pre><code>public boolean add(E e) {\n    // 扩容机制，\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n\n    // 直接在数组末尾插入元素\n    elementData[size++] = e;\n    return true;\n}\n\n// 扩容\nprivate void ensureCapacityInternal(int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n\n    ensureExplicitCapacity(minCapacity);\n}\n\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n\n    // overflow-conscious code\n    if (minCapacity - elementData.length &gt; 0)\n        grow(minCapacity);\n}\n\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n</code></pre><h3 id=\"add-int-index-E-element\"><a href=\"#add-int-index-E-element\" class=\"headerlink\" title=\"add(int index, E element)\"></a>add(int index, E element)</h3><pre><code>public void add(int index, E element) {\n    rangeCheckForAdd(index);\n\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n    elementData[index] = element;\n    size++;\n}\n</code></pre><p>可以看到在指定位置index插入元素的时候才会导致元素的移动</p>\n<h2 id=\"查找元素\"><a href=\"#查找元素\" class=\"headerlink\" title=\"查找元素\"></a>查找元素</h2><pre><code>public E get(int index) {\n    rangeCheck(index);\n\n    return elementData(index);\n}\n\n@SuppressWarnings(&quot;unchecked&quot;)\nE elementData(int index) {\n    return (E) elementData[index];\n}\n</code></pre><p>时间复杂度为O(1)</p>\n<h2 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h2><h3 id=\"remove-int-index\"><a href=\"#remove-int-index\" class=\"headerlink\" title=\"remove(int index)\"></a>remove(int index)</h3><pre><code>public E remove(int index) {\n    rangeCheck(index);\n\n    modCount++;\n    E oldValue = elementData(index);\n\n    // 向前移动的元素的位置\n    int numMoved = size - index - 1;\n    if (numMoved &gt; 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n\n    return oldValue;\n}\n\n// 原生方法\npublic static native void arraycopy(Object src,  int  srcPos,\n                                    Object dest, int destPos,\n                                    int length);\n</code></pre><p>可以看到删除指定index的元素后，后面的所有元素向前移动。时间复杂度为O(n)</p>\n<h3 id=\"remove-Object-o\"><a href=\"#remove-Object-o\" class=\"headerlink\" title=\"remove(Object o)\"></a>remove(Object o)</h3><pre><code>public boolean remove(Object o) {\n    if (o == null) {\n        for (int index = 0; index &lt; size; index++)\n            if (elementData[index] == null) {\n                fastRemove(index);\n                return true;\n            }\n    } else {\n        for (int index = 0; index &lt; size; index++)\n            if (o.equals(elementData[index])) {\n                fastRemove(index);\n                return true;\n            }\n    }\n    return false;\n}\n\nprivate void fastRemove(int index) {\n    modCount++;\n    int numMoved = size - index - 1;\n    if (numMoved &gt; 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n}\n</code></pre><p>删除指定对象Object的元素，也会导致后面的元素向前移动，只不过中间多了对象的比较过程，时间复杂度为O(n)</p>\n<h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h1><h2 id=\"插入元素-1\"><a href=\"#插入元素-1\" class=\"headerlink\" title=\"插入元素\"></a>插入元素</h2><h3 id=\"add-E-e-1\"><a href=\"#add-E-e-1\" class=\"headerlink\" title=\"add(E e)\"></a>add(E e)</h3><pre><code>// 在链表末尾插入元素\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n\n// 尾插法\nvoid linkLast(E e) {\n    final Node&lt;E&gt; l = last;\n    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);\n    last = newNode;\n    if (l == null)\n        //初始链表为空，这是插入第一个元素\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n</code></pre><p>插入元素默认为尾插法，所以时间复杂度为O(1)</p>\n<h3 id=\"add-int-index-E-element-1\"><a href=\"#add-int-index-E-element-1\" class=\"headerlink\" title=\"add(int index, E element)\"></a>add(int index, E element)</h3><pre><code>public void add(int index, E element) {\n    // 检查插入位置是否合法\n    checkPositionIndex(index);\n\n    if (index == size)\n        // 插入位置是末尾，包括列表为空的情况\n        linkLast(element);\n    else\n        linkBefore(element, node(index));\n}\n\nvoid linkBefore(E e, Node&lt;E&gt; succ) {\n    // 先根据index找到要插入的位置，再修改引用，完成插入操作\n    final Node&lt;E&gt; pred = succ.prev;\n    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);\n    succ.prev = newNode;\n    // 插入位置为0，即插入第一个节点\n    if (pred == null)\n        first = newNode;\n    else\n        pred.next = newNode;\n    size++;\n    modCount++;\n}\n</code></pre><p>如果指定index，仍然需要去遍历链表，时间复杂度为O(n)</p>\n<h2 id=\"修改元素\"><a href=\"#修改元素\" class=\"headerlink\" title=\"修改元素\"></a>修改元素</h2><pre><code>public E set(int index, E element) {\n    checkElementIndex(index);\n\n    // 先找到指定位置节点\n    Node&lt;E&gt; x = node(index);\n    E oldVal = x.item;\n    x.item = element;\n\n    // 修改元素后返回旧值\n    return oldVal;\n}\n</code></pre><p>修改元素也是先找到节点，然后修改value，时间复杂度为O(n)</p>\n<h2 id=\"查找元素-1\"><a href=\"#查找元素-1\" class=\"headerlink\" title=\"查找元素\"></a>查找元素</h2><pre><code>public E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\n\n// 因为链表是双向的，具体从开始往后找还是从后往前找需要判断\nNode&lt;E&gt; node(int index) {\n    // assert isElementIndex(index);\n\n    if (index &lt; (size &gt;&gt; 1)) {\n        Node&lt;E&gt; x = first;\n        for (int i = 0; i &lt; index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node&lt;E&gt; x = last;\n        for (int i = size - 1; i &gt; index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n</code></pre><p>查找index的元素，需要遍历链表，时间复杂度为O(n)</p>\n<h2 id=\"删除元素-1\"><a href=\"#删除元素-1\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h2><h3 id=\"remove-int-index-1\"><a href=\"#remove-int-index-1\" class=\"headerlink\" title=\"remove(int index)\"></a>remove(int index)</h3><pre><code>public E remove(int index) {\n    checkElementIndex(index);\n    return unlink(node(index));\n}\n\nE unlink(Node&lt;E&gt; x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node&lt;E&gt; next = x.next;\n    final Node&lt;E&gt; prev = x.prev;\n\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n</code></pre><h3 id=\"remove-Object-o-1\"><a href=\"#remove-Object-o-1\" class=\"headerlink\" title=\"remove(Object o)\"></a>remove(Object o)</h3><pre><code>public boolean remove(Object o) {\n    if (o == null) {\n        for (Node&lt;E&gt; x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        for (Node&lt;E&gt; x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n</code></pre><p>可以看到删除元素，也会先遍历查找到节点，然后再删除，时间复杂度为O(n)。</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>从源码可以看出<br>1、 get(int index)、set(int index, E element)，ArrayList明显快于LinkedList，因为LinkedList需要移动指针</p>\n<p>2、add(E) ArrayList和LinkedList都是直接插入尾部</p>\n<p>3、add(int index, E element) ArrayList需要移动后面的元素，LinkedList需要遍历指针(需要具体分析)</p>\n<p>4、remove(int index)/remove(Object o) ArrayList需要移动后面的元素，LinkedList需要遍历指针(需要具体分析)</p>\n","site":{"data":{}},"excerpt":"<p>集合的东西是很常用的类，今天抽时间看看源码，加深印象</p>","more":"<h1 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h1><p>可以看到ArrayList的默认初始化大小为10，</p>\n<pre><code>private static final int DEFAULT_CAPACITY = 10;\n</code></pre><h2 id=\"插入元素\"><a href=\"#插入元素\" class=\"headerlink\" title=\"插入元素\"></a>插入元素</h2><h3 id=\"add-E-e\"><a href=\"#add-E-e\" class=\"headerlink\" title=\"add(E e)\"></a>add(E e)</h3><pre><code>public boolean add(E e) {\n    // 扩容机制，\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n\n    // 直接在数组末尾插入元素\n    elementData[size++] = e;\n    return true;\n}\n\n// 扩容\nprivate void ensureCapacityInternal(int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n\n    ensureExplicitCapacity(minCapacity);\n}\n\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n\n    // overflow-conscious code\n    if (minCapacity - elementData.length &gt; 0)\n        grow(minCapacity);\n}\n\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n</code></pre><h3 id=\"add-int-index-E-element\"><a href=\"#add-int-index-E-element\" class=\"headerlink\" title=\"add(int index, E element)\"></a>add(int index, E element)</h3><pre><code>public void add(int index, E element) {\n    rangeCheckForAdd(index);\n\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n    elementData[index] = element;\n    size++;\n}\n</code></pre><p>可以看到在指定位置index插入元素的时候才会导致元素的移动</p>\n<h2 id=\"查找元素\"><a href=\"#查找元素\" class=\"headerlink\" title=\"查找元素\"></a>查找元素</h2><pre><code>public E get(int index) {\n    rangeCheck(index);\n\n    return elementData(index);\n}\n\n@SuppressWarnings(&quot;unchecked&quot;)\nE elementData(int index) {\n    return (E) elementData[index];\n}\n</code></pre><p>时间复杂度为O(1)</p>\n<h2 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h2><h3 id=\"remove-int-index\"><a href=\"#remove-int-index\" class=\"headerlink\" title=\"remove(int index)\"></a>remove(int index)</h3><pre><code>public E remove(int index) {\n    rangeCheck(index);\n\n    modCount++;\n    E oldValue = elementData(index);\n\n    // 向前移动的元素的位置\n    int numMoved = size - index - 1;\n    if (numMoved &gt; 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n\n    return oldValue;\n}\n\n// 原生方法\npublic static native void arraycopy(Object src,  int  srcPos,\n                                    Object dest, int destPos,\n                                    int length);\n</code></pre><p>可以看到删除指定index的元素后，后面的所有元素向前移动。时间复杂度为O(n)</p>\n<h3 id=\"remove-Object-o\"><a href=\"#remove-Object-o\" class=\"headerlink\" title=\"remove(Object o)\"></a>remove(Object o)</h3><pre><code>public boolean remove(Object o) {\n    if (o == null) {\n        for (int index = 0; index &lt; size; index++)\n            if (elementData[index] == null) {\n                fastRemove(index);\n                return true;\n            }\n    } else {\n        for (int index = 0; index &lt; size; index++)\n            if (o.equals(elementData[index])) {\n                fastRemove(index);\n                return true;\n            }\n    }\n    return false;\n}\n\nprivate void fastRemove(int index) {\n    modCount++;\n    int numMoved = size - index - 1;\n    if (numMoved &gt; 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n}\n</code></pre><p>删除指定对象Object的元素，也会导致后面的元素向前移动，只不过中间多了对象的比较过程，时间复杂度为O(n)</p>\n<h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h1><h2 id=\"插入元素-1\"><a href=\"#插入元素-1\" class=\"headerlink\" title=\"插入元素\"></a>插入元素</h2><h3 id=\"add-E-e-1\"><a href=\"#add-E-e-1\" class=\"headerlink\" title=\"add(E e)\"></a>add(E e)</h3><pre><code>// 在链表末尾插入元素\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n\n// 尾插法\nvoid linkLast(E e) {\n    final Node&lt;E&gt; l = last;\n    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);\n    last = newNode;\n    if (l == null)\n        //初始链表为空，这是插入第一个元素\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n</code></pre><p>插入元素默认为尾插法，所以时间复杂度为O(1)</p>\n<h3 id=\"add-int-index-E-element-1\"><a href=\"#add-int-index-E-element-1\" class=\"headerlink\" title=\"add(int index, E element)\"></a>add(int index, E element)</h3><pre><code>public void add(int index, E element) {\n    // 检查插入位置是否合法\n    checkPositionIndex(index);\n\n    if (index == size)\n        // 插入位置是末尾，包括列表为空的情况\n        linkLast(element);\n    else\n        linkBefore(element, node(index));\n}\n\nvoid linkBefore(E e, Node&lt;E&gt; succ) {\n    // 先根据index找到要插入的位置，再修改引用，完成插入操作\n    final Node&lt;E&gt; pred = succ.prev;\n    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);\n    succ.prev = newNode;\n    // 插入位置为0，即插入第一个节点\n    if (pred == null)\n        first = newNode;\n    else\n        pred.next = newNode;\n    size++;\n    modCount++;\n}\n</code></pre><p>如果指定index，仍然需要去遍历链表，时间复杂度为O(n)</p>\n<h2 id=\"修改元素\"><a href=\"#修改元素\" class=\"headerlink\" title=\"修改元素\"></a>修改元素</h2><pre><code>public E set(int index, E element) {\n    checkElementIndex(index);\n\n    // 先找到指定位置节点\n    Node&lt;E&gt; x = node(index);\n    E oldVal = x.item;\n    x.item = element;\n\n    // 修改元素后返回旧值\n    return oldVal;\n}\n</code></pre><p>修改元素也是先找到节点，然后修改value，时间复杂度为O(n)</p>\n<h2 id=\"查找元素-1\"><a href=\"#查找元素-1\" class=\"headerlink\" title=\"查找元素\"></a>查找元素</h2><pre><code>public E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\n\n// 因为链表是双向的，具体从开始往后找还是从后往前找需要判断\nNode&lt;E&gt; node(int index) {\n    // assert isElementIndex(index);\n\n    if (index &lt; (size &gt;&gt; 1)) {\n        Node&lt;E&gt; x = first;\n        for (int i = 0; i &lt; index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node&lt;E&gt; x = last;\n        for (int i = size - 1; i &gt; index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n</code></pre><p>查找index的元素，需要遍历链表，时间复杂度为O(n)</p>\n<h2 id=\"删除元素-1\"><a href=\"#删除元素-1\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h2><h3 id=\"remove-int-index-1\"><a href=\"#remove-int-index-1\" class=\"headerlink\" title=\"remove(int index)\"></a>remove(int index)</h3><pre><code>public E remove(int index) {\n    checkElementIndex(index);\n    return unlink(node(index));\n}\n\nE unlink(Node&lt;E&gt; x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node&lt;E&gt; next = x.next;\n    final Node&lt;E&gt; prev = x.prev;\n\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n</code></pre><h3 id=\"remove-Object-o-1\"><a href=\"#remove-Object-o-1\" class=\"headerlink\" title=\"remove(Object o)\"></a>remove(Object o)</h3><pre><code>public boolean remove(Object o) {\n    if (o == null) {\n        for (Node&lt;E&gt; x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        for (Node&lt;E&gt; x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n</code></pre><p>可以看到删除元素，也会先遍历查找到节点，然后再删除，时间复杂度为O(n)。</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>从源码可以看出<br>1、 get(int index)、set(int index, E element)，ArrayList明显快于LinkedList，因为LinkedList需要移动指针</p>\n<p>2、add(E) ArrayList和LinkedList都是直接插入尾部</p>\n<p>3、add(int index, E element) ArrayList需要移动后面的元素，LinkedList需要遍历指针(需要具体分析)</p>\n<p>4、remove(int index)/remove(Object o) ArrayList需要移动后面的元素，LinkedList需要遍历指针(需要具体分析)</p>"},{"title":"java中的引用类型","date":"2018-08-11T03:58:29.000Z","_content":"## 强引用 ##\n\n只要强引用还存在，垃圾回收器永远不会回收被引用的对象\n\nObject obj = new Object()\n\n<!-- more -->\n\n## 软引用 ##\n\n在系统发生内存溢出之前，将会把这些对象列进回收范围进行第二次回收\n\nJDK1.2+的SoftReference\n\n## 弱引用 ##\n\n比软引用更弱一些，当垃圾收集器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象\n\nJDK1.2+的WeakReference\n\n## 虚引用(幽灵引用/幻影引用) ##\n\n它是最弱的一种引用，一个对象即使有虚引用，也会被回收。为对象设置虚引用的目的就是在这个对象被收集器回收时收到一个系统通知\n\nJDK1.2+的PhantomReference","source":"_posts/java-reference.md","raw":"---\ntitle: java中的引用类型\ndate: 2018-08-11 11:58:29\ntags: java, jvm\ncategories: java\n---\n## 强引用 ##\n\n只要强引用还存在，垃圾回收器永远不会回收被引用的对象\n\nObject obj = new Object()\n\n<!-- more -->\n\n## 软引用 ##\n\n在系统发生内存溢出之前，将会把这些对象列进回收范围进行第二次回收\n\nJDK1.2+的SoftReference\n\n## 弱引用 ##\n\n比软引用更弱一些，当垃圾收集器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象\n\nJDK1.2+的WeakReference\n\n## 虚引用(幽灵引用/幻影引用) ##\n\n它是最弱的一种引用，一个对象即使有虚引用，也会被回收。为对象设置虚引用的目的就是在这个对象被收集器回收时收到一个系统通知\n\nJDK1.2+的PhantomReference","slug":"java-reference","published":1,"updated":"2018-08-14T04:01:30.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde1g001av0f0pjej7fxv","content":"<h2 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h2><p>只要强引用还存在，垃圾回收器永远不会回收被引用的对象</p>\n<p>Object obj = new Object()</p>\n<a id=\"more\"></a>\n<h2 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h2><p>在系统发生内存溢出之前，将会把这些对象列进回收范围进行第二次回收</p>\n<p>JDK1.2+的SoftReference</p>\n<h2 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h2><p>比软引用更弱一些，当垃圾收集器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象</p>\n<p>JDK1.2+的WeakReference</p>\n<h2 id=\"虚引用-幽灵引用-幻影引用\"><a href=\"#虚引用-幽灵引用-幻影引用\" class=\"headerlink\" title=\"虚引用(幽灵引用/幻影引用)\"></a>虚引用(幽灵引用/幻影引用)</h2><p>它是最弱的一种引用，一个对象即使有虚引用，也会被回收。为对象设置虚引用的目的就是在这个对象被收集器回收时收到一个系统通知</p>\n<p>JDK1.2+的PhantomReference</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h2><p>只要强引用还存在，垃圾回收器永远不会回收被引用的对象</p>\n<p>Object obj = new Object()</p>","more":"<h2 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h2><p>在系统发生内存溢出之前，将会把这些对象列进回收范围进行第二次回收</p>\n<p>JDK1.2+的SoftReference</p>\n<h2 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h2><p>比软引用更弱一些，当垃圾收集器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象</p>\n<p>JDK1.2+的WeakReference</p>\n<h2 id=\"虚引用-幽灵引用-幻影引用\"><a href=\"#虚引用-幽灵引用-幻影引用\" class=\"headerlink\" title=\"虚引用(幽灵引用/幻影引用)\"></a>虚引用(幽灵引用/幻影引用)</h2><p>它是最弱的一种引用，一个对象即使有虚引用，也会被回收。为对象设置虚引用的目的就是在这个对象被收集器回收时收到一个系统通知</p>\n<p>JDK1.2+的PhantomReference</p>"},{"title":"java-treemap","date":"2018-08-15T10:17:09.000Z","_content":"","source":"_posts/java-treemap.md","raw":"---\ntitle: java-treemap\ndate: 2018-08-15 18:17:09\ntags:\n---\n","slug":"java-treemap","published":1,"updated":"2018-08-15T10:17:12.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde1l001ev0f0pywzjnpn","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"mysql-lock","date":"2018-08-06T17:04:31.000Z","_content":"","source":"_posts/mysql-lock.md","raw":"---\ntitle: mysql-lock\ndate: 2018-08-07 01:04:31\ntags:\n---\n","slug":"mysql-lock","published":1,"updated":"2018-08-06T17:04:31.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde1p001hv0f0i7guf4vl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"mysql索引","date":"2018-08-06T17:03:58.000Z","_content":"\n\n\n## 索引失效的问题 ##\n\nin、not in、like、or不走索引","source":"_posts/mysql-index.md","raw":"---\ntitle: mysql索引\ndate: 2018-08-07 01:03:58\ntags: mysql, 索引\ncategories: mysql\n---\n\n\n\n## 索引失效的问题 ##\n\nin、not in、like、or不走索引","slug":"mysql-index","published":1,"updated":"2018-08-07T09:34:10.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde1s001kv0f0kjyxudnc","content":"<h2 id=\"索引失效的问题\"><a href=\"#索引失效的问题\" class=\"headerlink\" title=\"索引失效的问题\"></a>索引失效的问题</h2><p>in、not in、like、or不走索引</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"索引失效的问题\"><a href=\"#索引失效的问题\" class=\"headerlink\" title=\"索引失效的问题\"></a>索引失效的问题</h2><p>in、not in、like、or不走索引</p>\n"},{"title":"java爬虫技术","date":"2018-04-21T12:33:19.000Z","_content":"","source":"_posts/javaCrawler.md","raw":"---\ntitle: java爬虫技术\ndate: 2018-04-21 20:33:19\ntags: java, 爬虫\ncategories: 爬虫\n---\n","slug":"javaCrawler","published":1,"updated":"2018-07-25T09:21:52.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde1v001nv0f0d4k2lat2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Threadlocal原理分析","date":"2018-08-11T02:16:46.000Z","_content":"## ThreadLocal的底层实现 ##\n\n### 主要方法： ###\n\n#### set ####\n\n\tpublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n\n<!-- more -->\n\n#### get ####\n\n\tpublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();\n    }\n可以看到先获取当前线程t,然后根据t得到ThreadLocalMap对象，如果map为null则设置初始值。\n\n#### getMap(t) ####\n\n\tThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n从getMap可以看到返回的是当前线程的threadLocals属性。\n\n#### ThreadLocalMap类 ####\n\n\tstatic class ThreadLocalMap {\n\n        static class Entry extends WeakReference<ThreadLocal> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n\n        private static final int INITIAL_CAPACITY = 16;\n\n        private Entry[] table;\n\t\t\n\t\t...\n\n        private Entry getEntry(ThreadLocal key) {\n            int i = key.threadLocalHashCode & (table.length - 1);\n            Entry e = table[i];\n            if (e != null && e.get() == key)\n                return e;\n            else\n                return getEntryAfterMiss(key, i, e);\n        }\n\n可以看到其实ThreadLocalMap就是HashMap的一个变形。\n\n#### setInitialValue ####\n\n\tprivate T setInitialValue() {\n        T value = initialValue();\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n        return value;\n    }\n\n\tprotected T initialValue() {\n        return null;\n    }\n\n\tvoid createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n    }\n可以看到初始化时，为当前线程t设置了一个key为当前ThreadLocal对象，value为null的threadLocals属性。\n\n\n## ThreadLocal初始化在堆上还是栈上 ##\n\n## ThreadLocal会导致内存泄漏吗? ##\n\n看到一篇博客讲不会发生内存泄漏，原因是Entry是一个弱引用，如果entry.get()=null，entry会被擦除\n\n\tstatic class ThreadLocalMap {\n\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as \"stale entries\" in the code that follows.\n         */\n        static class Entry extends WeakReference<ThreadLocal> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n\n[技术小黑屋](https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/ \"技术小黑屋\")\n\n\n\n## ThreadLocal和InheritableThreadLocal的区别 ##\n\nInheritableThreadLocal会自动将值传递给子线程，也就是说在子线程可以看到父线程的值。\n\n**注意：**为了保护线程安全，应该只对不可变的对象使用InheritableThreadLocal。但不能是有状态的对象，例如JDBC Connection\n\nThreadLocal\n\n    static final ThreadLocal<Integer> threadLocal = new ThreadLocal();\n\n    public static void main(String[] args){\n\n        threadLocal.set(123);\n        System.out.println(\"父线程获取threadLocal:\" + threadLocal.get());\n\n        Thread t = new Thread(){\n            @Override\n            public void run() {\n                super.run();\n                System.out.println(\"设值前：子线程获取threadLocal:\" + threadLocal.get());\n\n                threadLocal.set(234);\n                System.out.println(\"设值后：子线程获取threadLocal:\" + threadLocal.get());\n            }\n        };\n\n        t.start();\n\n    }\n\n返回值\n\n\t父线程获取threadLocal:123\n\t设值前：子线程获取threadLocal:null\n\t设值后：子线程获取threadLocal:234\n\nInheritableThreadLocal\n\n\tstatic final ThreadLocal threadLocal = new InheritableThreadLocal();\n\n    public static void main(String[] args){\n\n        threadLocal.set(123);\n        System.out.println(\"父线程获取threadLocal:\" + threadLocal.get());\n\n        Thread t = new Thread(){\n            @Override\n            public void run() {\n                super.run();\n                System.out.println(\"设值前：子线程获取threadLocal:\" + threadLocal.get());\n\n                threadLocal.set(234);\n                System.out.println(\"设值后：子线程获取threadLocal:\" + threadLocal.get());\n            }\n        };\n\n        t.start();\n\n    }\n\n返回值\n\n\t父线程获取threadLocal:123\n\t设值前：子线程获取threadLocal:123\n\t设值后：子线程获取threadLocal:234\n\n### ThreadLocal的应用场景 ###\n\n1.实现单个线程单例以及单个线程上下文信息存储，比如交易id等\n\n2.实现对象线程安全，例如：数据库连接\n\n3.承载一些线程相关的数据，避免在方法中来回传递参数。例如：Session管理\n\n### InheritableThreadLocal的应用场景 ###\n\n1、用户标识\n\n2、事务标识\n","source":"_posts/java-threadlocal.md","raw":"---\ntitle: Threadlocal原理分析\ndate: 2018-08-11 10:16:46\ntags: java, threadlocal\ncategories: java\n---\n## ThreadLocal的底层实现 ##\n\n### 主要方法： ###\n\n#### set ####\n\n\tpublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n\n<!-- more -->\n\n#### get ####\n\n\tpublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();\n    }\n可以看到先获取当前线程t,然后根据t得到ThreadLocalMap对象，如果map为null则设置初始值。\n\n#### getMap(t) ####\n\n\tThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n从getMap可以看到返回的是当前线程的threadLocals属性。\n\n#### ThreadLocalMap类 ####\n\n\tstatic class ThreadLocalMap {\n\n        static class Entry extends WeakReference<ThreadLocal> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n\n        private static final int INITIAL_CAPACITY = 16;\n\n        private Entry[] table;\n\t\t\n\t\t...\n\n        private Entry getEntry(ThreadLocal key) {\n            int i = key.threadLocalHashCode & (table.length - 1);\n            Entry e = table[i];\n            if (e != null && e.get() == key)\n                return e;\n            else\n                return getEntryAfterMiss(key, i, e);\n        }\n\n可以看到其实ThreadLocalMap就是HashMap的一个变形。\n\n#### setInitialValue ####\n\n\tprivate T setInitialValue() {\n        T value = initialValue();\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n        return value;\n    }\n\n\tprotected T initialValue() {\n        return null;\n    }\n\n\tvoid createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n    }\n可以看到初始化时，为当前线程t设置了一个key为当前ThreadLocal对象，value为null的threadLocals属性。\n\n\n## ThreadLocal初始化在堆上还是栈上 ##\n\n## ThreadLocal会导致内存泄漏吗? ##\n\n看到一篇博客讲不会发生内存泄漏，原因是Entry是一个弱引用，如果entry.get()=null，entry会被擦除\n\n\tstatic class ThreadLocalMap {\n\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as \"stale entries\" in the code that follows.\n         */\n        static class Entry extends WeakReference<ThreadLocal> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n\n[技术小黑屋](https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/ \"技术小黑屋\")\n\n\n\n## ThreadLocal和InheritableThreadLocal的区别 ##\n\nInheritableThreadLocal会自动将值传递给子线程，也就是说在子线程可以看到父线程的值。\n\n**注意：**为了保护线程安全，应该只对不可变的对象使用InheritableThreadLocal。但不能是有状态的对象，例如JDBC Connection\n\nThreadLocal\n\n    static final ThreadLocal<Integer> threadLocal = new ThreadLocal();\n\n    public static void main(String[] args){\n\n        threadLocal.set(123);\n        System.out.println(\"父线程获取threadLocal:\" + threadLocal.get());\n\n        Thread t = new Thread(){\n            @Override\n            public void run() {\n                super.run();\n                System.out.println(\"设值前：子线程获取threadLocal:\" + threadLocal.get());\n\n                threadLocal.set(234);\n                System.out.println(\"设值后：子线程获取threadLocal:\" + threadLocal.get());\n            }\n        };\n\n        t.start();\n\n    }\n\n返回值\n\n\t父线程获取threadLocal:123\n\t设值前：子线程获取threadLocal:null\n\t设值后：子线程获取threadLocal:234\n\nInheritableThreadLocal\n\n\tstatic final ThreadLocal threadLocal = new InheritableThreadLocal();\n\n    public static void main(String[] args){\n\n        threadLocal.set(123);\n        System.out.println(\"父线程获取threadLocal:\" + threadLocal.get());\n\n        Thread t = new Thread(){\n            @Override\n            public void run() {\n                super.run();\n                System.out.println(\"设值前：子线程获取threadLocal:\" + threadLocal.get());\n\n                threadLocal.set(234);\n                System.out.println(\"设值后：子线程获取threadLocal:\" + threadLocal.get());\n            }\n        };\n\n        t.start();\n\n    }\n\n返回值\n\n\t父线程获取threadLocal:123\n\t设值前：子线程获取threadLocal:123\n\t设值后：子线程获取threadLocal:234\n\n### ThreadLocal的应用场景 ###\n\n1.实现单个线程单例以及单个线程上下文信息存储，比如交易id等\n\n2.实现对象线程安全，例如：数据库连接\n\n3.承载一些线程相关的数据，避免在方法中来回传递参数。例如：Session管理\n\n### InheritableThreadLocal的应用场景 ###\n\n1、用户标识\n\n2、事务标识\n","slug":"java-threadlocal","published":1,"updated":"2018-08-11T04:08:19.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde20001rv0f0s8a5lks9","content":"<h2 id=\"ThreadLocal的底层实现\"><a href=\"#ThreadLocal的底层实现\" class=\"headerlink\" title=\"ThreadLocal的底层实现\"></a>ThreadLocal的底层实现</h2><h3 id=\"主要方法：\"><a href=\"#主要方法：\" class=\"headerlink\" title=\"主要方法：\"></a>主要方法：</h3><h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><pre><code>public void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n</code></pre><a id=\"more\"></a>\n<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h4><pre><code>public T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null)\n            return (T)e.value;\n    }\n    return setInitialValue();\n}\n</code></pre><p>可以看到先获取当前线程t,然后根据t得到ThreadLocalMap对象，如果map为null则设置初始值。</p>\n<h4 id=\"getMap-t\"><a href=\"#getMap-t\" class=\"headerlink\" title=\"getMap(t)\"></a>getMap(t)</h4><pre><code>ThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n</code></pre><p>从getMap可以看到返回的是当前线程的threadLocals属性。</p>\n<h4 id=\"ThreadLocalMap类\"><a href=\"#ThreadLocalMap类\" class=\"headerlink\" title=\"ThreadLocalMap类\"></a>ThreadLocalMap类</h4><pre><code>static class ThreadLocalMap {\n\n    static class Entry extends WeakReference&lt;ThreadLocal&gt; {\n        /** The value associated with this ThreadLocal. */\n        Object value;\n\n        Entry(ThreadLocal k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n\n    private static final int INITIAL_CAPACITY = 16;\n\n    private Entry[] table;\n\n    ...\n\n    private Entry getEntry(ThreadLocal key) {\n        int i = key.threadLocalHashCode &amp; (table.length - 1);\n        Entry e = table[i];\n        if (e != null &amp;&amp; e.get() == key)\n            return e;\n        else\n            return getEntryAfterMiss(key, i, e);\n    }\n</code></pre><p>可以看到其实ThreadLocalMap就是HashMap的一个变形。</p>\n<h4 id=\"setInitialValue\"><a href=\"#setInitialValue\" class=\"headerlink\" title=\"setInitialValue\"></a>setInitialValue</h4><pre><code>private T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n\nprotected T initialValue() {\n    return null;\n}\n\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n</code></pre><p>可以看到初始化时，为当前线程t设置了一个key为当前ThreadLocal对象，value为null的threadLocals属性。</p>\n<h2 id=\"ThreadLocal初始化在堆上还是栈上\"><a href=\"#ThreadLocal初始化在堆上还是栈上\" class=\"headerlink\" title=\"ThreadLocal初始化在堆上还是栈上\"></a>ThreadLocal初始化在堆上还是栈上</h2><h2 id=\"ThreadLocal会导致内存泄漏吗\"><a href=\"#ThreadLocal会导致内存泄漏吗\" class=\"headerlink\" title=\"ThreadLocal会导致内存泄漏吗?\"></a>ThreadLocal会导致内存泄漏吗?</h2><p>看到一篇博客讲不会发生内存泄漏，原因是Entry是一个弱引用，如果entry.get()=null，entry会被擦除</p>\n<pre><code>static class ThreadLocalMap {\n\n    /**\n     * The entries in this hash map extend WeakReference, using\n     * its main ref field as the key (which is always a\n     * ThreadLocal object).  Note that null keys (i.e. entry.get()\n     * == null) mean that the key is no longer referenced, so the\n     * entry can be expunged from table.  Such entries are referred to\n     * as &quot;stale entries&quot; in the code that follows.\n     */\n    static class Entry extends WeakReference&lt;ThreadLocal&gt; {\n        /** The value associated with this ThreadLocal. */\n        Object value;\n\n        Entry(ThreadLocal k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n</code></pre><p><a href=\"https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/\" title=\"技术小黑屋\" target=\"_blank\" rel=\"noopener\">技术小黑屋</a></p>\n<h2 id=\"ThreadLocal和InheritableThreadLocal的区别\"><a href=\"#ThreadLocal和InheritableThreadLocal的区别\" class=\"headerlink\" title=\"ThreadLocal和InheritableThreadLocal的区别\"></a>ThreadLocal和InheritableThreadLocal的区别</h2><p>InheritableThreadLocal会自动将值传递给子线程，也就是说在子线程可以看到父线程的值。</p>\n<p><strong>注意：</strong>为了保护线程安全，应该只对不可变的对象使用InheritableThreadLocal。但不能是有状态的对象，例如JDBC Connection</p>\n<p>ThreadLocal</p>\n<pre><code>static final ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal();\n\npublic static void main(String[] args){\n\n    threadLocal.set(123);\n    System.out.println(&quot;父线程获取threadLocal:&quot; + threadLocal.get());\n\n    Thread t = new Thread(){\n        @Override\n        public void run() {\n            super.run();\n            System.out.println(&quot;设值前：子线程获取threadLocal:&quot; + threadLocal.get());\n\n            threadLocal.set(234);\n            System.out.println(&quot;设值后：子线程获取threadLocal:&quot; + threadLocal.get());\n        }\n    };\n\n    t.start();\n\n}\n</code></pre><p>返回值</p>\n<pre><code>父线程获取threadLocal:123\n设值前：子线程获取threadLocal:null\n设值后：子线程获取threadLocal:234\n</code></pre><p>InheritableThreadLocal</p>\n<pre><code>static final ThreadLocal threadLocal = new InheritableThreadLocal();\n\npublic static void main(String[] args){\n\n    threadLocal.set(123);\n    System.out.println(&quot;父线程获取threadLocal:&quot; + threadLocal.get());\n\n    Thread t = new Thread(){\n        @Override\n        public void run() {\n            super.run();\n            System.out.println(&quot;设值前：子线程获取threadLocal:&quot; + threadLocal.get());\n\n            threadLocal.set(234);\n            System.out.println(&quot;设值后：子线程获取threadLocal:&quot; + threadLocal.get());\n        }\n    };\n\n    t.start();\n\n}\n</code></pre><p>返回值</p>\n<pre><code>父线程获取threadLocal:123\n设值前：子线程获取threadLocal:123\n设值后：子线程获取threadLocal:234\n</code></pre><h3 id=\"ThreadLocal的应用场景\"><a href=\"#ThreadLocal的应用场景\" class=\"headerlink\" title=\"ThreadLocal的应用场景\"></a>ThreadLocal的应用场景</h3><p>1.实现单个线程单例以及单个线程上下文信息存储，比如交易id等</p>\n<p>2.实现对象线程安全，例如：数据库连接</p>\n<p>3.承载一些线程相关的数据，避免在方法中来回传递参数。例如：Session管理</p>\n<h3 id=\"InheritableThreadLocal的应用场景\"><a href=\"#InheritableThreadLocal的应用场景\" class=\"headerlink\" title=\"InheritableThreadLocal的应用场景\"></a>InheritableThreadLocal的应用场景</h3><p>1、用户标识</p>\n<p>2、事务标识</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"ThreadLocal的底层实现\"><a href=\"#ThreadLocal的底层实现\" class=\"headerlink\" title=\"ThreadLocal的底层实现\"></a>ThreadLocal的底层实现</h2><h3 id=\"主要方法：\"><a href=\"#主要方法：\" class=\"headerlink\" title=\"主要方法：\"></a>主要方法：</h3><h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><pre><code>public void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n</code></pre>","more":"<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h4><pre><code>public T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null)\n            return (T)e.value;\n    }\n    return setInitialValue();\n}\n</code></pre><p>可以看到先获取当前线程t,然后根据t得到ThreadLocalMap对象，如果map为null则设置初始值。</p>\n<h4 id=\"getMap-t\"><a href=\"#getMap-t\" class=\"headerlink\" title=\"getMap(t)\"></a>getMap(t)</h4><pre><code>ThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n</code></pre><p>从getMap可以看到返回的是当前线程的threadLocals属性。</p>\n<h4 id=\"ThreadLocalMap类\"><a href=\"#ThreadLocalMap类\" class=\"headerlink\" title=\"ThreadLocalMap类\"></a>ThreadLocalMap类</h4><pre><code>static class ThreadLocalMap {\n\n    static class Entry extends WeakReference&lt;ThreadLocal&gt; {\n        /** The value associated with this ThreadLocal. */\n        Object value;\n\n        Entry(ThreadLocal k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n\n    private static final int INITIAL_CAPACITY = 16;\n\n    private Entry[] table;\n\n    ...\n\n    private Entry getEntry(ThreadLocal key) {\n        int i = key.threadLocalHashCode &amp; (table.length - 1);\n        Entry e = table[i];\n        if (e != null &amp;&amp; e.get() == key)\n            return e;\n        else\n            return getEntryAfterMiss(key, i, e);\n    }\n</code></pre><p>可以看到其实ThreadLocalMap就是HashMap的一个变形。</p>\n<h4 id=\"setInitialValue\"><a href=\"#setInitialValue\" class=\"headerlink\" title=\"setInitialValue\"></a>setInitialValue</h4><pre><code>private T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n\nprotected T initialValue() {\n    return null;\n}\n\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n</code></pre><p>可以看到初始化时，为当前线程t设置了一个key为当前ThreadLocal对象，value为null的threadLocals属性。</p>\n<h2 id=\"ThreadLocal初始化在堆上还是栈上\"><a href=\"#ThreadLocal初始化在堆上还是栈上\" class=\"headerlink\" title=\"ThreadLocal初始化在堆上还是栈上\"></a>ThreadLocal初始化在堆上还是栈上</h2><h2 id=\"ThreadLocal会导致内存泄漏吗\"><a href=\"#ThreadLocal会导致内存泄漏吗\" class=\"headerlink\" title=\"ThreadLocal会导致内存泄漏吗?\"></a>ThreadLocal会导致内存泄漏吗?</h2><p>看到一篇博客讲不会发生内存泄漏，原因是Entry是一个弱引用，如果entry.get()=null，entry会被擦除</p>\n<pre><code>static class ThreadLocalMap {\n\n    /**\n     * The entries in this hash map extend WeakReference, using\n     * its main ref field as the key (which is always a\n     * ThreadLocal object).  Note that null keys (i.e. entry.get()\n     * == null) mean that the key is no longer referenced, so the\n     * entry can be expunged from table.  Such entries are referred to\n     * as &quot;stale entries&quot; in the code that follows.\n     */\n    static class Entry extends WeakReference&lt;ThreadLocal&gt; {\n        /** The value associated with this ThreadLocal. */\n        Object value;\n\n        Entry(ThreadLocal k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n</code></pre><p><a href=\"https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/\" title=\"技术小黑屋\" target=\"_blank\" rel=\"noopener\">技术小黑屋</a></p>\n<h2 id=\"ThreadLocal和InheritableThreadLocal的区别\"><a href=\"#ThreadLocal和InheritableThreadLocal的区别\" class=\"headerlink\" title=\"ThreadLocal和InheritableThreadLocal的区别\"></a>ThreadLocal和InheritableThreadLocal的区别</h2><p>InheritableThreadLocal会自动将值传递给子线程，也就是说在子线程可以看到父线程的值。</p>\n<p><strong>注意：</strong>为了保护线程安全，应该只对不可变的对象使用InheritableThreadLocal。但不能是有状态的对象，例如JDBC Connection</p>\n<p>ThreadLocal</p>\n<pre><code>static final ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal();\n\npublic static void main(String[] args){\n\n    threadLocal.set(123);\n    System.out.println(&quot;父线程获取threadLocal:&quot; + threadLocal.get());\n\n    Thread t = new Thread(){\n        @Override\n        public void run() {\n            super.run();\n            System.out.println(&quot;设值前：子线程获取threadLocal:&quot; + threadLocal.get());\n\n            threadLocal.set(234);\n            System.out.println(&quot;设值后：子线程获取threadLocal:&quot; + threadLocal.get());\n        }\n    };\n\n    t.start();\n\n}\n</code></pre><p>返回值</p>\n<pre><code>父线程获取threadLocal:123\n设值前：子线程获取threadLocal:null\n设值后：子线程获取threadLocal:234\n</code></pre><p>InheritableThreadLocal</p>\n<pre><code>static final ThreadLocal threadLocal = new InheritableThreadLocal();\n\npublic static void main(String[] args){\n\n    threadLocal.set(123);\n    System.out.println(&quot;父线程获取threadLocal:&quot; + threadLocal.get());\n\n    Thread t = new Thread(){\n        @Override\n        public void run() {\n            super.run();\n            System.out.println(&quot;设值前：子线程获取threadLocal:&quot; + threadLocal.get());\n\n            threadLocal.set(234);\n            System.out.println(&quot;设值后：子线程获取threadLocal:&quot; + threadLocal.get());\n        }\n    };\n\n    t.start();\n\n}\n</code></pre><p>返回值</p>\n<pre><code>父线程获取threadLocal:123\n设值前：子线程获取threadLocal:123\n设值后：子线程获取threadLocal:234\n</code></pre><h3 id=\"ThreadLocal的应用场景\"><a href=\"#ThreadLocal的应用场景\" class=\"headerlink\" title=\"ThreadLocal的应用场景\"></a>ThreadLocal的应用场景</h3><p>1.实现单个线程单例以及单个线程上下文信息存储，比如交易id等</p>\n<p>2.实现对象线程安全，例如：数据库连接</p>\n<p>3.承载一些线程相关的数据，避免在方法中来回传递参数。例如：Session管理</p>\n<h3 id=\"InheritableThreadLocal的应用场景\"><a href=\"#InheritableThreadLocal的应用场景\" class=\"headerlink\" title=\"InheritableThreadLocal的应用场景\"></a>InheritableThreadLocal的应用场景</h3><p>1、用户标识</p>\n<p>2、事务标识</p>"},{"title":"树莓派系统搭建踩坑","date":"2018-04-26T10:43:00.000Z","_content":"\n### 一、安装树莓派系统\n1、SDFormatter格式化优盘\n\n2、win32Disk写入镜像\n\n3、pi用户登录系统，pi/raspberry\n\n<!-- more -->\n\n### 二、修改键盘布局(因为树莓派默认英国键盘布局，会导致出错\n\tsudo raspi-config\n\n> 1. Locals Options\n\n> 2. Choose Keyword Layout\n\n> 3. Generic 104-key PC #键盘101布局和104布局\n\n> 4. English(US, alternative international)\n\n\t\n重启系统\n\n    reboot\n\n### 三、设置远程登录，使用xshell操作\n\n开启22号端口\n\tsudo raspi-config\n\n> 1、Advanced Options\n\n> 2、SSH Enable\n\n树莓派默认pi用户，开启root用户\n\tsudo passwd root\n\n\tsudo passwd --unlock root\n\n\tsu root\n\n设置允许root用户远程登录系统\n\n\tvi /etc/ssh/sshd_config\n\n> PermitRootLogin yes\n\n\treboot\n\n### 四、配置WiFi\n\n\tsu root\n\tvi /etc/wpa_supplicant/wpa_supplicant.conf\n\n> network={\n> \n> \tssid=\"wifi名称\"\n> \n> \tpsk=\"wifi密码\"\n> }\n\n重启查看网络\n\n\treboot\n\tifconfig wlan0\n\n### 五、卸载系统自带vim，安装vim(自带vim上下左右键盘为ABCD)\n\n\tapt-get remove vim-common\n\tapt-get install vim\n\n### 六、修改镜像源\nvi /etc/apt/sources.list\n\ndeb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi \ndeb-src http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi \n\n\tvi /etc/apt/sources.list.d/raspi.list\n\n更新源\n\n\tsudo apt-get update\n\tsudo apt-get upgrade -y","source":"_posts/raspberry-base.md","raw":"---\ntitle: 树莓派系统搭建踩坑\ndate: 2018-04-26 18:43:00\ncategories: raspberry\ntags: 树莓派\n---\n\n### 一、安装树莓派系统\n1、SDFormatter格式化优盘\n\n2、win32Disk写入镜像\n\n3、pi用户登录系统，pi/raspberry\n\n<!-- more -->\n\n### 二、修改键盘布局(因为树莓派默认英国键盘布局，会导致出错\n\tsudo raspi-config\n\n> 1. Locals Options\n\n> 2. Choose Keyword Layout\n\n> 3. Generic 104-key PC #键盘101布局和104布局\n\n> 4. English(US, alternative international)\n\n\t\n重启系统\n\n    reboot\n\n### 三、设置远程登录，使用xshell操作\n\n开启22号端口\n\tsudo raspi-config\n\n> 1、Advanced Options\n\n> 2、SSH Enable\n\n树莓派默认pi用户，开启root用户\n\tsudo passwd root\n\n\tsudo passwd --unlock root\n\n\tsu root\n\n设置允许root用户远程登录系统\n\n\tvi /etc/ssh/sshd_config\n\n> PermitRootLogin yes\n\n\treboot\n\n### 四、配置WiFi\n\n\tsu root\n\tvi /etc/wpa_supplicant/wpa_supplicant.conf\n\n> network={\n> \n> \tssid=\"wifi名称\"\n> \n> \tpsk=\"wifi密码\"\n> }\n\n重启查看网络\n\n\treboot\n\tifconfig wlan0\n\n### 五、卸载系统自带vim，安装vim(自带vim上下左右键盘为ABCD)\n\n\tapt-get remove vim-common\n\tapt-get install vim\n\n### 六、修改镜像源\nvi /etc/apt/sources.list\n\ndeb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi \ndeb-src http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi \n\n\tvi /etc/apt/sources.list.d/raspi.list\n\n更新源\n\n\tsudo apt-get update\n\tsudo apt-get upgrade -y","slug":"raspberry-base","published":1,"updated":"2018-07-29T02:07:37.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde23001uv0f0tj0xq2cz","content":"<h3 id=\"一、安装树莓派系统\"><a href=\"#一、安装树莓派系统\" class=\"headerlink\" title=\"一、安装树莓派系统\"></a>一、安装树莓派系统</h3><p>1、SDFormatter格式化优盘</p>\n<p>2、win32Disk写入镜像</p>\n<p>3、pi用户登录系统，pi/raspberry</p>\n<a id=\"more\"></a>\n<h3 id=\"二、修改键盘布局-因为树莓派默认英国键盘布局，会导致出错\"><a href=\"#二、修改键盘布局-因为树莓派默认英国键盘布局，会导致出错\" class=\"headerlink\" title=\"二、修改键盘布局(因为树莓派默认英国键盘布局，会导致出错\"></a>二、修改键盘布局(因为树莓派默认英国键盘布局，会导致出错</h3><pre><code>sudo raspi-config\n</code></pre><blockquote>\n<ol>\n<li>Locals Options</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol>\n<li>Choose Keyword Layout</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol>\n<li>Generic 104-key PC #键盘101布局和104布局</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol>\n<li>English(US, alternative international)</li>\n</ol>\n</blockquote>\n<p>重启系统</p>\n<pre><code>reboot\n</code></pre><h3 id=\"三、设置远程登录，使用xshell操作\"><a href=\"#三、设置远程登录，使用xshell操作\" class=\"headerlink\" title=\"三、设置远程登录，使用xshell操作\"></a>三、设置远程登录，使用xshell操作</h3><p>开启22号端口<br>    sudo raspi-config</p>\n<blockquote>\n<p>1、Advanced Options</p>\n</blockquote>\n<blockquote>\n<p>2、SSH Enable</p>\n</blockquote>\n<p>树莓派默认pi用户，开启root用户<br>    sudo passwd root</p>\n<pre><code>sudo passwd --unlock root\n\nsu root\n</code></pre><p>设置允许root用户远程登录系统</p>\n<pre><code>vi /etc/ssh/sshd_config\n</code></pre><blockquote>\n<p>PermitRootLogin yes</p>\n</blockquote>\n<pre><code>reboot\n</code></pre><h3 id=\"四、配置WiFi\"><a href=\"#四、配置WiFi\" class=\"headerlink\" title=\"四、配置WiFi\"></a>四、配置WiFi</h3><pre><code>su root\nvi /etc/wpa_supplicant/wpa_supplicant.conf\n</code></pre><blockquote>\n<p>network={</p>\n<pre><code>ssid=&quot;wifi名称&quot;\n\npsk=&quot;wifi密码&quot;\n</code></pre><p>}</p>\n</blockquote>\n<p>重启查看网络</p>\n<pre><code>reboot\nifconfig wlan0\n</code></pre><h3 id=\"五、卸载系统自带vim，安装vim-自带vim上下左右键盘为ABCD\"><a href=\"#五、卸载系统自带vim，安装vim-自带vim上下左右键盘为ABCD\" class=\"headerlink\" title=\"五、卸载系统自带vim，安装vim(自带vim上下左右键盘为ABCD)\"></a>五、卸载系统自带vim，安装vim(自带vim上下左右键盘为ABCD)</h3><pre><code>apt-get remove vim-common\napt-get install vim\n</code></pre><h3 id=\"六、修改镜像源\"><a href=\"#六、修改镜像源\" class=\"headerlink\" title=\"六、修改镜像源\"></a>六、修改镜像源</h3><p>vi /etc/apt/sources.list</p>\n<p>deb <a href=\"http://mirrors.aliyun.com/raspbian/raspbian/\" target=\"_blank\" rel=\"noopener\">http://mirrors.aliyun.com/raspbian/raspbian/</a> stretch main contrib non-free rpi<br>deb-src <a href=\"http://mirrors.aliyun.com/raspbian/raspbian/\" target=\"_blank\" rel=\"noopener\">http://mirrors.aliyun.com/raspbian/raspbian/</a> stretch main contrib non-free rpi </p>\n<pre><code>vi /etc/apt/sources.list.d/raspi.list\n</code></pre><p>更新源</p>\n<pre><code>sudo apt-get update\nsudo apt-get upgrade -y\n</code></pre>","site":{"data":{}},"excerpt":"<h3 id=\"一、安装树莓派系统\"><a href=\"#一、安装树莓派系统\" class=\"headerlink\" title=\"一、安装树莓派系统\"></a>一、安装树莓派系统</h3><p>1、SDFormatter格式化优盘</p>\n<p>2、win32Disk写入镜像</p>\n<p>3、pi用户登录系统，pi/raspberry</p>","more":"<h3 id=\"二、修改键盘布局-因为树莓派默认英国键盘布局，会导致出错\"><a href=\"#二、修改键盘布局-因为树莓派默认英国键盘布局，会导致出错\" class=\"headerlink\" title=\"二、修改键盘布局(因为树莓派默认英国键盘布局，会导致出错\"></a>二、修改键盘布局(因为树莓派默认英国键盘布局，会导致出错</h3><pre><code>sudo raspi-config\n</code></pre><blockquote>\n<ol>\n<li>Locals Options</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol>\n<li>Choose Keyword Layout</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol>\n<li>Generic 104-key PC #键盘101布局和104布局</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol>\n<li>English(US, alternative international)</li>\n</ol>\n</blockquote>\n<p>重启系统</p>\n<pre><code>reboot\n</code></pre><h3 id=\"三、设置远程登录，使用xshell操作\"><a href=\"#三、设置远程登录，使用xshell操作\" class=\"headerlink\" title=\"三、设置远程登录，使用xshell操作\"></a>三、设置远程登录，使用xshell操作</h3><p>开启22号端口<br>    sudo raspi-config</p>\n<blockquote>\n<p>1、Advanced Options</p>\n</blockquote>\n<blockquote>\n<p>2、SSH Enable</p>\n</blockquote>\n<p>树莓派默认pi用户，开启root用户<br>    sudo passwd root</p>\n<pre><code>sudo passwd --unlock root\n\nsu root\n</code></pre><p>设置允许root用户远程登录系统</p>\n<pre><code>vi /etc/ssh/sshd_config\n</code></pre><blockquote>\n<p>PermitRootLogin yes</p>\n</blockquote>\n<pre><code>reboot\n</code></pre><h3 id=\"四、配置WiFi\"><a href=\"#四、配置WiFi\" class=\"headerlink\" title=\"四、配置WiFi\"></a>四、配置WiFi</h3><pre><code>su root\nvi /etc/wpa_supplicant/wpa_supplicant.conf\n</code></pre><blockquote>\n<p>network={</p>\n<pre><code>ssid=&quot;wifi名称&quot;\n\npsk=&quot;wifi密码&quot;\n</code></pre><p>}</p>\n</blockquote>\n<p>重启查看网络</p>\n<pre><code>reboot\nifconfig wlan0\n</code></pre><h3 id=\"五、卸载系统自带vim，安装vim-自带vim上下左右键盘为ABCD\"><a href=\"#五、卸载系统自带vim，安装vim-自带vim上下左右键盘为ABCD\" class=\"headerlink\" title=\"五、卸载系统自带vim，安装vim(自带vim上下左右键盘为ABCD)\"></a>五、卸载系统自带vim，安装vim(自带vim上下左右键盘为ABCD)</h3><pre><code>apt-get remove vim-common\napt-get install vim\n</code></pre><h3 id=\"六、修改镜像源\"><a href=\"#六、修改镜像源\" class=\"headerlink\" title=\"六、修改镜像源\"></a>六、修改镜像源</h3><p>vi /etc/apt/sources.list</p>\n<p>deb <a href=\"http://mirrors.aliyun.com/raspbian/raspbian/\" target=\"_blank\" rel=\"noopener\">http://mirrors.aliyun.com/raspbian/raspbian/</a> stretch main contrib non-free rpi<br>deb-src <a href=\"http://mirrors.aliyun.com/raspbian/raspbian/\" target=\"_blank\" rel=\"noopener\">http://mirrors.aliyun.com/raspbian/raspbian/</a> stretch main contrib non-free rpi </p>\n<pre><code>vi /etc/apt/sources.list.d/raspi.list\n</code></pre><p>更新源</p>\n<pre><code>sudo apt-get update\nsudo apt-get upgrade -y\n</code></pre>"},{"title":"树莓派实现简单的人脸识别","date":"2018-07-25T09:20:30.000Z","_content":"**硬件需求：**\n\n>树莓派开发板\n>\n>pi摄像头\n>\n>16g内存卡\n>\n>读卡器\n\n\n<!-- more -->\n\n## 1、更新镜像源\n\n\tapt-get update\n\t\n\tapt-get upgrade\n\t\n\tapt-get install python-opencv\n\n## 2、针对PiCamera安装包\n\n\tapt-get install python-pip\n\t\n\tapt-get install python-dev\n\t\n\tpip install picamera\n\n\n**pip报错(1)**\n\nTypeError: unsupported operand type(s) for -=: 'Retry' and 'int'\n\n解决方案：pip内部bug,升级pip版本\n\n**pip报错(2)**\n\nfrom pip import main ImportError: cannot import name main\n\n解决方案：pip版本冲突，pip -V; cd /usr/bin; cat pip; mv pip9.0; pip2 -V\n\n**下载open-cv报错**\n\nUnable to establish SSL connection\n\n解决方案：手动下载\n\nhttps://github.com/opencv/opencv/archive/3.4.0.tar.gz\n\nhttps://codeload.github.com/opencv/opencv_contrib/zip/master\n\n\n### 安装视频I/O包\n\tsudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev \n\t\n\tsudo apt-get install libgtk2.0-dev\n\n### 优化函数包：\n`\nsudo apt-get install libatlas-base-dev gfortran\n`\n\n**报错,安装依赖包**\n\n\tapt-get install libgstreamer-plugins-base1.0-dev\n\t\n\tapt-get install libgphoto2-dev\n\t\n\tapt-get install libavresample-dev\n\t\n\tapt-get install libdc1394-22-dev\n\t\n\tapt-get install libgtk-3-dev\n\n\n**如果中间缺少以下依赖包，则进行安装**\napt-get install gtk+-3.0 gtk+-2.0 gthread-2.0 gstreamer-base-1.0\n\napt-get install libavresample libgphoto2\n\n## 3、编译open-cv\n\n`\nsudo cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local  -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.3.1/modules ..\n    -D INSTALL_PYTHON_EXAMPLES=ON \\\n    -D BUILD_EXAMPLES=ON ..\n`\n\n\n## 4、编写pytho脚本，并执行\n\n    python TestOpencv.py \n\n**报错**\n\nFound 0 face(s)\n\nUnable to init server: Could not connect: Connection refused\n\n(Frame:15788): Gtk-WARNING **: cannot open display: \n\n解决：原因是raspberry系统stetch最小化安装，没有图形界面\n\n\tsudo apt-get install xorg\n\n\tsudo apt-get install lxde openbox\n\n\tsudo startx  #不要通过ssh执行\n\n\tsudo apt-get install raspberrypi-ui-mods\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/raspberry-facerecognition.md","raw":"---\ntitle: 树莓派实现简单的人脸识别\ndate: 2018-07-25 17:20:30\ntags: raspberry, python, 人脸识别\ncategories: Python\n---\n**硬件需求：**\n\n>树莓派开发板\n>\n>pi摄像头\n>\n>16g内存卡\n>\n>读卡器\n\n\n<!-- more -->\n\n## 1、更新镜像源\n\n\tapt-get update\n\t\n\tapt-get upgrade\n\t\n\tapt-get install python-opencv\n\n## 2、针对PiCamera安装包\n\n\tapt-get install python-pip\n\t\n\tapt-get install python-dev\n\t\n\tpip install picamera\n\n\n**pip报错(1)**\n\nTypeError: unsupported operand type(s) for -=: 'Retry' and 'int'\n\n解决方案：pip内部bug,升级pip版本\n\n**pip报错(2)**\n\nfrom pip import main ImportError: cannot import name main\n\n解决方案：pip版本冲突，pip -V; cd /usr/bin; cat pip; mv pip9.0; pip2 -V\n\n**下载open-cv报错**\n\nUnable to establish SSL connection\n\n解决方案：手动下载\n\nhttps://github.com/opencv/opencv/archive/3.4.0.tar.gz\n\nhttps://codeload.github.com/opencv/opencv_contrib/zip/master\n\n\n### 安装视频I/O包\n\tsudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev \n\t\n\tsudo apt-get install libgtk2.0-dev\n\n### 优化函数包：\n`\nsudo apt-get install libatlas-base-dev gfortran\n`\n\n**报错,安装依赖包**\n\n\tapt-get install libgstreamer-plugins-base1.0-dev\n\t\n\tapt-get install libgphoto2-dev\n\t\n\tapt-get install libavresample-dev\n\t\n\tapt-get install libdc1394-22-dev\n\t\n\tapt-get install libgtk-3-dev\n\n\n**如果中间缺少以下依赖包，则进行安装**\napt-get install gtk+-3.0 gtk+-2.0 gthread-2.0 gstreamer-base-1.0\n\napt-get install libavresample libgphoto2\n\n## 3、编译open-cv\n\n`\nsudo cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local  -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.3.1/modules ..\n    -D INSTALL_PYTHON_EXAMPLES=ON \\\n    -D BUILD_EXAMPLES=ON ..\n`\n\n\n## 4、编写pytho脚本，并执行\n\n    python TestOpencv.py \n\n**报错**\n\nFound 0 face(s)\n\nUnable to init server: Could not connect: Connection refused\n\n(Frame:15788): Gtk-WARNING **: cannot open display: \n\n解决：原因是raspberry系统stetch最小化安装，没有图形界面\n\n\tsudo apt-get install xorg\n\n\tsudo apt-get install lxde openbox\n\n\tsudo startx  #不要通过ssh执行\n\n\tsudo apt-get install raspberrypi-ui-mods\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"raspberry-facerecognition","published":1,"updated":"2018-07-25T09:53:32.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde26001wv0f03f6ybh9v","content":"<p><strong>硬件需求：</strong></p>\n<blockquote>\n<p>树莓派开发板</p>\n<p>pi摄像头</p>\n<p>16g内存卡</p>\n<p>读卡器</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"1、更新镜像源\"><a href=\"#1、更新镜像源\" class=\"headerlink\" title=\"1、更新镜像源\"></a>1、更新镜像源</h2><pre><code>apt-get update\n\napt-get upgrade\n\napt-get install python-opencv\n</code></pre><h2 id=\"2、针对PiCamera安装包\"><a href=\"#2、针对PiCamera安装包\" class=\"headerlink\" title=\"2、针对PiCamera安装包\"></a>2、针对PiCamera安装包</h2><pre><code>apt-get install python-pip\n\napt-get install python-dev\n\npip install picamera\n</code></pre><p><strong>pip报错(1)</strong></p>\n<p>TypeError: unsupported operand type(s) for -=: ‘Retry’ and ‘int’</p>\n<p>解决方案：pip内部bug,升级pip版本</p>\n<p><strong>pip报错(2)</strong></p>\n<p>from pip import main ImportError: cannot import name main</p>\n<p>解决方案：pip版本冲突，pip -V; cd /usr/bin; cat pip; mv pip9.0; pip2 -V</p>\n<p><strong>下载open-cv报错</strong></p>\n<p>Unable to establish SSL connection</p>\n<p>解决方案：手动下载</p>\n<p><a href=\"https://github.com/opencv/opencv/archive/3.4.0.tar.gz\" target=\"_blank\" rel=\"noopener\">https://github.com/opencv/opencv/archive/3.4.0.tar.gz</a></p>\n<p><a href=\"https://codeload.github.com/opencv/opencv_contrib/zip/master\" target=\"_blank\" rel=\"noopener\">https://codeload.github.com/opencv/opencv_contrib/zip/master</a></p>\n<h3 id=\"安装视频I-O包\"><a href=\"#安装视频I-O包\" class=\"headerlink\" title=\"安装视频I/O包\"></a>安装视频I/O包</h3><pre><code>sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev \n\nsudo apt-get install libgtk2.0-dev\n</code></pre><h3 id=\"优化函数包：\"><a href=\"#优化函数包：\" class=\"headerlink\" title=\"优化函数包：\"></a>优化函数包：</h3><p><code>sudo apt-get install libatlas-base-dev gfortran</code></p>\n<p><strong>报错,安装依赖包</strong></p>\n<pre><code>apt-get install libgstreamer-plugins-base1.0-dev\n\napt-get install libgphoto2-dev\n\napt-get install libavresample-dev\n\napt-get install libdc1394-22-dev\n\napt-get install libgtk-3-dev\n</code></pre><p><strong>如果中间缺少以下依赖包，则进行安装</strong><br>apt-get install gtk+-3.0 gtk+-2.0 gthread-2.0 gstreamer-base-1.0</p>\n<p>apt-get install libavresample libgphoto2</p>\n<h2 id=\"3、编译open-cv\"><a href=\"#3、编译open-cv\" class=\"headerlink\" title=\"3、编译open-cv\"></a>3、编译open-cv</h2><p><code>sudo cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local  -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.3.1/modules ..\n    -D INSTALL_PYTHON_EXAMPLES=ON \\\n    -D BUILD_EXAMPLES=ON ..</code></p>\n<h2 id=\"4、编写pytho脚本，并执行\"><a href=\"#4、编写pytho脚本，并执行\" class=\"headerlink\" title=\"4、编写pytho脚本，并执行\"></a>4、编写pytho脚本，并执行</h2><pre><code>python TestOpencv.py \n</code></pre><p><strong>报错</strong></p>\n<p>Found 0 face(s)</p>\n<p>Unable to init server: Could not connect: Connection refused</p>\n<p>(Frame:15788): Gtk-WARNING **: cannot open display: </p>\n<p>解决：原因是raspberry系统stetch最小化安装，没有图形界面</p>\n<pre><code>sudo apt-get install xorg\n\nsudo apt-get install lxde openbox\n\nsudo startx  #不要通过ssh执行\n\nsudo apt-get install raspberrypi-ui-mods\n</code></pre>","site":{"data":{}},"excerpt":"<p><strong>硬件需求：</strong></p>\n<blockquote>\n<p>树莓派开发板</p>\n<p>pi摄像头</p>\n<p>16g内存卡</p>\n<p>读卡器</p>\n</blockquote>","more":"<h2 id=\"1、更新镜像源\"><a href=\"#1、更新镜像源\" class=\"headerlink\" title=\"1、更新镜像源\"></a>1、更新镜像源</h2><pre><code>apt-get update\n\napt-get upgrade\n\napt-get install python-opencv\n</code></pre><h2 id=\"2、针对PiCamera安装包\"><a href=\"#2、针对PiCamera安装包\" class=\"headerlink\" title=\"2、针对PiCamera安装包\"></a>2、针对PiCamera安装包</h2><pre><code>apt-get install python-pip\n\napt-get install python-dev\n\npip install picamera\n</code></pre><p><strong>pip报错(1)</strong></p>\n<p>TypeError: unsupported operand type(s) for -=: ‘Retry’ and ‘int’</p>\n<p>解决方案：pip内部bug,升级pip版本</p>\n<p><strong>pip报错(2)</strong></p>\n<p>from pip import main ImportError: cannot import name main</p>\n<p>解决方案：pip版本冲突，pip -V; cd /usr/bin; cat pip; mv pip9.0; pip2 -V</p>\n<p><strong>下载open-cv报错</strong></p>\n<p>Unable to establish SSL connection</p>\n<p>解决方案：手动下载</p>\n<p><a href=\"https://github.com/opencv/opencv/archive/3.4.0.tar.gz\" target=\"_blank\" rel=\"noopener\">https://github.com/opencv/opencv/archive/3.4.0.tar.gz</a></p>\n<p><a href=\"https://codeload.github.com/opencv/opencv_contrib/zip/master\" target=\"_blank\" rel=\"noopener\">https://codeload.github.com/opencv/opencv_contrib/zip/master</a></p>\n<h3 id=\"安装视频I-O包\"><a href=\"#安装视频I-O包\" class=\"headerlink\" title=\"安装视频I/O包\"></a>安装视频I/O包</h3><pre><code>sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev \n\nsudo apt-get install libgtk2.0-dev\n</code></pre><h3 id=\"优化函数包：\"><a href=\"#优化函数包：\" class=\"headerlink\" title=\"优化函数包：\"></a>优化函数包：</h3><p><code>sudo apt-get install libatlas-base-dev gfortran</code></p>\n<p><strong>报错,安装依赖包</strong></p>\n<pre><code>apt-get install libgstreamer-plugins-base1.0-dev\n\napt-get install libgphoto2-dev\n\napt-get install libavresample-dev\n\napt-get install libdc1394-22-dev\n\napt-get install libgtk-3-dev\n</code></pre><p><strong>如果中间缺少以下依赖包，则进行安装</strong><br>apt-get install gtk+-3.0 gtk+-2.0 gthread-2.0 gstreamer-base-1.0</p>\n<p>apt-get install libavresample libgphoto2</p>\n<h2 id=\"3、编译open-cv\"><a href=\"#3、编译open-cv\" class=\"headerlink\" title=\"3、编译open-cv\"></a>3、编译open-cv</h2><p><code>sudo cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local  -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.3.1/modules ..\n    -D INSTALL_PYTHON_EXAMPLES=ON \\\n    -D BUILD_EXAMPLES=ON ..</code></p>\n<h2 id=\"4、编写pytho脚本，并执行\"><a href=\"#4、编写pytho脚本，并执行\" class=\"headerlink\" title=\"4、编写pytho脚本，并执行\"></a>4、编写pytho脚本，并执行</h2><pre><code>python TestOpencv.py \n</code></pre><p><strong>报错</strong></p>\n<p>Found 0 face(s)</p>\n<p>Unable to init server: Could not connect: Connection refused</p>\n<p>(Frame:15788): Gtk-WARNING **: cannot open display: </p>\n<p>解决：原因是raspberry系统stetch最小化安装，没有图形界面</p>\n<pre><code>sudo apt-get install xorg\n\nsudo apt-get install lxde openbox\n\nsudo startx  #不要通过ssh执行\n\nsudo apt-get install raspberrypi-ui-mods\n</code></pre>"},{"title":"树莓派实现简易的语音识别","date":"2018-04-26T11:45:06.000Z","_content":"###","source":"_posts/raspberry-snowboy.md","raw":"---\ntitle: 树莓派实现简易的语音识别\ndate: 2018-04-26 19:45:06\ntags: 树莓派\n---\n###","slug":"raspberry-snowboy","published":1,"updated":"2018-04-26T11:45:57.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde29001zv0f00chj5hxw","content":"<p>###</p>\n","site":{"data":{}},"excerpt":"","more":"<p>###</p>\n"},{"title":"mysql主从复制","date":"2018-08-08T14:17:15.000Z","_content":"## 主要解决的问题： ##\n\n数据分布\n\n负载均衡\n\n备份\n\n高可用性和故障切换\n\n升级测试\n\n<!-- more -->\n\n## 工作原理 ##\n\n1、主库把数据更新记录到二进制日志\n\n2、备库将主库的日志复制到自己的中继日志\n\n> 备库启动I/O线程，和主库建立一个客户端连接\n> \n> 主库启动特殊的转储线程，读取主库上二进制日志中的事件\n> \n> 备库I/O线程将接收到的事件记录到中继日志\n\n3、备库读取中继日志的事件，写入数据\n\n备库sql线程从中继日志读取事件、执行事件\n\n### 基于语句的复制 ###\n\n主库会记录所有数据更新的sql，当备库读取重放这些事件时，实际上是把所有执行过的sql语句执行一遍。\n\n优点：\n\n缺点：\n\n### 基于行的复制 ###\n\n将实际的数据记录在二进制日志中。\n\n优点：\n\n缺点：\n\n## 环境搭建 ##\n\n### 主库 ###\n\n1、修改配置文件\n\n\tvi /etc/my.cnf\n\n配置参数\n\n\tlog_bin=mysql-bin  \n\tserver-id=1 \n\treplay_log=/var/lib/mysql/mysql-replay-bin\n\tlog_slave_updates=1\n\tread_only=1\n\tinnodb_flush_log_at_trx_commit=1 \n\tsync_binlog=1\n\n启动MySQL\n\t\n\tsystemctl restart mysqld;\n\n**注意：** log_bin一定要开启，也可以是'log-bin',如果不开启可能会报错：\n\nERROR 2006 (HY000): MySQL server has gone away\nNo connection. Trying to reconnect...\nConnection id:    3\nCurrent database: *** NONE ***\n\nEmpty set (0.00 sec)\n\n#### 参数解释 ####\n\n2、创建一个供局域网内连接的用户(有的提到要加锁)\n\n\tgrant replication slave on *.* to 'admin'@'192.168.117.%' identified by 'xxxxxx';\n\n\tflush privileges;\n\n**注意：** on后面是'*.*',否则可能会报错：\n\nERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'to 'admin-m'@'192.168.117.%' identified by 'admin234'' at line 1\n\n3、查看主库\n\n\tmysql -uroot -p\n\tshow master status \\G;\n\t\n### 从库 ###\n\n1、修改配置(有的提到修改/var/lib/mysql/auto.cnf文件)\n\n\tvi /etc/my.cnf\n\n配置参数：\n\n\tserver_id=22\n\trelay_log=relay-log-bin\n\tskip_slave_start\n\tread_only\n\trelay_log_index=slave-relay-bin.index\n\n2、连接到主库\n\n\tchange master to master_host='192.168.117.135',master_port=3306,master_user='admin',master_password='xxxxx',master_log_file='mysql-bin.000003',master_log_pos=154;\n\n参数解释：\n\n3、启动从库，查看是否启动成功\n\n\tstart slave;\n\n\tshow slave status \\G;\n\n\n如果Slave_IO_Running: YES Slave_SQL_Running: Yes,则表明启动成功。\n\n参数Last_IO_Errno: 1236 Last_IO_Error显示失败的原因。\n\n错误1:中间重启从库mysql,启动后直接start slave;\n\n报错：ERROR 1872 (HY000): Slave failed to initialize relay log info structure from the repository\n\n解决：\n\n\treset slave;\n\n\tchange master .....;\n\n\tstart slave;\n\n启动成功；\n\n","source":"_posts/mysql-master-slave.md","raw":"---\ntitle: mysql主从复制\ndate: 2018-08-08 22:17:15\ntags: mysql,\ncategories: mysql\n---\n## 主要解决的问题： ##\n\n数据分布\n\n负载均衡\n\n备份\n\n高可用性和故障切换\n\n升级测试\n\n<!-- more -->\n\n## 工作原理 ##\n\n1、主库把数据更新记录到二进制日志\n\n2、备库将主库的日志复制到自己的中继日志\n\n> 备库启动I/O线程，和主库建立一个客户端连接\n> \n> 主库启动特殊的转储线程，读取主库上二进制日志中的事件\n> \n> 备库I/O线程将接收到的事件记录到中继日志\n\n3、备库读取中继日志的事件，写入数据\n\n备库sql线程从中继日志读取事件、执行事件\n\n### 基于语句的复制 ###\n\n主库会记录所有数据更新的sql，当备库读取重放这些事件时，实际上是把所有执行过的sql语句执行一遍。\n\n优点：\n\n缺点：\n\n### 基于行的复制 ###\n\n将实际的数据记录在二进制日志中。\n\n优点：\n\n缺点：\n\n## 环境搭建 ##\n\n### 主库 ###\n\n1、修改配置文件\n\n\tvi /etc/my.cnf\n\n配置参数\n\n\tlog_bin=mysql-bin  \n\tserver-id=1 \n\treplay_log=/var/lib/mysql/mysql-replay-bin\n\tlog_slave_updates=1\n\tread_only=1\n\tinnodb_flush_log_at_trx_commit=1 \n\tsync_binlog=1\n\n启动MySQL\n\t\n\tsystemctl restart mysqld;\n\n**注意：** log_bin一定要开启，也可以是'log-bin',如果不开启可能会报错：\n\nERROR 2006 (HY000): MySQL server has gone away\nNo connection. Trying to reconnect...\nConnection id:    3\nCurrent database: *** NONE ***\n\nEmpty set (0.00 sec)\n\n#### 参数解释 ####\n\n2、创建一个供局域网内连接的用户(有的提到要加锁)\n\n\tgrant replication slave on *.* to 'admin'@'192.168.117.%' identified by 'xxxxxx';\n\n\tflush privileges;\n\n**注意：** on后面是'*.*',否则可能会报错：\n\nERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'to 'admin-m'@'192.168.117.%' identified by 'admin234'' at line 1\n\n3、查看主库\n\n\tmysql -uroot -p\n\tshow master status \\G;\n\t\n### 从库 ###\n\n1、修改配置(有的提到修改/var/lib/mysql/auto.cnf文件)\n\n\tvi /etc/my.cnf\n\n配置参数：\n\n\tserver_id=22\n\trelay_log=relay-log-bin\n\tskip_slave_start\n\tread_only\n\trelay_log_index=slave-relay-bin.index\n\n2、连接到主库\n\n\tchange master to master_host='192.168.117.135',master_port=3306,master_user='admin',master_password='xxxxx',master_log_file='mysql-bin.000003',master_log_pos=154;\n\n参数解释：\n\n3、启动从库，查看是否启动成功\n\n\tstart slave;\n\n\tshow slave status \\G;\n\n\n如果Slave_IO_Running: YES Slave_SQL_Running: Yes,则表明启动成功。\n\n参数Last_IO_Errno: 1236 Last_IO_Error显示失败的原因。\n\n错误1:中间重启从库mysql,启动后直接start slave;\n\n报错：ERROR 1872 (HY000): Slave failed to initialize relay log info structure from the repository\n\n解决：\n\n\treset slave;\n\n\tchange master .....;\n\n\tstart slave;\n\n启动成功；\n\n","slug":"mysql-master-slave","published":1,"updated":"2018-08-09T06:14:08.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde2d0022v0f0ln924jaz","content":"<h2 id=\"主要解决的问题：\"><a href=\"#主要解决的问题：\" class=\"headerlink\" title=\"主要解决的问题：\"></a>主要解决的问题：</h2><p>数据分布</p>\n<p>负载均衡</p>\n<p>备份</p>\n<p>高可用性和故障切换</p>\n<p>升级测试</p>\n<a id=\"more\"></a>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p>1、主库把数据更新记录到二进制日志</p>\n<p>2、备库将主库的日志复制到自己的中继日志</p>\n<blockquote>\n<p>备库启动I/O线程，和主库建立一个客户端连接</p>\n<p>主库启动特殊的转储线程，读取主库上二进制日志中的事件</p>\n<p>备库I/O线程将接收到的事件记录到中继日志</p>\n</blockquote>\n<p>3、备库读取中继日志的事件，写入数据</p>\n<p>备库sql线程从中继日志读取事件、执行事件</p>\n<h3 id=\"基于语句的复制\"><a href=\"#基于语句的复制\" class=\"headerlink\" title=\"基于语句的复制\"></a>基于语句的复制</h3><p>主库会记录所有数据更新的sql，当备库读取重放这些事件时，实际上是把所有执行过的sql语句执行一遍。</p>\n<p>优点：</p>\n<p>缺点：</p>\n<h3 id=\"基于行的复制\"><a href=\"#基于行的复制\" class=\"headerlink\" title=\"基于行的复制\"></a>基于行的复制</h3><p>将实际的数据记录在二进制日志中。</p>\n<p>优点：</p>\n<p>缺点：</p>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><h3 id=\"主库\"><a href=\"#主库\" class=\"headerlink\" title=\"主库\"></a>主库</h3><p>1、修改配置文件</p>\n<pre><code>vi /etc/my.cnf\n</code></pre><p>配置参数</p>\n<pre><code>log_bin=mysql-bin  \nserver-id=1 \nreplay_log=/var/lib/mysql/mysql-replay-bin\nlog_slave_updates=1\nread_only=1\ninnodb_flush_log_at_trx_commit=1 \nsync_binlog=1\n</code></pre><p>启动MySQL</p>\n<pre><code>systemctl restart mysqld;\n</code></pre><p><strong>注意：</strong> log_bin一定要开启，也可以是’log-bin’,如果不开启可能会报错：</p>\n<p>ERROR 2006 (HY000): MySQL server has gone away<br>No connection. Trying to reconnect…<br>Connection id:    3<br>Current database: <strong><em> NONE </em></strong></p>\n<p>Empty set (0.00 sec)</p>\n<h4 id=\"参数解释\"><a href=\"#参数解释\" class=\"headerlink\" title=\"参数解释\"></a>参数解释</h4><p>2、创建一个供局域网内连接的用户(有的提到要加锁)</p>\n<pre><code>grant replication slave on *.* to &apos;admin&apos;@&apos;192.168.117.%&apos; identified by &apos;xxxxxx&apos;;\n\nflush privileges;\n</code></pre><p><strong>注意：</strong> on后面是’<em>.</em>‘,否则可能会报错：</p>\n<p>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘to ‘admin-m‘@’192.168.117.%’ identified by ‘admin234’’ at line 1</p>\n<p>3、查看主库</p>\n<pre><code>mysql -uroot -p\nshow master status \\G;\n</code></pre><h3 id=\"从库\"><a href=\"#从库\" class=\"headerlink\" title=\"从库\"></a>从库</h3><p>1、修改配置(有的提到修改/var/lib/mysql/auto.cnf文件)</p>\n<pre><code>vi /etc/my.cnf\n</code></pre><p>配置参数：</p>\n<pre><code>server_id=22\nrelay_log=relay-log-bin\nskip_slave_start\nread_only\nrelay_log_index=slave-relay-bin.index\n</code></pre><p>2、连接到主库</p>\n<pre><code>change master to master_host=&apos;192.168.117.135&apos;,master_port=3306,master_user=&apos;admin&apos;,master_password=&apos;xxxxx&apos;,master_log_file=&apos;mysql-bin.000003&apos;,master_log_pos=154;\n</code></pre><p>参数解释：</p>\n<p>3、启动从库，查看是否启动成功</p>\n<pre><code>start slave;\n\nshow slave status \\G;\n</code></pre><p>如果Slave_IO_Running: YES Slave_SQL_Running: Yes,则表明启动成功。</p>\n<p>参数Last_IO_Errno: 1236 Last_IO_Error显示失败的原因。</p>\n<p>错误1:中间重启从库mysql,启动后直接start slave;</p>\n<p>报错：ERROR 1872 (HY000): Slave failed to initialize relay log info structure from the repository</p>\n<p>解决：</p>\n<pre><code>reset slave;\n\nchange master .....;\n\nstart slave;\n</code></pre><p>启动成功；</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"主要解决的问题：\"><a href=\"#主要解决的问题：\" class=\"headerlink\" title=\"主要解决的问题：\"></a>主要解决的问题：</h2><p>数据分布</p>\n<p>负载均衡</p>\n<p>备份</p>\n<p>高可用性和故障切换</p>\n<p>升级测试</p>","more":"<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p>1、主库把数据更新记录到二进制日志</p>\n<p>2、备库将主库的日志复制到自己的中继日志</p>\n<blockquote>\n<p>备库启动I/O线程，和主库建立一个客户端连接</p>\n<p>主库启动特殊的转储线程，读取主库上二进制日志中的事件</p>\n<p>备库I/O线程将接收到的事件记录到中继日志</p>\n</blockquote>\n<p>3、备库读取中继日志的事件，写入数据</p>\n<p>备库sql线程从中继日志读取事件、执行事件</p>\n<h3 id=\"基于语句的复制\"><a href=\"#基于语句的复制\" class=\"headerlink\" title=\"基于语句的复制\"></a>基于语句的复制</h3><p>主库会记录所有数据更新的sql，当备库读取重放这些事件时，实际上是把所有执行过的sql语句执行一遍。</p>\n<p>优点：</p>\n<p>缺点：</p>\n<h3 id=\"基于行的复制\"><a href=\"#基于行的复制\" class=\"headerlink\" title=\"基于行的复制\"></a>基于行的复制</h3><p>将实际的数据记录在二进制日志中。</p>\n<p>优点：</p>\n<p>缺点：</p>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><h3 id=\"主库\"><a href=\"#主库\" class=\"headerlink\" title=\"主库\"></a>主库</h3><p>1、修改配置文件</p>\n<pre><code>vi /etc/my.cnf\n</code></pre><p>配置参数</p>\n<pre><code>log_bin=mysql-bin  \nserver-id=1 \nreplay_log=/var/lib/mysql/mysql-replay-bin\nlog_slave_updates=1\nread_only=1\ninnodb_flush_log_at_trx_commit=1 \nsync_binlog=1\n</code></pre><p>启动MySQL</p>\n<pre><code>systemctl restart mysqld;\n</code></pre><p><strong>注意：</strong> log_bin一定要开启，也可以是’log-bin’,如果不开启可能会报错：</p>\n<p>ERROR 2006 (HY000): MySQL server has gone away<br>No connection. Trying to reconnect…<br>Connection id:    3<br>Current database: <strong><em> NONE </em></strong></p>\n<p>Empty set (0.00 sec)</p>\n<h4 id=\"参数解释\"><a href=\"#参数解释\" class=\"headerlink\" title=\"参数解释\"></a>参数解释</h4><p>2、创建一个供局域网内连接的用户(有的提到要加锁)</p>\n<pre><code>grant replication slave on *.* to &apos;admin&apos;@&apos;192.168.117.%&apos; identified by &apos;xxxxxx&apos;;\n\nflush privileges;\n</code></pre><p><strong>注意：</strong> on后面是’<em>.</em>‘,否则可能会报错：</p>\n<p>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘to ‘admin-m‘@’192.168.117.%’ identified by ‘admin234’’ at line 1</p>\n<p>3、查看主库</p>\n<pre><code>mysql -uroot -p\nshow master status \\G;\n</code></pre><h3 id=\"从库\"><a href=\"#从库\" class=\"headerlink\" title=\"从库\"></a>从库</h3><p>1、修改配置(有的提到修改/var/lib/mysql/auto.cnf文件)</p>\n<pre><code>vi /etc/my.cnf\n</code></pre><p>配置参数：</p>\n<pre><code>server_id=22\nrelay_log=relay-log-bin\nskip_slave_start\nread_only\nrelay_log_index=slave-relay-bin.index\n</code></pre><p>2、连接到主库</p>\n<pre><code>change master to master_host=&apos;192.168.117.135&apos;,master_port=3306,master_user=&apos;admin&apos;,master_password=&apos;xxxxx&apos;,master_log_file=&apos;mysql-bin.000003&apos;,master_log_pos=154;\n</code></pre><p>参数解释：</p>\n<p>3、启动从库，查看是否启动成功</p>\n<pre><code>start slave;\n\nshow slave status \\G;\n</code></pre><p>如果Slave_IO_Running: YES Slave_SQL_Running: Yes,则表明启动成功。</p>\n<p>参数Last_IO_Errno: 1236 Last_IO_Error显示失败的原因。</p>\n<p>错误1:中间重启从库mysql,启动后直接start slave;</p>\n<p>报错：ERROR 1872 (HY000): Slave failed to initialize relay log info structure from the repository</p>\n<p>解决：</p>\n<pre><code>reset slave;\n\nchange master .....;\n\nstart slave;\n</code></pre><p>启动成功；</p>"},{"title":"Scala基础入门","date":"2018-05-12T22:48:37.000Z","_content":"与Scala大约是三年之前，在一本《程序员面试宝典》看到，2016年买了《Scala快速入门》，感觉好繁琐，后来慢慢放下，去年接触到Apache Apollo，是一个MQTT的代理服务器开源软件(貌似是2007年发布的，就没有更新过)。最近突然想要捡起来\n\n学习新语言语法最快的途径就是打开[菜鸟教程网](http://www.runoob.com/scala/scala-tutorial.html \"菜鸟教程Scala\")跟着敲一遍，以下内容权当记录：\n\n<!-- more -->\n\n#### 一、基础语法：\n> 区分大小写 -  Scala是大小写敏感的，这意味着标识Hello 和 hello在Scala中会有不同的含义。\n\n>类名 - 对于所有的类名的第一个字母要大写。\n\n>如果需要使用几个单词来构成一个类的名称，每个单词的第一个字母要大写。示例：class MyFirstScalaClass\n\n>方法名称 - 所有的方法名称的第一个字母用小写。\n\n>如果若干单词被用于构成方法的名称，则每个单词的第一个字母应大写。示例：def myMethodName()\n\n>程序文件名 - 程序文件的名称应该与对象名称(object)完全匹配。\n\n>保存文件时，应该保存它使用的对象名称（记住Scala是区分大小写），并追加\".scala\"为文件扩展名。 （如果文件名和对象名称不匹配，程序将无法编译）。\n\n>def main(args: Array[String]) - Scala程序从main()方法开始处理，这是每一个Scala程序的强制程序入口部分。(类似于Java)\n\n#### 二、标识符\n>避免使用$开头的标识符\n\n>避免使用下划线结尾的标识符\n\n**混合标识符**：例如unary_+\n\n**字面标识符**：例如`x``yield`\n\n***在Scala中不能使用Thread.yield(),必须使用Thread.`yield`();***\n\n#### 三、包\n定义包\n引用包，import语句可以出现在任何地方，而不只是文件顶部\n\n引入包内所有成员：import java.awt._\n\n重命名成员：import java.util.{HashMap => JavaHashMap}\n\n隐藏成员：import java.util.{HashMap => _, _}\n\n***默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._，这里也能解释，为什么以scala开头的包，在使用时都是省去scala.的。***\n\n\n#### 四、数据类型\n\nUnit\nNull\nNothing\nAny\nAnyRef\n\n符号字面量\n字符字面量 'wangsir'\n字符串字面量 \"Hello World!\"\n多行字符串\n\tval foo = \"\"\" Hello\n\t\tWorld!\n\t\tScala\n\t\"\"\"\n\n#### 五、变量\nvar 声明变量\n\nval 声明常量\n\n变量不一定要声明类型，会有类型推断; 但是如果声明类型，必须初始化。\n\n声明多个变量 val xmax, ymax = 100 //xmax=ymax=100\n声明元组 val person = (\"wangsir\", 27)\n\n#### 六、访问修饰符\n> private：比Java更严格，在嵌套类情况下，外部类甚至不能访问嵌套类的私有成员\n\n> protected：比Java更严格，只允许在该类的子类中被访问\n\n> public：和Java不同，Scala默认访问为public\n\n作用域保护：private[x] protected[x]\n\n\n#### 七、\nScala不支持break或continue语句，但是2.8版本后提供了一种中断循环\n\n1、字符串\nScala本身没有String类，所以Scala中的String类实际上是Java String\n\n\tAPI：str1.concat(str2)\n\n2、数组:\nvar z:Array[String] = new Array[String](3)\nvar z = new Array[String](3)\nvar z = Array(\"\",\"\",\"\")\n区间数组：var z = range(10, 20, 2)\n\nfor(a <- array)\nfor(i <- 0 to (array.length-1))\n\n3、集合(类似于Java、Python)\n\nList:\n\nSet:\n\nMap:\n\n元组: var x = (10, \"\")\n\nOption:Option有两个子类(Some、None) var x:Option[Int] = Some(5)\n\nIterator:\n\n4、模式匹配，类似于Java中的switch\nx match {case Any => Any}\n\n#### 八、函数\n**函数传名调用**：传名调用，传值调用\n\n**内嵌函数**\n\n**偏应用函数**\n\n递归函数\n\n**高阶函数**：允许使用其他函数作为参数/返回值 def f1(f2(), arg) = f2();\n\n**匿名函数**：\n`var inc = (x:Int) => x+1; var print = () => {System.getProperty(\"\")}`\n\n**函数柯里化**\n\n闭包**：\n\n\n#### 九、对象、类、特征\n1、继承\n  > 1、重写一个非抽象方法必须使用override修饰符。\n  > \n  > 2、只有主构造函数才可以往基类的构造函数里写参数。\n  > \n  > 3、在子类中重写超类的抽象方法时，你不需要使用override关键字。\n\n***Scala没有static***\n\nScala定义单利模式时，需要在同一个源文件中定义一个类(伴生类)，和一个同名的object对象(伴生对象),类和对象可以互相访问其私有成员\n\n2、特征：相当于Java的接口，不同的是特征可以定义属性和方法的实现，所以更像Java的抽象类\n特征也有构造器\n\n构造器的执行顺序：\n> 调用超类的构造器；\n> \n>特征构造器在超类构造器之后、类构造器之前执行；\n>\n>特征由左到右被构造；\n>\n>每个特征当中，父特征先被构造；\n>\n>如果多个特征共有一个父特征，父特征不会被重复构造\n>\n>所有特征被构造完毕，子类被构造。\n\n3、样例类，用于模式匹配\n\n`case class Person(name: String, age: Int)`\n\n在声明样例类时，下面的过程自动发生了：\n>构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做；\n>\n>在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象；\n>\n>提供unapply方法使模式匹配可以工作；\n>\n>生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。\n\n4、提取器：从传递的对象中提出构造该对象的参数\napply\nunapply\n\n\n\n#### 十、异常\n和Java类似\n\n#### 十一、web框架\nLift框架\nPlay框架","source":"_posts/scala-base.md","raw":"---\ntitle: Scala基础入门\ndate: 2018-05-13 06:48:37\ntags: Scala, 函数式编程\n---\n与Scala大约是三年之前，在一本《程序员面试宝典》看到，2016年买了《Scala快速入门》，感觉好繁琐，后来慢慢放下，去年接触到Apache Apollo，是一个MQTT的代理服务器开源软件(貌似是2007年发布的，就没有更新过)。最近突然想要捡起来\n\n学习新语言语法最快的途径就是打开[菜鸟教程网](http://www.runoob.com/scala/scala-tutorial.html \"菜鸟教程Scala\")跟着敲一遍，以下内容权当记录：\n\n<!-- more -->\n\n#### 一、基础语法：\n> 区分大小写 -  Scala是大小写敏感的，这意味着标识Hello 和 hello在Scala中会有不同的含义。\n\n>类名 - 对于所有的类名的第一个字母要大写。\n\n>如果需要使用几个单词来构成一个类的名称，每个单词的第一个字母要大写。示例：class MyFirstScalaClass\n\n>方法名称 - 所有的方法名称的第一个字母用小写。\n\n>如果若干单词被用于构成方法的名称，则每个单词的第一个字母应大写。示例：def myMethodName()\n\n>程序文件名 - 程序文件的名称应该与对象名称(object)完全匹配。\n\n>保存文件时，应该保存它使用的对象名称（记住Scala是区分大小写），并追加\".scala\"为文件扩展名。 （如果文件名和对象名称不匹配，程序将无法编译）。\n\n>def main(args: Array[String]) - Scala程序从main()方法开始处理，这是每一个Scala程序的强制程序入口部分。(类似于Java)\n\n#### 二、标识符\n>避免使用$开头的标识符\n\n>避免使用下划线结尾的标识符\n\n**混合标识符**：例如unary_+\n\n**字面标识符**：例如`x``yield`\n\n***在Scala中不能使用Thread.yield(),必须使用Thread.`yield`();***\n\n#### 三、包\n定义包\n引用包，import语句可以出现在任何地方，而不只是文件顶部\n\n引入包内所有成员：import java.awt._\n\n重命名成员：import java.util.{HashMap => JavaHashMap}\n\n隐藏成员：import java.util.{HashMap => _, _}\n\n***默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._，这里也能解释，为什么以scala开头的包，在使用时都是省去scala.的。***\n\n\n#### 四、数据类型\n\nUnit\nNull\nNothing\nAny\nAnyRef\n\n符号字面量\n字符字面量 'wangsir'\n字符串字面量 \"Hello World!\"\n多行字符串\n\tval foo = \"\"\" Hello\n\t\tWorld!\n\t\tScala\n\t\"\"\"\n\n#### 五、变量\nvar 声明变量\n\nval 声明常量\n\n变量不一定要声明类型，会有类型推断; 但是如果声明类型，必须初始化。\n\n声明多个变量 val xmax, ymax = 100 //xmax=ymax=100\n声明元组 val person = (\"wangsir\", 27)\n\n#### 六、访问修饰符\n> private：比Java更严格，在嵌套类情况下，外部类甚至不能访问嵌套类的私有成员\n\n> protected：比Java更严格，只允许在该类的子类中被访问\n\n> public：和Java不同，Scala默认访问为public\n\n作用域保护：private[x] protected[x]\n\n\n#### 七、\nScala不支持break或continue语句，但是2.8版本后提供了一种中断循环\n\n1、字符串\nScala本身没有String类，所以Scala中的String类实际上是Java String\n\n\tAPI：str1.concat(str2)\n\n2、数组:\nvar z:Array[String] = new Array[String](3)\nvar z = new Array[String](3)\nvar z = Array(\"\",\"\",\"\")\n区间数组：var z = range(10, 20, 2)\n\nfor(a <- array)\nfor(i <- 0 to (array.length-1))\n\n3、集合(类似于Java、Python)\n\nList:\n\nSet:\n\nMap:\n\n元组: var x = (10, \"\")\n\nOption:Option有两个子类(Some、None) var x:Option[Int] = Some(5)\n\nIterator:\n\n4、模式匹配，类似于Java中的switch\nx match {case Any => Any}\n\n#### 八、函数\n**函数传名调用**：传名调用，传值调用\n\n**内嵌函数**\n\n**偏应用函数**\n\n递归函数\n\n**高阶函数**：允许使用其他函数作为参数/返回值 def f1(f2(), arg) = f2();\n\n**匿名函数**：\n`var inc = (x:Int) => x+1; var print = () => {System.getProperty(\"\")}`\n\n**函数柯里化**\n\n闭包**：\n\n\n#### 九、对象、类、特征\n1、继承\n  > 1、重写一个非抽象方法必须使用override修饰符。\n  > \n  > 2、只有主构造函数才可以往基类的构造函数里写参数。\n  > \n  > 3、在子类中重写超类的抽象方法时，你不需要使用override关键字。\n\n***Scala没有static***\n\nScala定义单利模式时，需要在同一个源文件中定义一个类(伴生类)，和一个同名的object对象(伴生对象),类和对象可以互相访问其私有成员\n\n2、特征：相当于Java的接口，不同的是特征可以定义属性和方法的实现，所以更像Java的抽象类\n特征也有构造器\n\n构造器的执行顺序：\n> 调用超类的构造器；\n> \n>特征构造器在超类构造器之后、类构造器之前执行；\n>\n>特征由左到右被构造；\n>\n>每个特征当中，父特征先被构造；\n>\n>如果多个特征共有一个父特征，父特征不会被重复构造\n>\n>所有特征被构造完毕，子类被构造。\n\n3、样例类，用于模式匹配\n\n`case class Person(name: String, age: Int)`\n\n在声明样例类时，下面的过程自动发生了：\n>构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做；\n>\n>在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象；\n>\n>提供unapply方法使模式匹配可以工作；\n>\n>生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。\n\n4、提取器：从传递的对象中提出构造该对象的参数\napply\nunapply\n\n\n\n#### 十、异常\n和Java类似\n\n#### 十一、web框架\nLift框架\nPlay框架","slug":"scala-base","published":1,"updated":"2018-07-24T08:41:37.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde2h0026v0f0o6tenvc0","content":"<p>与Scala大约是三年之前，在一本《程序员面试宝典》看到，2016年买了《Scala快速入门》，感觉好繁琐，后来慢慢放下，去年接触到Apache Apollo，是一个MQTT的代理服务器开源软件(貌似是2007年发布的，就没有更新过)。最近突然想要捡起来</p>\n<p>学习新语言语法最快的途径就是打开<a href=\"http://www.runoob.com/scala/scala-tutorial.html\" title=\"菜鸟教程Scala\" target=\"_blank\" rel=\"noopener\">菜鸟教程网</a>跟着敲一遍，以下内容权当记录：</p>\n<a id=\"more\"></a>\n<h4 id=\"一、基础语法：\"><a href=\"#一、基础语法：\" class=\"headerlink\" title=\"一、基础语法：\"></a>一、基础语法：</h4><blockquote>\n<p>区分大小写 -  Scala是大小写敏感的，这意味着标识Hello 和 hello在Scala中会有不同的含义。</p>\n</blockquote>\n<blockquote>\n<p>类名 - 对于所有的类名的第一个字母要大写。</p>\n</blockquote>\n<blockquote>\n<p>如果需要使用几个单词来构成一个类的名称，每个单词的第一个字母要大写。示例：class MyFirstScalaClass</p>\n</blockquote>\n<blockquote>\n<p>方法名称 - 所有的方法名称的第一个字母用小写。</p>\n</blockquote>\n<blockquote>\n<p>如果若干单词被用于构成方法的名称，则每个单词的第一个字母应大写。示例：def myMethodName()</p>\n</blockquote>\n<blockquote>\n<p>程序文件名 - 程序文件的名称应该与对象名称(object)完全匹配。</p>\n</blockquote>\n<blockquote>\n<p>保存文件时，应该保存它使用的对象名称（记住Scala是区分大小写），并追加”.scala”为文件扩展名。 （如果文件名和对象名称不匹配，程序将无法编译）。</p>\n</blockquote>\n<blockquote>\n<p>def main(args: Array[String]) - Scala程序从main()方法开始处理，这是每一个Scala程序的强制程序入口部分。(类似于Java)</p>\n</blockquote>\n<h4 id=\"二、标识符\"><a href=\"#二、标识符\" class=\"headerlink\" title=\"二、标识符\"></a>二、标识符</h4><blockquote>\n<p>避免使用$开头的标识符</p>\n</blockquote>\n<blockquote>\n<p>避免使用下划线结尾的标识符</p>\n</blockquote>\n<p><strong>混合标识符</strong>：例如unary_+</p>\n<p><strong>字面标识符</strong>：例如<code>x`</code>yield`</p>\n<p><strong><em>在Scala中不能使用Thread.yield(),必须使用Thread.<code>yield</code>();</em></strong></p>\n<h4 id=\"三、包\"><a href=\"#三、包\" class=\"headerlink\" title=\"三、包\"></a>三、包</h4><p>定义包<br>引用包，import语句可以出现在任何地方，而不只是文件顶部</p>\n<p>引入包内所有成员：import java.awt._</p>\n<p>重命名成员：import java.util.{HashMap =&gt; JavaHashMap}</p>\n<p>隐藏成员：import java.util.{HashMap =&gt; _, _}</p>\n<p><strong><em>默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._，这里也能解释，为什么以scala开头的包，在使用时都是省去scala.的。</em></strong></p>\n<h4 id=\"四、数据类型\"><a href=\"#四、数据类型\" class=\"headerlink\" title=\"四、数据类型\"></a>四、数据类型</h4><p>Unit<br>Null<br>Nothing<br>Any<br>AnyRef</p>\n<p>符号字面量<br>字符字面量 ‘wangsir’<br>字符串字面量 “Hello World!”<br>多行字符串<br>    val foo = “”” Hello<br>        World!<br>        Scala<br>    “””</p>\n<h4 id=\"五、变量\"><a href=\"#五、变量\" class=\"headerlink\" title=\"五、变量\"></a>五、变量</h4><p>var 声明变量</p>\n<p>val 声明常量</p>\n<p>变量不一定要声明类型，会有类型推断; 但是如果声明类型，必须初始化。</p>\n<p>声明多个变量 val xmax, ymax = 100 //xmax=ymax=100<br>声明元组 val person = (“wangsir”, 27)</p>\n<h4 id=\"六、访问修饰符\"><a href=\"#六、访问修饰符\" class=\"headerlink\" title=\"六、访问修饰符\"></a>六、访问修饰符</h4><blockquote>\n<p>private：比Java更严格，在嵌套类情况下，外部类甚至不能访问嵌套类的私有成员</p>\n</blockquote>\n<blockquote>\n<p>protected：比Java更严格，只允许在该类的子类中被访问</p>\n</blockquote>\n<blockquote>\n<p>public：和Java不同，Scala默认访问为public</p>\n</blockquote>\n<p>作用域保护：private[x] protected[x]</p>\n<h4 id=\"七、\"><a href=\"#七、\" class=\"headerlink\" title=\"七、\"></a>七、</h4><p>Scala不支持break或continue语句，但是2.8版本后提供了一种中断循环</p>\n<p>1、字符串<br>Scala本身没有String类，所以Scala中的String类实际上是Java String</p>\n<pre><code>API：str1.concat(str2)\n</code></pre><p>2、数组:<br>var z:Array[String] = new Array<a href=\"3\">String</a><br>var z = new Array<a href=\"3\">String</a><br>var z = Array(“”,””,””)<br>区间数组：var z = range(10, 20, 2)</p>\n<p>for(a &lt;- array)<br>for(i &lt;- 0 to (array.length-1))</p>\n<p>3、集合(类似于Java、Python)</p>\n<p>List:</p>\n<p>Set:</p>\n<p>Map:</p>\n<p>元组: var x = (10, “”)</p>\n<p>Option:Option有两个子类(Some、None) var x:Option[Int] = Some(5)</p>\n<p>Iterator:</p>\n<p>4、模式匹配，类似于Java中的switch<br>x match {case Any =&gt; Any}</p>\n<h4 id=\"八、函数\"><a href=\"#八、函数\" class=\"headerlink\" title=\"八、函数\"></a>八、函数</h4><p><strong>函数传名调用</strong>：传名调用，传值调用</p>\n<p><strong>内嵌函数</strong></p>\n<p><strong>偏应用函数</strong></p>\n<p>递归函数</p>\n<p><strong>高阶函数</strong>：允许使用其他函数作为参数/返回值 def f1(f2(), arg) = f2();</p>\n<p><strong>匿名函数</strong>：<br><code>var inc = (x:Int) =&gt; x+1; var print = () =&gt; {System.getProperty(&quot;&quot;)}</code></p>\n<p><strong>函数柯里化</strong></p>\n<p>闭包**：</p>\n<h4 id=\"九、对象、类、特征\"><a href=\"#九、对象、类、特征\" class=\"headerlink\" title=\"九、对象、类、特征\"></a>九、对象、类、特征</h4><p>1、继承</p>\n<blockquote>\n<p>1、重写一个非抽象方法必须使用override修饰符。</p>\n<p>2、只有主构造函数才可以往基类的构造函数里写参数。</p>\n<p>3、在子类中重写超类的抽象方法时，你不需要使用override关键字。</p>\n</blockquote>\n<p><strong><em>Scala没有static</em></strong></p>\n<p>Scala定义单利模式时，需要在同一个源文件中定义一个类(伴生类)，和一个同名的object对象(伴生对象),类和对象可以互相访问其私有成员</p>\n<p>2、特征：相当于Java的接口，不同的是特征可以定义属性和方法的实现，所以更像Java的抽象类<br>特征也有构造器</p>\n<p>构造器的执行顺序：</p>\n<blockquote>\n<p>调用超类的构造器；</p>\n<p>特征构造器在超类构造器之后、类构造器之前执行；</p>\n<p>特征由左到右被构造；</p>\n<p>每个特征当中，父特征先被构造；</p>\n<p>如果多个特征共有一个父特征，父特征不会被重复构造</p>\n<p>所有特征被构造完毕，子类被构造。</p>\n</blockquote>\n<p>3、样例类，用于模式匹配</p>\n<p><code>case class Person(name: String, age: Int)</code></p>\n<p>在声明样例类时，下面的过程自动发生了：</p>\n<blockquote>\n<p>构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做；</p>\n<p>在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象；</p>\n<p>提供unapply方法使模式匹配可以工作；</p>\n<p>生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。</p>\n</blockquote>\n<p>4、提取器：从传递的对象中提出构造该对象的参数<br>apply<br>unapply</p>\n<h4 id=\"十、异常\"><a href=\"#十、异常\" class=\"headerlink\" title=\"十、异常\"></a>十、异常</h4><p>和Java类似</p>\n<h4 id=\"十一、web框架\"><a href=\"#十一、web框架\" class=\"headerlink\" title=\"十一、web框架\"></a>十一、web框架</h4><p>Lift框架<br>Play框架</p>\n","site":{"data":{}},"excerpt":"<p>与Scala大约是三年之前，在一本《程序员面试宝典》看到，2016年买了《Scala快速入门》，感觉好繁琐，后来慢慢放下，去年接触到Apache Apollo，是一个MQTT的代理服务器开源软件(貌似是2007年发布的，就没有更新过)。最近突然想要捡起来</p>\n<p>学习新语言语法最快的途径就是打开<a href=\"http://www.runoob.com/scala/scala-tutorial.html\" title=\"菜鸟教程Scala\" target=\"_blank\" rel=\"noopener\">菜鸟教程网</a>跟着敲一遍，以下内容权当记录：</p>","more":"<h4 id=\"一、基础语法：\"><a href=\"#一、基础语法：\" class=\"headerlink\" title=\"一、基础语法：\"></a>一、基础语法：</h4><blockquote>\n<p>区分大小写 -  Scala是大小写敏感的，这意味着标识Hello 和 hello在Scala中会有不同的含义。</p>\n</blockquote>\n<blockquote>\n<p>类名 - 对于所有的类名的第一个字母要大写。</p>\n</blockquote>\n<blockquote>\n<p>如果需要使用几个单词来构成一个类的名称，每个单词的第一个字母要大写。示例：class MyFirstScalaClass</p>\n</blockquote>\n<blockquote>\n<p>方法名称 - 所有的方法名称的第一个字母用小写。</p>\n</blockquote>\n<blockquote>\n<p>如果若干单词被用于构成方法的名称，则每个单词的第一个字母应大写。示例：def myMethodName()</p>\n</blockquote>\n<blockquote>\n<p>程序文件名 - 程序文件的名称应该与对象名称(object)完全匹配。</p>\n</blockquote>\n<blockquote>\n<p>保存文件时，应该保存它使用的对象名称（记住Scala是区分大小写），并追加”.scala”为文件扩展名。 （如果文件名和对象名称不匹配，程序将无法编译）。</p>\n</blockquote>\n<blockquote>\n<p>def main(args: Array[String]) - Scala程序从main()方法开始处理，这是每一个Scala程序的强制程序入口部分。(类似于Java)</p>\n</blockquote>\n<h4 id=\"二、标识符\"><a href=\"#二、标识符\" class=\"headerlink\" title=\"二、标识符\"></a>二、标识符</h4><blockquote>\n<p>避免使用$开头的标识符</p>\n</blockquote>\n<blockquote>\n<p>避免使用下划线结尾的标识符</p>\n</blockquote>\n<p><strong>混合标识符</strong>：例如unary_+</p>\n<p><strong>字面标识符</strong>：例如<code>x`</code>yield`</p>\n<p><strong><em>在Scala中不能使用Thread.yield(),必须使用Thread.<code>yield</code>();</em></strong></p>\n<h4 id=\"三、包\"><a href=\"#三、包\" class=\"headerlink\" title=\"三、包\"></a>三、包</h4><p>定义包<br>引用包，import语句可以出现在任何地方，而不只是文件顶部</p>\n<p>引入包内所有成员：import java.awt._</p>\n<p>重命名成员：import java.util.{HashMap =&gt; JavaHashMap}</p>\n<p>隐藏成员：import java.util.{HashMap =&gt; _, _}</p>\n<p><strong><em>默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._，这里也能解释，为什么以scala开头的包，在使用时都是省去scala.的。</em></strong></p>\n<h4 id=\"四、数据类型\"><a href=\"#四、数据类型\" class=\"headerlink\" title=\"四、数据类型\"></a>四、数据类型</h4><p>Unit<br>Null<br>Nothing<br>Any<br>AnyRef</p>\n<p>符号字面量<br>字符字面量 ‘wangsir’<br>字符串字面量 “Hello World!”<br>多行字符串<br>    val foo = “”” Hello<br>        World!<br>        Scala<br>    “””</p>\n<h4 id=\"五、变量\"><a href=\"#五、变量\" class=\"headerlink\" title=\"五、变量\"></a>五、变量</h4><p>var 声明变量</p>\n<p>val 声明常量</p>\n<p>变量不一定要声明类型，会有类型推断; 但是如果声明类型，必须初始化。</p>\n<p>声明多个变量 val xmax, ymax = 100 //xmax=ymax=100<br>声明元组 val person = (“wangsir”, 27)</p>\n<h4 id=\"六、访问修饰符\"><a href=\"#六、访问修饰符\" class=\"headerlink\" title=\"六、访问修饰符\"></a>六、访问修饰符</h4><blockquote>\n<p>private：比Java更严格，在嵌套类情况下，外部类甚至不能访问嵌套类的私有成员</p>\n</blockquote>\n<blockquote>\n<p>protected：比Java更严格，只允许在该类的子类中被访问</p>\n</blockquote>\n<blockquote>\n<p>public：和Java不同，Scala默认访问为public</p>\n</blockquote>\n<p>作用域保护：private[x] protected[x]</p>\n<h4 id=\"七、\"><a href=\"#七、\" class=\"headerlink\" title=\"七、\"></a>七、</h4><p>Scala不支持break或continue语句，但是2.8版本后提供了一种中断循环</p>\n<p>1、字符串<br>Scala本身没有String类，所以Scala中的String类实际上是Java String</p>\n<pre><code>API：str1.concat(str2)\n</code></pre><p>2、数组:<br>var z:Array[String] = new Array<a href=\"3\">String</a><br>var z = new Array<a href=\"3\">String</a><br>var z = Array(“”,””,””)<br>区间数组：var z = range(10, 20, 2)</p>\n<p>for(a &lt;- array)<br>for(i &lt;- 0 to (array.length-1))</p>\n<p>3、集合(类似于Java、Python)</p>\n<p>List:</p>\n<p>Set:</p>\n<p>Map:</p>\n<p>元组: var x = (10, “”)</p>\n<p>Option:Option有两个子类(Some、None) var x:Option[Int] = Some(5)</p>\n<p>Iterator:</p>\n<p>4、模式匹配，类似于Java中的switch<br>x match {case Any =&gt; Any}</p>\n<h4 id=\"八、函数\"><a href=\"#八、函数\" class=\"headerlink\" title=\"八、函数\"></a>八、函数</h4><p><strong>函数传名调用</strong>：传名调用，传值调用</p>\n<p><strong>内嵌函数</strong></p>\n<p><strong>偏应用函数</strong></p>\n<p>递归函数</p>\n<p><strong>高阶函数</strong>：允许使用其他函数作为参数/返回值 def f1(f2(), arg) = f2();</p>\n<p><strong>匿名函数</strong>：<br><code>var inc = (x:Int) =&gt; x+1; var print = () =&gt; {System.getProperty(&quot;&quot;)}</code></p>\n<p><strong>函数柯里化</strong></p>\n<p>闭包**：</p>\n<h4 id=\"九、对象、类、特征\"><a href=\"#九、对象、类、特征\" class=\"headerlink\" title=\"九、对象、类、特征\"></a>九、对象、类、特征</h4><p>1、继承</p>\n<blockquote>\n<p>1、重写一个非抽象方法必须使用override修饰符。</p>\n<p>2、只有主构造函数才可以往基类的构造函数里写参数。</p>\n<p>3、在子类中重写超类的抽象方法时，你不需要使用override关键字。</p>\n</blockquote>\n<p><strong><em>Scala没有static</em></strong></p>\n<p>Scala定义单利模式时，需要在同一个源文件中定义一个类(伴生类)，和一个同名的object对象(伴生对象),类和对象可以互相访问其私有成员</p>\n<p>2、特征：相当于Java的接口，不同的是特征可以定义属性和方法的实现，所以更像Java的抽象类<br>特征也有构造器</p>\n<p>构造器的执行顺序：</p>\n<blockquote>\n<p>调用超类的构造器；</p>\n<p>特征构造器在超类构造器之后、类构造器之前执行；</p>\n<p>特征由左到右被构造；</p>\n<p>每个特征当中，父特征先被构造；</p>\n<p>如果多个特征共有一个父特征，父特征不会被重复构造</p>\n<p>所有特征被构造完毕，子类被构造。</p>\n</blockquote>\n<p>3、样例类，用于模式匹配</p>\n<p><code>case class Person(name: String, age: Int)</code></p>\n<p>在声明样例类时，下面的过程自动发生了：</p>\n<blockquote>\n<p>构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做；</p>\n<p>在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象；</p>\n<p>提供unapply方法使模式匹配可以工作；</p>\n<p>生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。</p>\n</blockquote>\n<p>4、提取器：从传递的对象中提出构造该对象的参数<br>apply<br>unapply</p>\n<h4 id=\"十、异常\"><a href=\"#十、异常\" class=\"headerlink\" title=\"十、异常\"></a>十、异常</h4><p>和Java类似</p>\n<h4 id=\"十一、web框架\"><a href=\"#十一、web框架\" class=\"headerlink\" title=\"十一、web框架\"></a>十一、web框架</h4><p>Lift框架<br>Play框架</p>"},{"title":"Spring的IOC原理分析","date":"2018-08-08T14:16:41.000Z","_content":"\nBeanFactory\n\nListableBeanFactory\n\nHierarchicalBeanFactory\n\nAutowireCapableBeanFactory\n\nApplicationContext","source":"_posts/spring-ioc.md","raw":"---\ntitle: Spring的IOC原理分析\ndate: 2018-08-08 22:16:41\ntags: java, spring, ioc\ncategories: java\n---\n\nBeanFactory\n\nListableBeanFactory\n\nHierarchicalBeanFactory\n\nAutowireCapableBeanFactory\n\nApplicationContext","slug":"spring-ioc","published":1,"updated":"2018-08-12T03:26:17.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde2o0028v0f0bh125x57","content":"<p>BeanFactory</p>\n<p>ListableBeanFactory</p>\n<p>HierarchicalBeanFactory</p>\n<p>AutowireCapableBeanFactory</p>\n<p>ApplicationContext</p>\n","site":{"data":{}},"excerpt":"","more":"<p>BeanFactory</p>\n<p>ListableBeanFactory</p>\n<p>HierarchicalBeanFactory</p>\n<p>AutowireCapableBeanFactory</p>\n<p>ApplicationContext</p>\n"},{"title":"spring-design-pattern","date":"2018-08-12T13:22:53.000Z","_content":"## 简单工厂模式 ##\n\n\n设计原则：要依赖抽象，不要依赖具体类\n\n避免违反依赖倒置原则的建议：\n\n> 变量不可以持有具体类的引用\n> \n> 不要让类派生自具体类\n> \n> 不要覆盖基类中已实现的方法\n\n<!-- more -->\n\n## 抽象工厂模式 ##\n\n\nSpring的BeanFactory\n\n\n\n## 建设者模式/生成器模式 ##\n\n\nSpring中BeanDefinitionBuilder\n\n\n\n## 代理模式 ##\n\nSpring中ProxyFactoryBean\n\n\n## 策略模式 ##\n\n设计原则：针对接口编程，而不是针对实现编程\n\nspring中MethodNameResolver + ParameterMethodNameResolver\n\n\n## 模板方法模式 ##\n\nSpring中AbstractApplicationCOntext.obtainFreshBeanFactory、refreshBeanFactory、getBeanFactory + GenericApplicationContext\n\n\n\n## 策略、模板、状态3中设计模式的对比 ##\n\n\n## 原型模式 ##\n\nSpring中bean的作用域scope=\"prototype\"\n\n优点：\n\n向客户隐藏制造新实例的复杂性\n\n提供客户能够产生未知类型实例对象的选项\n\n在某些环境下，复制对象比创建新对象更有效\n\n\n## 观察者模式 ##\n\nSpring中AbstractApplicationContext.addApplicationListener + ApplicationListener + ApplicationEventMulticaster\n\n\n\n## 适配器模式 ##\n\nSpring中AOP使用load-time-weaving针对AspectJ、CGLIB使用不同的逻辑\n\n\n\n## 装饰者模式 ##\n\n\n## 适配器模式、装饰者模式的区别 ##","source":"_posts/spring-design-pattern.md","raw":"---\ntitle: spring-design-pattern\ndate: 2018-08-12 21:22:53\ntags: java\ncategories: java\n---\n## 简单工厂模式 ##\n\n\n设计原则：要依赖抽象，不要依赖具体类\n\n避免违反依赖倒置原则的建议：\n\n> 变量不可以持有具体类的引用\n> \n> 不要让类派生自具体类\n> \n> 不要覆盖基类中已实现的方法\n\n<!-- more -->\n\n## 抽象工厂模式 ##\n\n\nSpring的BeanFactory\n\n\n\n## 建设者模式/生成器模式 ##\n\n\nSpring中BeanDefinitionBuilder\n\n\n\n## 代理模式 ##\n\nSpring中ProxyFactoryBean\n\n\n## 策略模式 ##\n\n设计原则：针对接口编程，而不是针对实现编程\n\nspring中MethodNameResolver + ParameterMethodNameResolver\n\n\n## 模板方法模式 ##\n\nSpring中AbstractApplicationCOntext.obtainFreshBeanFactory、refreshBeanFactory、getBeanFactory + GenericApplicationContext\n\n\n\n## 策略、模板、状态3中设计模式的对比 ##\n\n\n## 原型模式 ##\n\nSpring中bean的作用域scope=\"prototype\"\n\n优点：\n\n向客户隐藏制造新实例的复杂性\n\n提供客户能够产生未知类型实例对象的选项\n\n在某些环境下，复制对象比创建新对象更有效\n\n\n## 观察者模式 ##\n\nSpring中AbstractApplicationContext.addApplicationListener + ApplicationListener + ApplicationEventMulticaster\n\n\n\n## 适配器模式 ##\n\nSpring中AOP使用load-time-weaving针对AspectJ、CGLIB使用不同的逻辑\n\n\n\n## 装饰者模式 ##\n\n\n## 适配器模式、装饰者模式的区别 ##","slug":"spring-design-pattern","published":1,"updated":"2018-08-14T04:01:19.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde2t002cv0f0ca5fgufn","content":"<h2 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h2><p>设计原则：要依赖抽象，不要依赖具体类</p>\n<p>避免违反依赖倒置原则的建议：</p>\n<blockquote>\n<p>变量不可以持有具体类的引用</p>\n<p>不要让类派生自具体类</p>\n<p>不要覆盖基类中已实现的方法</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h2><p>Spring的BeanFactory</p>\n<h2 id=\"建设者模式-生成器模式\"><a href=\"#建设者模式-生成器模式\" class=\"headerlink\" title=\"建设者模式/生成器模式\"></a>建设者模式/生成器模式</h2><p>Spring中BeanDefinitionBuilder</p>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>Spring中ProxyFactoryBean</p>\n<h2 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h2><p>设计原则：针对接口编程，而不是针对实现编程</p>\n<p>spring中MethodNameResolver + ParameterMethodNameResolver</p>\n<h2 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h2><p>Spring中AbstractApplicationCOntext.obtainFreshBeanFactory、refreshBeanFactory、getBeanFactory + GenericApplicationContext</p>\n<h2 id=\"策略、模板、状态3中设计模式的对比\"><a href=\"#策略、模板、状态3中设计模式的对比\" class=\"headerlink\" title=\"策略、模板、状态3中设计模式的对比\"></a>策略、模板、状态3中设计模式的对比</h2><h2 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h2><p>Spring中bean的作用域scope=”prototype”</p>\n<p>优点：</p>\n<p>向客户隐藏制造新实例的复杂性</p>\n<p>提供客户能够产生未知类型实例对象的选项</p>\n<p>在某些环境下，复制对象比创建新对象更有效</p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>Spring中AbstractApplicationContext.addApplicationListener + ApplicationListener + ApplicationEventMulticaster</p>\n<h2 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h2><p>Spring中AOP使用load-time-weaving针对AspectJ、CGLIB使用不同的逻辑</p>\n<h2 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h2><h2 id=\"适配器模式、装饰者模式的区别\"><a href=\"#适配器模式、装饰者模式的区别\" class=\"headerlink\" title=\"适配器模式、装饰者模式的区别\"></a>适配器模式、装饰者模式的区别</h2>","site":{"data":{}},"excerpt":"<h2 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h2><p>设计原则：要依赖抽象，不要依赖具体类</p>\n<p>避免违反依赖倒置原则的建议：</p>\n<blockquote>\n<p>变量不可以持有具体类的引用</p>\n<p>不要让类派生自具体类</p>\n<p>不要覆盖基类中已实现的方法</p>\n</blockquote>","more":"<h2 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h2><p>Spring的BeanFactory</p>\n<h2 id=\"建设者模式-生成器模式\"><a href=\"#建设者模式-生成器模式\" class=\"headerlink\" title=\"建设者模式/生成器模式\"></a>建设者模式/生成器模式</h2><p>Spring中BeanDefinitionBuilder</p>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>Spring中ProxyFactoryBean</p>\n<h2 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h2><p>设计原则：针对接口编程，而不是针对实现编程</p>\n<p>spring中MethodNameResolver + ParameterMethodNameResolver</p>\n<h2 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h2><p>Spring中AbstractApplicationCOntext.obtainFreshBeanFactory、refreshBeanFactory、getBeanFactory + GenericApplicationContext</p>\n<h2 id=\"策略、模板、状态3中设计模式的对比\"><a href=\"#策略、模板、状态3中设计模式的对比\" class=\"headerlink\" title=\"策略、模板、状态3中设计模式的对比\"></a>策略、模板、状态3中设计模式的对比</h2><h2 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h2><p>Spring中bean的作用域scope=”prototype”</p>\n<p>优点：</p>\n<p>向客户隐藏制造新实例的复杂性</p>\n<p>提供客户能够产生未知类型实例对象的选项</p>\n<p>在某些环境下，复制对象比创建新对象更有效</p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>Spring中AbstractApplicationContext.addApplicationListener + ApplicationListener + ApplicationEventMulticaster</p>\n<h2 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h2><p>Spring中AOP使用load-time-weaving针对AspectJ、CGLIB使用不同的逻辑</p>\n<h2 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h2><h2 id=\"适配器模式、装饰者模式的区别\"><a href=\"#适配器模式、装饰者模式的区别\" class=\"headerlink\" title=\"适配器模式、装饰者模式的区别\"></a>适配器模式、装饰者模式的区别</h2>"},{"title":"Spring的事务机制","date":"2018-08-06T17:06:03.000Z","_content":"## 事务的7种传播机制 ##\n\nTransactionDefinition接口中定义了7种类型的事务传播机制：\n\nPROPAGATION_REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。**这是最常见的选择，也是 Spring 默认的事务的传播**。\n\nPROPAGATION_REQUIRES_NEW: 新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作\n\nPROPAGATION_SUPPORTS: 支持当前事务，如果当前没有事务，就以非事务方式执行。\n\nPROPAGATION_MANDATORY: 支持当前事务，如果当前没有事务，就抛出异常。\n\nPROPAGATION_NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n\nPROPAGATION_NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常。\n\nPROPAGATION_NESTED   \n\n<!--more -->\n\n## 事务的4种隔离级别 ##\n\nISOLATION_DEFAULT: **PlatfromTransactionManager默认的隔离级别**，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。\n\nISOLATION_READ_UNCOMMITTED: 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。\n\nISOLATION_READ_COMMITTED: 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。可以防止脏读\n\nISOLATION_REPEATABLE_READ: 事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。\n\nISOLATION_SERIALIZABLE: 花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。\n\n## 事务失效的情况 ##\n\n1、MySQL数据表的引擎必须为InnoDB，MyISAM引擎不支持事务\n\n2、调用的类必须是由Spring容器管理的代理类\n\njdk代理\n\ncglib代理\n\n3、调用的方法必须是public方法，这是由Spring的AOP特性决定的\n\n4、抛出runtimeException才能回滚。\n\n事务默认支持CheckException不会滚，unCheckException回滚，如果需要checkException回滚，注解需要标明@Transactional(rollbackFor=Exception.class)\n\n5、事务传播策略在内部方法调用时将不起作用\n\n情景1：\n\n\tpublic void insert2(Person person, Book book){\n        insert(person, book);\n    }\n\n    @Transactional\n    public void insert(Person person, Book book){\n        insertPerson(person);\n\n        insertBook(book);\n    }\n\t\n\tpersonServiceImpl.insert(person, book)事务起作用\n\n\tpersonServiceImpl.insert2(person, book)事务不起作用\n\n解决方案1：\n\n> 增加<aop:config proxy-target-class=\"true\" expose-proxy=\"true\"></aop:config>\n> \n> 在外层调用内层的事务方法时使用AopContext代理 \n  \n\tpublic void insert2(Person person, Book book){\n        ((PersonServiceImpl)AopContext.currentProxy()).insert(person, book);\n    }\n\n解决方案2：\n\n> 增加<aop:config proxy-target-class=\"true\"></aop:config>\n> \n> 在外层调用内层的事务方法时使用Spring的IOC容器代理 \n  \t\n\t@Autowired\n    private ApplicationContext ctx;\n\n\tpublic void insert2(Person person, Book book){\n        ctx.getBean(PersonServiceImpl.class).insert(person, book);;\n    }","source":"_posts/spring-transaction.md","raw":"---\ntitle: Spring的事务机制\ndate: 2018-08-07 01:06:03\ntags: spring, 事务\ncategories: spring\n---\n## 事务的7种传播机制 ##\n\nTransactionDefinition接口中定义了7种类型的事务传播机制：\n\nPROPAGATION_REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。**这是最常见的选择，也是 Spring 默认的事务的传播**。\n\nPROPAGATION_REQUIRES_NEW: 新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作\n\nPROPAGATION_SUPPORTS: 支持当前事务，如果当前没有事务，就以非事务方式执行。\n\nPROPAGATION_MANDATORY: 支持当前事务，如果当前没有事务，就抛出异常。\n\nPROPAGATION_NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n\nPROPAGATION_NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常。\n\nPROPAGATION_NESTED   \n\n<!--more -->\n\n## 事务的4种隔离级别 ##\n\nISOLATION_DEFAULT: **PlatfromTransactionManager默认的隔离级别**，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。\n\nISOLATION_READ_UNCOMMITTED: 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。\n\nISOLATION_READ_COMMITTED: 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。可以防止脏读\n\nISOLATION_REPEATABLE_READ: 事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。\n\nISOLATION_SERIALIZABLE: 花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。\n\n## 事务失效的情况 ##\n\n1、MySQL数据表的引擎必须为InnoDB，MyISAM引擎不支持事务\n\n2、调用的类必须是由Spring容器管理的代理类\n\njdk代理\n\ncglib代理\n\n3、调用的方法必须是public方法，这是由Spring的AOP特性决定的\n\n4、抛出runtimeException才能回滚。\n\n事务默认支持CheckException不会滚，unCheckException回滚，如果需要checkException回滚，注解需要标明@Transactional(rollbackFor=Exception.class)\n\n5、事务传播策略在内部方法调用时将不起作用\n\n情景1：\n\n\tpublic void insert2(Person person, Book book){\n        insert(person, book);\n    }\n\n    @Transactional\n    public void insert(Person person, Book book){\n        insertPerson(person);\n\n        insertBook(book);\n    }\n\t\n\tpersonServiceImpl.insert(person, book)事务起作用\n\n\tpersonServiceImpl.insert2(person, book)事务不起作用\n\n解决方案1：\n\n> 增加<aop:config proxy-target-class=\"true\" expose-proxy=\"true\"></aop:config>\n> \n> 在外层调用内层的事务方法时使用AopContext代理 \n  \n\tpublic void insert2(Person person, Book book){\n        ((PersonServiceImpl)AopContext.currentProxy()).insert(person, book);\n    }\n\n解决方案2：\n\n> 增加<aop:config proxy-target-class=\"true\"></aop:config>\n> \n> 在外层调用内层的事务方法时使用Spring的IOC容器代理 \n  \t\n\t@Autowired\n    private ApplicationContext ctx;\n\n\tpublic void insert2(Person person, Book book){\n        ctx.getBean(PersonServiceImpl.class).insert(person, book);;\n    }","slug":"spring-transaction","published":1,"updated":"2018-08-07T13:52:35.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde2w002ev0f0ajgt5gal","content":"<h2 id=\"事务的7种传播机制\"><a href=\"#事务的7种传播机制\" class=\"headerlink\" title=\"事务的7种传播机制\"></a>事务的7种传播机制</h2><p>TransactionDefinition接口中定义了7种类型的事务传播机制：</p>\n<p>PROPAGATION_REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。<strong>这是最常见的选择，也是 Spring 默认的事务的传播</strong>。</p>\n<p>PROPAGATION_REQUIRES_NEW: 新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作</p>\n<p>PROPAGATION_SUPPORTS: 支持当前事务，如果当前没有事务，就以非事务方式执行。</p>\n<p>PROPAGATION_MANDATORY: 支持当前事务，如果当前没有事务，就抛出异常。</p>\n<p>PROPAGATION_NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>\n<p>PROPAGATION_NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常。</p>\n<p>PROPAGATION_NESTED   </p>\n<a id=\"more\"></a>\n<h2 id=\"事务的4种隔离级别\"><a href=\"#事务的4种隔离级别\" class=\"headerlink\" title=\"事务的4种隔离级别\"></a>事务的4种隔离级别</h2><p>ISOLATION_DEFAULT: <strong>PlatfromTransactionManager默认的隔离级别</strong>，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。</p>\n<p>ISOLATION_READ_UNCOMMITTED: 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</p>\n<p>ISOLATION_READ_COMMITTED: 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。可以防止脏读</p>\n<p>ISOLATION_REPEATABLE_READ: 事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</p>\n<p>ISOLATION_SERIALIZABLE: 花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</p>\n<h2 id=\"事务失效的情况\"><a href=\"#事务失效的情况\" class=\"headerlink\" title=\"事务失效的情况\"></a>事务失效的情况</h2><p>1、MySQL数据表的引擎必须为InnoDB，MyISAM引擎不支持事务</p>\n<p>2、调用的类必须是由Spring容器管理的代理类</p>\n<p>jdk代理</p>\n<p>cglib代理</p>\n<p>3、调用的方法必须是public方法，这是由Spring的AOP特性决定的</p>\n<p>4、抛出runtimeException才能回滚。</p>\n<p>事务默认支持CheckException不会滚，unCheckException回滚，如果需要checkException回滚，注解需要标明@Transactional(rollbackFor=Exception.class)</p>\n<p>5、事务传播策略在内部方法调用时将不起作用</p>\n<p>情景1：</p>\n<pre><code>public void insert2(Person person, Book book){\n    insert(person, book);\n}\n\n@Transactional\npublic void insert(Person person, Book book){\n    insertPerson(person);\n\n    insertBook(book);\n}\n\npersonServiceImpl.insert(person, book)事务起作用\n\npersonServiceImpl.insert2(person, book)事务不起作用\n</code></pre><p>解决方案1：</p>\n<blockquote>\n<p>增加&lt;aop:config proxy-target-class=”true” expose-proxy=”true”&gt;&lt;/aop:config&gt;</p>\n<p>在外层调用内层的事务方法时使用AopContext代理 </p>\n</blockquote>\n<pre><code>public void insert2(Person person, Book book){\n    ((PersonServiceImpl)AopContext.currentProxy()).insert(person, book);\n}\n</code></pre><p>解决方案2：</p>\n<blockquote>\n<p>增加&lt;aop:config proxy-target-class=”true”&gt;&lt;/aop:config&gt;</p>\n<p>在外层调用内层的事务方法时使用Spring的IOC容器代理 </p>\n</blockquote>\n<pre><code>@Autowired\nprivate ApplicationContext ctx;\n\npublic void insert2(Person person, Book book){\n    ctx.getBean(PersonServiceImpl.class).insert(person, book);;\n}\n</code></pre>","site":{"data":{}},"excerpt":"<h2 id=\"事务的7种传播机制\"><a href=\"#事务的7种传播机制\" class=\"headerlink\" title=\"事务的7种传播机制\"></a>事务的7种传播机制</h2><p>TransactionDefinition接口中定义了7种类型的事务传播机制：</p>\n<p>PROPAGATION_REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。<strong>这是最常见的选择，也是 Spring 默认的事务的传播</strong>。</p>\n<p>PROPAGATION_REQUIRES_NEW: 新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作</p>\n<p>PROPAGATION_SUPPORTS: 支持当前事务，如果当前没有事务，就以非事务方式执行。</p>\n<p>PROPAGATION_MANDATORY: 支持当前事务，如果当前没有事务，就抛出异常。</p>\n<p>PROPAGATION_NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>\n<p>PROPAGATION_NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常。</p>\n<p>PROPAGATION_NESTED   </p>","more":"<h2 id=\"事务的4种隔离级别\"><a href=\"#事务的4种隔离级别\" class=\"headerlink\" title=\"事务的4种隔离级别\"></a>事务的4种隔离级别</h2><p>ISOLATION_DEFAULT: <strong>PlatfromTransactionManager默认的隔离级别</strong>，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。</p>\n<p>ISOLATION_READ_UNCOMMITTED: 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</p>\n<p>ISOLATION_READ_COMMITTED: 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。可以防止脏读</p>\n<p>ISOLATION_REPEATABLE_READ: 事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</p>\n<p>ISOLATION_SERIALIZABLE: 花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</p>\n<h2 id=\"事务失效的情况\"><a href=\"#事务失效的情况\" class=\"headerlink\" title=\"事务失效的情况\"></a>事务失效的情况</h2><p>1、MySQL数据表的引擎必须为InnoDB，MyISAM引擎不支持事务</p>\n<p>2、调用的类必须是由Spring容器管理的代理类</p>\n<p>jdk代理</p>\n<p>cglib代理</p>\n<p>3、调用的方法必须是public方法，这是由Spring的AOP特性决定的</p>\n<p>4、抛出runtimeException才能回滚。</p>\n<p>事务默认支持CheckException不会滚，unCheckException回滚，如果需要checkException回滚，注解需要标明@Transactional(rollbackFor=Exception.class)</p>\n<p>5、事务传播策略在内部方法调用时将不起作用</p>\n<p>情景1：</p>\n<pre><code>public void insert2(Person person, Book book){\n    insert(person, book);\n}\n\n@Transactional\npublic void insert(Person person, Book book){\n    insertPerson(person);\n\n    insertBook(book);\n}\n\npersonServiceImpl.insert(person, book)事务起作用\n\npersonServiceImpl.insert2(person, book)事务不起作用\n</code></pre><p>解决方案1：</p>\n<blockquote>\n<p>增加&lt;aop:config proxy-target-class=”true” expose-proxy=”true”&gt;&lt;/aop:config&gt;</p>\n<p>在外层调用内层的事务方法时使用AopContext代理 </p>\n</blockquote>\n<pre><code>public void insert2(Person person, Book book){\n    ((PersonServiceImpl)AopContext.currentProxy()).insert(person, book);\n}\n</code></pre><p>解决方案2：</p>\n<blockquote>\n<p>增加&lt;aop:config proxy-target-class=”true”&gt;&lt;/aop:config&gt;</p>\n<p>在外层调用内层的事务方法时使用Spring的IOC容器代理 </p>\n</blockquote>\n<pre><code>@Autowired\nprivate ApplicationContext ctx;\n\npublic void insert2(Person person, Book book){\n    ctx.getBean(PersonServiceImpl.class).insert(person, book);;\n}\n</code></pre>"},{"title":"spring bean分析","date":"2018-08-13T13:34:09.000Z","_content":"Spring的东西有很多不经常用，就会忘记，还是要多记录一下。其实bean这一块儿有很多的东西要梳理，以后慢慢还债\n\n\n<!-- more -->\n\n## bean生命周期 ##\n\n1. 实例化BeanFactoryPostProcessor实现类; \n2. BeanFactoryPostProcessor#postProcessBeanFactory();\n3. 实例化BeanPostProcessor实现类\n4. 实例化InstantiationAwareBeanPostProcessorAdapter实现类\n5. InstantiationAwareBeanPostProcessorAdapter#postProcessBeforeInstatiation()\n6. bean构造器\n6. InstantiationAwareBeanPostProcessorAdapter#postProcessPropertyValues()\n7. bean设置属性值; \n8. 如果实现了BeanNameAware接口,调用setBeanName设置Bean的ID或者Name; \n9. 如果实现BeanFactoryAware接口,调用setBeanFactory 设置BeanFactory; \n10. 如果实现ApplicationContextAware,调用setApplicationContext设置ApplicationContext \n11. 调用BeanPostProcessor#postProcessBeforeInitialization(); \n12. 调用InitializingBean#afterPropertiesSet(); \n13. 调用bean属性中设置的init-method方法； \n14. 调用BeanPostProcessor#postProcessAfterInitialization();\n15. InstantiationAwareBeanPostProcessorAdapter#postProcessAfterInstatiation()\n\nDiposibelBean#destroy()\n执行bean属性中设置的destroy-method方法\n\n\n\n## 多bean加载顺序 ##\n1. xml配置的bean优先于注解bean\n2. 优先加载BeanPostProcessor实现的bean; \n3. 按bean文件(例如import标签)和bean的定义顺序装载,\n4. 如果顺序执行中，beanA通过属性ref引用别的beanB，加载完beanA后，加载beanB，然后再顺序执行\n5. 如果beanA属性中depen-on依赖beanB，则会优先装载beanB，然后装载beanA，然后顺序装载\n6. BeanFactoryUtils类也会改变Bean的加载顺序","source":"_posts/spring-bean.md","raw":"---\ntitle: spring bean分析\ndate: 2018-08-13 21:34:09\ntags:\n---\nSpring的东西有很多不经常用，就会忘记，还是要多记录一下。其实bean这一块儿有很多的东西要梳理，以后慢慢还债\n\n\n<!-- more -->\n\n## bean生命周期 ##\n\n1. 实例化BeanFactoryPostProcessor实现类; \n2. BeanFactoryPostProcessor#postProcessBeanFactory();\n3. 实例化BeanPostProcessor实现类\n4. 实例化InstantiationAwareBeanPostProcessorAdapter实现类\n5. InstantiationAwareBeanPostProcessorAdapter#postProcessBeforeInstatiation()\n6. bean构造器\n6. InstantiationAwareBeanPostProcessorAdapter#postProcessPropertyValues()\n7. bean设置属性值; \n8. 如果实现了BeanNameAware接口,调用setBeanName设置Bean的ID或者Name; \n9. 如果实现BeanFactoryAware接口,调用setBeanFactory 设置BeanFactory; \n10. 如果实现ApplicationContextAware,调用setApplicationContext设置ApplicationContext \n11. 调用BeanPostProcessor#postProcessBeforeInitialization(); \n12. 调用InitializingBean#afterPropertiesSet(); \n13. 调用bean属性中设置的init-method方法； \n14. 调用BeanPostProcessor#postProcessAfterInitialization();\n15. InstantiationAwareBeanPostProcessorAdapter#postProcessAfterInstatiation()\n\nDiposibelBean#destroy()\n执行bean属性中设置的destroy-method方法\n\n\n\n## 多bean加载顺序 ##\n1. xml配置的bean优先于注解bean\n2. 优先加载BeanPostProcessor实现的bean; \n3. 按bean文件(例如import标签)和bean的定义顺序装载,\n4. 如果顺序执行中，beanA通过属性ref引用别的beanB，加载完beanA后，加载beanB，然后再顺序执行\n5. 如果beanA属性中depen-on依赖beanB，则会优先装载beanB，然后装载beanA，然后顺序装载\n6. BeanFactoryUtils类也会改变Bean的加载顺序","slug":"spring-bean","published":1,"updated":"2018-08-13T15:10:23.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde30002iv0f06s5xmsy8","content":"<p>Spring的东西有很多不经常用，就会忘记，还是要多记录一下。其实bean这一块儿有很多的东西要梳理，以后慢慢还债</p>\n<a id=\"more\"></a>\n<h2 id=\"bean生命周期\"><a href=\"#bean生命周期\" class=\"headerlink\" title=\"bean生命周期\"></a>bean生命周期</h2><ol>\n<li>实例化BeanFactoryPostProcessor实现类; </li>\n<li>BeanFactoryPostProcessor#postProcessBeanFactory();</li>\n<li>实例化BeanPostProcessor实现类</li>\n<li>实例化InstantiationAwareBeanPostProcessorAdapter实现类</li>\n<li>InstantiationAwareBeanPostProcessorAdapter#postProcessBeforeInstatiation()</li>\n<li>bean构造器</li>\n<li>InstantiationAwareBeanPostProcessorAdapter#postProcessPropertyValues()</li>\n<li>bean设置属性值; </li>\n<li>如果实现了BeanNameAware接口,调用setBeanName设置Bean的ID或者Name; </li>\n<li>如果实现BeanFactoryAware接口,调用setBeanFactory 设置BeanFactory; </li>\n<li>如果实现ApplicationContextAware,调用setApplicationContext设置ApplicationContext </li>\n<li>调用BeanPostProcessor#postProcessBeforeInitialization(); </li>\n<li>调用InitializingBean#afterPropertiesSet(); </li>\n<li>调用bean属性中设置的init-method方法； </li>\n<li>调用BeanPostProcessor#postProcessAfterInitialization();</li>\n<li>InstantiationAwareBeanPostProcessorAdapter#postProcessAfterInstatiation()</li>\n</ol>\n<p>DiposibelBean#destroy()<br>执行bean属性中设置的destroy-method方法</p>\n<h2 id=\"多bean加载顺序\"><a href=\"#多bean加载顺序\" class=\"headerlink\" title=\"多bean加载顺序\"></a>多bean加载顺序</h2><ol>\n<li>xml配置的bean优先于注解bean</li>\n<li>优先加载BeanPostProcessor实现的bean; </li>\n<li>按bean文件(例如import标签)和bean的定义顺序装载,</li>\n<li>如果顺序执行中，beanA通过属性ref引用别的beanB，加载完beanA后，加载beanB，然后再顺序执行</li>\n<li>如果beanA属性中depen-on依赖beanB，则会优先装载beanB，然后装载beanA，然后顺序装载</li>\n<li>BeanFactoryUtils类也会改变Bean的加载顺序</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Spring的东西有很多不经常用，就会忘记，还是要多记录一下。其实bean这一块儿有很多的东西要梳理，以后慢慢还债</p>","more":"<h2 id=\"bean生命周期\"><a href=\"#bean生命周期\" class=\"headerlink\" title=\"bean生命周期\"></a>bean生命周期</h2><ol>\n<li>实例化BeanFactoryPostProcessor实现类; </li>\n<li>BeanFactoryPostProcessor#postProcessBeanFactory();</li>\n<li>实例化BeanPostProcessor实现类</li>\n<li>实例化InstantiationAwareBeanPostProcessorAdapter实现类</li>\n<li>InstantiationAwareBeanPostProcessorAdapter#postProcessBeforeInstatiation()</li>\n<li>bean构造器</li>\n<li>InstantiationAwareBeanPostProcessorAdapter#postProcessPropertyValues()</li>\n<li>bean设置属性值; </li>\n<li>如果实现了BeanNameAware接口,调用setBeanName设置Bean的ID或者Name; </li>\n<li>如果实现BeanFactoryAware接口,调用setBeanFactory 设置BeanFactory; </li>\n<li>如果实现ApplicationContextAware,调用setApplicationContext设置ApplicationContext </li>\n<li>调用BeanPostProcessor#postProcessBeforeInitialization(); </li>\n<li>调用InitializingBean#afterPropertiesSet(); </li>\n<li>调用bean属性中设置的init-method方法； </li>\n<li>调用BeanPostProcessor#postProcessAfterInitialization();</li>\n<li>InstantiationAwareBeanPostProcessorAdapter#postProcessAfterInstatiation()</li>\n</ol>\n<p>DiposibelBean#destroy()<br>执行bean属性中设置的destroy-method方法</p>\n<h2 id=\"多bean加载顺序\"><a href=\"#多bean加载顺序\" class=\"headerlink\" title=\"多bean加载顺序\"></a>多bean加载顺序</h2><ol>\n<li>xml配置的bean优先于注解bean</li>\n<li>优先加载BeanPostProcessor实现的bean; </li>\n<li>按bean文件(例如import标签)和bean的定义顺序装载,</li>\n<li>如果顺序执行中，beanA通过属性ref引用别的beanB，加载完beanA后，加载beanB，然后再顺序执行</li>\n<li>如果beanA属性中depen-on依赖beanB，则会优先装载beanB，然后装载beanA，然后顺序装载</li>\n<li>BeanFactoryUtils类也会改变Bean的加载顺序</li>\n</ol>"},{"title":"Spring boot注解自动装配原理分析","date":"2018-07-12T02:34:03.000Z","_content":"熟悉Spring Boot项目搭建的同学都知道基本的配置。\n\n首先看Application main类需要基本的注解@SpringBootApplication：\n\n\t@RestController\n\t@SpringBootApplication\n\tpublic class AutoconfigDemoTestApplication {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tSpringApplication.run(AutoconfigDemoTestApplication.class, args);\n\t\t}\n\t}\n\n<!-- more -->\n\n进入@SpringBootApplication可以看到：\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\t@Inherited\n\t@SpringBootConfiguration\n\t@EnableAutoConfiguration\n\t@ComponentScan(excludeFilters = {\n\t\t\t@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\n\tpublic @interface SpringBootApplication {\n\t\n\t}\n\n除去基本的元注解，进入@SpringBootConfiguration，可以看到是一些基本的注解：\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\t@Configuration\n\tpublic @interface SpringBootConfiguration {\n\t\n\t}\n\n进入注解@EnableAutoConfiguration，可以看到除了注解@AutoConfigurationPackage，还有一个@Import(AutoConfigurationImportSelector.class)：\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\t@Inherited\n\t@AutoConfigurationPackage\n\t@Import(AutoConfigurationImportSelector.class)\n\tpublic @interface EnableAutoConfiguration {\n\t\n\t\tString ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\t\n\t\t//\n\t\tClass<?>[] exclude() default {};\n\t\n\t\t//\n\t\tString[] excludeName() default {};\n\t\n\t}\n\n@AutoConfigurationPackage是一些：\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\t@Inherited\n\t@Import(AutoConfigurationPackages.Registrar.class)\n\tpublic @interface AutoConfigurationPackage {\n\t\n\t}\n\n进入AutoConfigurationImportSelector类，可以看到方法selectImports来确定要导入的类：\n\n\t@Override\n\tpublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n\t\tif (!isEnabled(annotationMetadata)) {\n\t\t\treturn NO_IMPORTS;\n\t\t}\n\t\t// 加载\"META-INF/spring-autoconfigure-metadata.properties\"\n\t\tAutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n\t\t\t\t.loadMetadata(this.beanClassLoader);\n\t\t//\n\t\tAnnotationAttributes attributes = getAttributes(annotationMetadata);\n\t\tList<String> configurations = getCandidateConfigurations(annotationMetadata,\n\t\t\t\tattributes);\n\t\tconfigurations = removeDuplicates(configurations);\n\t\tSet<String> exclusions = getExclusions(annotationMetadata, attributes);\n\t\tcheckExcludedClasses(configurations, exclusions);\n\t\tconfigurations.removeAll(exclusions);\n\t\tconfigurations = filter(configurations, autoConfigurationMetadata);\n\t\tfireAutoConfigurationImportEvents(configurations, exclusions);\n\t\treturn StringUtils.toStringArray(configurations);\n\t}\n\n先看方法getCandidateConfigurations，回头有时间再慢慢分析其它方法：\n\tprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata,\n\t\t\tAnnotationAttributes attributes) {\n\t\tList<String> configurations = SpringFactoriesLoader.loadFactoryNames(\n\t\t\t\tgetSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());\n\t\tAssert.notEmpty(configurations,\n\t\t\t\t\"No auto configuration classes found in META-INF/spring.factories. If you \"\n\t\t\t\t\t\t+ \"are using a custom packaging, make sure that file is correct.\");\n\t\treturn configurations;\n\t}\n\n再看SpringFactoriesLoader.loadFactoryNames，可以知道最终读取的是所有jar包META-INF目录下的spring.factories文件：\n\tpublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n\n\tpublic static List<String> loadFactoryNames(Class<?> factoryClass, @Nullable ClassLoader classLoader) {\n\t\tString factoryClassName = factoryClass.getName();\n\t\treturn loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());\n\t}\n\n\tprivate static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {\n\t\tMultiValueMap<String, String> result = cache.get(classLoader);\n\t\tif (result != null) {\n\t\t\treturn result;\n\t\t}\n\n\t\ttry {\n\t\t\tEnumeration<URL> urls = (classLoader != null ?\n\t\t\t\t\tclassLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n\t\t\t\t\tClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n\t\t\tresult = new LinkedMultiValueMap<>();\n\t\t\twhile (urls.hasMoreElements()) {\n\t\t\t\tURL url = urls.nextElement();\n\t\t\t\tUrlResource resource = new UrlResource(url);\n\t\t\t\tProperties properties = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t\tfor (Map.Entry<?, ?> entry : properties.entrySet()) {\n\t\t\t\t\tList<String> factoryClassNames = Arrays.asList(\n\t\t\t\t\t\t\tStringUtils.commaDelimitedListToStringArray((String) entry.getValue()));\n\t\t\t\t\tresult.addAll((String) entry.getKey(), factoryClassNames);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcache.put(classLoader, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to load factories from location [\" +\n\t\t\t\t\tFACTORIES_RESOURCE_LOCATION + \"]\", ex);\n\t\t}\n\t}","source":"_posts/spring-boot-1.md","raw":"---\ntitle: Spring boot注解自动装配原理分析\ndate: 2018-07-12 10:34:03\ntags: java, springboot, 源码\ncategories: java\n---\n熟悉Spring Boot项目搭建的同学都知道基本的配置。\n\n首先看Application main类需要基本的注解@SpringBootApplication：\n\n\t@RestController\n\t@SpringBootApplication\n\tpublic class AutoconfigDemoTestApplication {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tSpringApplication.run(AutoconfigDemoTestApplication.class, args);\n\t\t}\n\t}\n\n<!-- more -->\n\n进入@SpringBootApplication可以看到：\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\t@Inherited\n\t@SpringBootConfiguration\n\t@EnableAutoConfiguration\n\t@ComponentScan(excludeFilters = {\n\t\t\t@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\n\tpublic @interface SpringBootApplication {\n\t\n\t}\n\n除去基本的元注解，进入@SpringBootConfiguration，可以看到是一些基本的注解：\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\t@Configuration\n\tpublic @interface SpringBootConfiguration {\n\t\n\t}\n\n进入注解@EnableAutoConfiguration，可以看到除了注解@AutoConfigurationPackage，还有一个@Import(AutoConfigurationImportSelector.class)：\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\t@Inherited\n\t@AutoConfigurationPackage\n\t@Import(AutoConfigurationImportSelector.class)\n\tpublic @interface EnableAutoConfiguration {\n\t\n\t\tString ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\t\n\t\t//\n\t\tClass<?>[] exclude() default {};\n\t\n\t\t//\n\t\tString[] excludeName() default {};\n\t\n\t}\n\n@AutoConfigurationPackage是一些：\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\t@Inherited\n\t@Import(AutoConfigurationPackages.Registrar.class)\n\tpublic @interface AutoConfigurationPackage {\n\t\n\t}\n\n进入AutoConfigurationImportSelector类，可以看到方法selectImports来确定要导入的类：\n\n\t@Override\n\tpublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n\t\tif (!isEnabled(annotationMetadata)) {\n\t\t\treturn NO_IMPORTS;\n\t\t}\n\t\t// 加载\"META-INF/spring-autoconfigure-metadata.properties\"\n\t\tAutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n\t\t\t\t.loadMetadata(this.beanClassLoader);\n\t\t//\n\t\tAnnotationAttributes attributes = getAttributes(annotationMetadata);\n\t\tList<String> configurations = getCandidateConfigurations(annotationMetadata,\n\t\t\t\tattributes);\n\t\tconfigurations = removeDuplicates(configurations);\n\t\tSet<String> exclusions = getExclusions(annotationMetadata, attributes);\n\t\tcheckExcludedClasses(configurations, exclusions);\n\t\tconfigurations.removeAll(exclusions);\n\t\tconfigurations = filter(configurations, autoConfigurationMetadata);\n\t\tfireAutoConfigurationImportEvents(configurations, exclusions);\n\t\treturn StringUtils.toStringArray(configurations);\n\t}\n\n先看方法getCandidateConfigurations，回头有时间再慢慢分析其它方法：\n\tprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata,\n\t\t\tAnnotationAttributes attributes) {\n\t\tList<String> configurations = SpringFactoriesLoader.loadFactoryNames(\n\t\t\t\tgetSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());\n\t\tAssert.notEmpty(configurations,\n\t\t\t\t\"No auto configuration classes found in META-INF/spring.factories. If you \"\n\t\t\t\t\t\t+ \"are using a custom packaging, make sure that file is correct.\");\n\t\treturn configurations;\n\t}\n\n再看SpringFactoriesLoader.loadFactoryNames，可以知道最终读取的是所有jar包META-INF目录下的spring.factories文件：\n\tpublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n\n\tpublic static List<String> loadFactoryNames(Class<?> factoryClass, @Nullable ClassLoader classLoader) {\n\t\tString factoryClassName = factoryClass.getName();\n\t\treturn loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());\n\t}\n\n\tprivate static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {\n\t\tMultiValueMap<String, String> result = cache.get(classLoader);\n\t\tif (result != null) {\n\t\t\treturn result;\n\t\t}\n\n\t\ttry {\n\t\t\tEnumeration<URL> urls = (classLoader != null ?\n\t\t\t\t\tclassLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n\t\t\t\t\tClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n\t\t\tresult = new LinkedMultiValueMap<>();\n\t\t\twhile (urls.hasMoreElements()) {\n\t\t\t\tURL url = urls.nextElement();\n\t\t\t\tUrlResource resource = new UrlResource(url);\n\t\t\t\tProperties properties = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t\tfor (Map.Entry<?, ?> entry : properties.entrySet()) {\n\t\t\t\t\tList<String> factoryClassNames = Arrays.asList(\n\t\t\t\t\t\t\tStringUtils.commaDelimitedListToStringArray((String) entry.getValue()));\n\t\t\t\t\tresult.addAll((String) entry.getKey(), factoryClassNames);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcache.put(classLoader, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to load factories from location [\" +\n\t\t\t\t\tFACTORIES_RESOURCE_LOCATION + \"]\", ex);\n\t\t}\n\t}","slug":"spring-boot-1","published":1,"updated":"2018-08-13T13:33:51.017Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde33002lv0f0c0h4nnzr","content":"<p>熟悉Spring Boot项目搭建的同学都知道基本的配置。</p>\n<p>首先看Application main类需要基本的注解@SpringBootApplication：</p>\n<pre><code>@RestController\n@SpringBootApplication\npublic class AutoconfigDemoTestApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AutoconfigDemoTestApplication.class, args);\n    }\n}\n</code></pre><a id=\"more\"></a>\n<p>进入@SpringBootApplication可以看到：</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n\n}\n</code></pre><p>除去基本的元注解，进入@SpringBootConfiguration，可以看到是一些基本的注解：</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\npublic @interface SpringBootConfiguration {\n\n}\n</code></pre><p>进入注解@EnableAutoConfiguration，可以看到除了注解@AutoConfigurationPackage，还有一个@Import(AutoConfigurationImportSelector.class)：</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n\n    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;\n\n    //\n    Class&lt;?&gt;[] exclude() default {};\n\n    //\n    String[] excludeName() default {};\n\n}\n</code></pre><p>@AutoConfigurationPackage是一些：</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Import(AutoConfigurationPackages.Registrar.class)\npublic @interface AutoConfigurationPackage {\n\n}\n</code></pre><p>进入AutoConfigurationImportSelector类，可以看到方法selectImports来确定要导入的类：</p>\n<pre><code>@Override\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n    if (!isEnabled(annotationMetadata)) {\n        return NO_IMPORTS;\n    }\n    // 加载&quot;META-INF/spring-autoconfigure-metadata.properties&quot;\n    AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n            .loadMetadata(this.beanClassLoader);\n    //\n    AnnotationAttributes attributes = getAttributes(annotationMetadata);\n    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,\n            attributes);\n    configurations = removeDuplicates(configurations);\n    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);\n    checkExcludedClasses(configurations, exclusions);\n    configurations.removeAll(exclusions);\n    configurations = filter(configurations, autoConfigurationMetadata);\n    fireAutoConfigurationImportEvents(configurations, exclusions);\n    return StringUtils.toStringArray(configurations);\n}\n</code></pre><p>先看方法getCandidateConfigurations，回头有时间再慢慢分析其它方法：<br>    protected List<string> getCandidateConfigurations(AnnotationMetadata metadata,<br>            AnnotationAttributes attributes) {<br>        List<string> configurations = SpringFactoriesLoader.loadFactoryNames(<br>                getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());<br>        Assert.notEmpty(configurations,<br>                “No auto configuration classes found in META-INF/spring.factories. If you “</string></string></p>\n<pre><code>                    + &quot;are using a custom packaging, make sure that file is correct.&quot;);\n    return configurations;\n}\n</code></pre><p>再看SpringFactoriesLoader.loadFactoryNames，可以知道最终读取的是所有jar包META-INF目录下的spring.factories文件：<br>    public static final String FACTORIES_RESOURCE_LOCATION = “META-INF/spring.factories”;</p>\n<pre><code>public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {\n    String factoryClassName = factoryClass.getName();\n    return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());\n}\n\nprivate static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {\n    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);\n    if (result != null) {\n        return result;\n    }\n\n    try {\n        Enumeration&lt;URL&gt; urls = (classLoader != null ?\n                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n        result = new LinkedMultiValueMap&lt;&gt;();\n        while (urls.hasMoreElements()) {\n            URL url = urls.nextElement();\n            UrlResource resource = new UrlResource(url);\n            Properties properties = PropertiesLoaderUtils.loadProperties(resource);\n            for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {\n                List&lt;String&gt; factoryClassNames = Arrays.asList(\n                        StringUtils.commaDelimitedListToStringArray((String) entry.getValue()));\n                result.addAll((String) entry.getKey(), factoryClassNames);\n            }\n        }\n        cache.put(classLoader, result);\n        return result;\n    }\n    catch (IOException ex) {\n        throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +\n                FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"<p>熟悉Spring Boot项目搭建的同学都知道基本的配置。</p>\n<p>首先看Application main类需要基本的注解@SpringBootApplication：</p>\n<pre><code>@RestController\n@SpringBootApplication\npublic class AutoconfigDemoTestApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AutoconfigDemoTestApplication.class, args);\n    }\n}\n</code></pre>","more":"<p>进入@SpringBootApplication可以看到：</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n\n}\n</code></pre><p>除去基本的元注解，进入@SpringBootConfiguration，可以看到是一些基本的注解：</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\npublic @interface SpringBootConfiguration {\n\n}\n</code></pre><p>进入注解@EnableAutoConfiguration，可以看到除了注解@AutoConfigurationPackage，还有一个@Import(AutoConfigurationImportSelector.class)：</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n\n    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;\n\n    //\n    Class&lt;?&gt;[] exclude() default {};\n\n    //\n    String[] excludeName() default {};\n\n}\n</code></pre><p>@AutoConfigurationPackage是一些：</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Import(AutoConfigurationPackages.Registrar.class)\npublic @interface AutoConfigurationPackage {\n\n}\n</code></pre><p>进入AutoConfigurationImportSelector类，可以看到方法selectImports来确定要导入的类：</p>\n<pre><code>@Override\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n    if (!isEnabled(annotationMetadata)) {\n        return NO_IMPORTS;\n    }\n    // 加载&quot;META-INF/spring-autoconfigure-metadata.properties&quot;\n    AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n            .loadMetadata(this.beanClassLoader);\n    //\n    AnnotationAttributes attributes = getAttributes(annotationMetadata);\n    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,\n            attributes);\n    configurations = removeDuplicates(configurations);\n    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);\n    checkExcludedClasses(configurations, exclusions);\n    configurations.removeAll(exclusions);\n    configurations = filter(configurations, autoConfigurationMetadata);\n    fireAutoConfigurationImportEvents(configurations, exclusions);\n    return StringUtils.toStringArray(configurations);\n}\n</code></pre><p>先看方法getCandidateConfigurations，回头有时间再慢慢分析其它方法：<br>    protected List<string> getCandidateConfigurations(AnnotationMetadata metadata,<br>            AnnotationAttributes attributes) {<br>        List<string> configurations = SpringFactoriesLoader.loadFactoryNames(<br>                getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());<br>        Assert.notEmpty(configurations,<br>                “No auto configuration classes found in META-INF/spring.factories. If you “</string></string></p>\n<pre><code>                    + &quot;are using a custom packaging, make sure that file is correct.&quot;);\n    return configurations;\n}\n</code></pre><p>再看SpringFactoriesLoader.loadFactoryNames，可以知道最终读取的是所有jar包META-INF目录下的spring.factories文件：<br>    public static final String FACTORIES_RESOURCE_LOCATION = “META-INF/spring.factories”;</p>\n<pre><code>public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {\n    String factoryClassName = factoryClass.getName();\n    return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());\n}\n\nprivate static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {\n    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);\n    if (result != null) {\n        return result;\n    }\n\n    try {\n        Enumeration&lt;URL&gt; urls = (classLoader != null ?\n                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n        result = new LinkedMultiValueMap&lt;&gt;();\n        while (urls.hasMoreElements()) {\n            URL url = urls.nextElement();\n            UrlResource resource = new UrlResource(url);\n            Properties properties = PropertiesLoaderUtils.loadProperties(resource);\n            for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {\n                List&lt;String&gt; factoryClassNames = Arrays.asList(\n                        StringUtils.commaDelimitedListToStringArray((String) entry.getValue()));\n                result.addAll((String) entry.getKey(), factoryClassNames);\n            }\n        }\n        cache.put(classLoader, result);\n        return result;\n    }\n    catch (IOException ex) {\n        throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +\n                FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);\n    }\n}\n</code></pre>"},{"title":"村上春树和三毛","date":"2018-08-08T15:09:46.000Z","_content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=410161216&auto=1&height=66\"></iframe>\n\n不知道是因为下雨的原因，还是立秋的原因，今天走出门口，感觉凉凉的，有一点秋天的感觉。我想，也许有两者都有吧。然后赶往另一个地方，不经意间，就想起杨宗纬，想起村上春树，想起三毛。\n\n<!-- more -->\n\n想想自己来京一年多的时间里，自从去年在春雪未化的时候一个人去了碓臼峪，秋天去了中华民族园，去了香山。已经很久没有认真看过这个城市，正好搭公交去另一个地方。车上的人很少，大多是已上年纪的“老头”、“老太太”，依然选一个靠窗的位置坐下，开始百无聊赖的看窗外的故事。\n\n窗外有三三两两骑着电动车带小孩子的母亲，我想附近应该是有个学校吧，男孩儿背着书包，安安静静的拉着母亲的衣角，倒是女孩儿显得有点调皮，东张西望的样子，又显得有点可爱。心里暗自在想，如果可以永远当一个长不大的孩子，永远没有烦恼该多好。一会儿，上来一位奶爸，抱着两三岁的女儿，一副很学究气的眼镜，给人一种学者的印象，运动休闲短裤，脚上是休闲的凉鞋，手上爆凸的青筋，正好坐在我的邻座，一路上爸爸和女儿有的没的说话，女儿一概不理，我想，假如有女本柔弱，为母则刚的话，这一定是男本刚强，为父则柔吧，心中顿生温暖。\"静安庄到了，有到静安庄下车的乘客请注意\",车窗外是一位老爷爷，头发花白，应该在六十左右，双手背在身后，看着路上的一切，不知道在看些什么，也不知道在想些什么，三十而立，四十不惑，五十而知天命，六十而耳顺，七十而随心所欲不逾矩。如果我到了这个年纪，又会是什么样子呢？正当我陷入更多的思考后，车牌下一位头顶鸭舌帽，带着耳机，穿着短裤，我想她一定是个孤独而又对生活充满激情的人，有着年轻人该有的一切对生活不屈服的骄傲，一种来自内心的共鸣喷涌而出，如果说有什么让我坚持生活在这里，我想一定是在这里，每个人都在努力而又认真的活着。扫视窗外，路旁的清洁工正在打扫落叶，不知不觉，你已经离开我，后知后觉，又过了一个秋。生活就是这样，琐碎而又充满乐趣。\n\n此时此刻，村上春树、三毛更多的占据我的内心，使我迫不及待地想要把这一切记录下来。\n\n村上春树\n>天下的事在许多情况下并没有结论。那事情越是重要，这种倾向就越明显。越是脚踏实地大量收集第一手讯息，花费大量时间采访，事物的真相就越扑朔迷离。结论越发渐行渐远，视点越发四分五裂。注定如此。结果我们走投无路。孰对孰错，孰前孰后，我们渐渐不明就里了。 \n>\n>我们每个人或多或少，都是一只蛋，是拥有独一无二的灵魂和包裹这灵魂的脆弱外壳的蛋。我是这样，你们也是。而且我们每个人或多或少，都面对着一堵坚固的高墙。这堵墙是有名字的，它叫作“体制”。这体制本应是保护我们的东西。可在某些时候，它会自行其是，会杀死我们，会让我们杀人。它冷酷，高效，而且有条不紊。 \n>\n>年轻时音乐也好书也好，哪怕条件差一点，不也照样会不由分说地沁入心灵么？人的心中可以容纳无穷无尽的音乐。\n>\n>结果，大多数东西都烟消云散了。在那个时代里曾经震撼我们心灵、洞穿我们肉体的东西，当十年逝去回首往昔时，我们才知道那大多不过是经过粉饰的约定。我们追求了，于是给了我们。然而我们追求的东西太多，结果给我们的东西大多坠入了类型化。 \n>\n>在某些情况下，虚构会深深吞噬我们的真实存在。就像康拉德的小说将我们实际带入非洲原始森林深处一样。人们必须在某一时刻阖上书本，从那个场所回归现实。我们必须在与虚构不同的地点，恐怕是采取与虚构相互交换力量的形式，打造出抗击现实世界的自己。 \n>\n>与之相比，我们则生活在效率极低的混沌的社会里。阅读每日的报纸便可一目了然。不难理解毫不留恋地想逃出这种鬼地方，迅速融入心旷神怡的同质共同体的心情。 \n> \n>说得再深入些，我认为这里的外在混沌，不应当作他者和障碍加以排斥，而应视为我们内在混沌的反映接纳下来。其间的矛盾、庸俗、伪善和软弱，其实不正与我们内心暗藏的矛盾、庸俗、伪善和软弱相同吗？就像跳进大海时，包围身体的海水与我们内部的体液在成分上彼此呼应…… \n>\n>不过有个肉眼可见的变化。就是乘坐电车时，会极其自然地环视周围的乘客，想道，“这里的这些人，各自都有深刻的人生啊”。想道，“是的。我们在某种意义上是孤独的，但在某种意义上又不孤独”。着手这件工作之前，我根本没有这样的念头。电车仅仅是电车，乘客无非是“陌路人”罢了。\n\n\n对于未来，正如村上春树所说那样：**“世上所有的人终其一生，都在寻求某个宝贵的东西，但能找到的人不多。即使幸运地找到了，那东西也大多受到致命的损伤。但是，我们必须继续寻求。因为不这么做，活着的意义就不复存在。”**\n\n三毛\n>结婚，小半是为荷西情痴，大半仍是为了父母，至于我自己，本可以一辈子光棍下去，人的环境和追求并不只有那么一条狭路，怎么活，都是一场人生，不该在这件事上谈成败，论英雄。\n>\n>“每夜你上床时，一定要觉得——今天可真活了个够——那么你的一生都不会有遗憾”\n>\n>生命，在这样荒僻落后而贫苦的地方，一样欣欣向荣地滋长着，它，并不是挣扎着在生存，对于沙漠的居民而言，他们在此地的生老病死都好似是如此自然的事。我看着那些上升的烟火，觉得他们安详得近乎优雅起来。\n>\n>物质的文明对人类并不能说是必要，但是在我们同样生活着的地球上居然还有连镜子都没有看过的人，的确令我惊愕交加，继而对他们无由地产生了一丝怜悯。这样的无知只是地理环境的限制，还是人为的因素，我久久找不到答案。\n>\n>这条荒野里唯一的柏油路，照样被我日复一日地来回驶着，它乍看上去，好似死寂一片，没有生命，没有哀乐。其实它跟这世界上任何地方的一条街，一条窄弄，一弯溪流一样，载着它的过客和故事，来来往往地度着缓慢流动的年年月月。\n>\n>夏日的撒哈拉就似它漫天飞扬、永不止息的尘埃，好似再也没有过去的一天，岁月在令人欲死的炎热下粘了起来，缓慢而无奈的日子，除了使人懒散和疲倦之外，竟对什么都迷迷糊糊的不起劲，心里空空洞洞地熬着汗渍渍的日子。\n>\n>“看破的，遁入空门，痴迷的，枉送了性命，好一似，食尽鸟投林，落了片白茫茫大地真干净！”\n>\n>我蹲在远远的沙地上，不停地发着抖，发着抖，四周暗得快看不清他们了。风，突然没有了声音，我渐渐地什么也看不见，只听见屠宰房里骆驼嘶叫的悲鸣越来越响，越来越高，整个的天空，渐渐充满了骆驼们哭泣着的巨大的回声，像雷鸣似的向我罩下来。\n\n对于今天，则应该像三毛所说的那样：**“每夜你上床时，一定要觉得——今天可真活了个够——那么你的一生都不会有遗憾”**\n\n\n\n\n","source":"_posts/thinking-in-today.md","raw":"---\ntitle: 村上春树和三毛\ndate: 2018-08-08 23:09:46\ntags: life, reading\ncategories: life\n---\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=410161216&auto=1&height=66\"></iframe>\n\n不知道是因为下雨的原因，还是立秋的原因，今天走出门口，感觉凉凉的，有一点秋天的感觉。我想，也许有两者都有吧。然后赶往另一个地方，不经意间，就想起杨宗纬，想起村上春树，想起三毛。\n\n<!-- more -->\n\n想想自己来京一年多的时间里，自从去年在春雪未化的时候一个人去了碓臼峪，秋天去了中华民族园，去了香山。已经很久没有认真看过这个城市，正好搭公交去另一个地方。车上的人很少，大多是已上年纪的“老头”、“老太太”，依然选一个靠窗的位置坐下，开始百无聊赖的看窗外的故事。\n\n窗外有三三两两骑着电动车带小孩子的母亲，我想附近应该是有个学校吧，男孩儿背着书包，安安静静的拉着母亲的衣角，倒是女孩儿显得有点调皮，东张西望的样子，又显得有点可爱。心里暗自在想，如果可以永远当一个长不大的孩子，永远没有烦恼该多好。一会儿，上来一位奶爸，抱着两三岁的女儿，一副很学究气的眼镜，给人一种学者的印象，运动休闲短裤，脚上是休闲的凉鞋，手上爆凸的青筋，正好坐在我的邻座，一路上爸爸和女儿有的没的说话，女儿一概不理，我想，假如有女本柔弱，为母则刚的话，这一定是男本刚强，为父则柔吧，心中顿生温暖。\"静安庄到了，有到静安庄下车的乘客请注意\",车窗外是一位老爷爷，头发花白，应该在六十左右，双手背在身后，看着路上的一切，不知道在看些什么，也不知道在想些什么，三十而立，四十不惑，五十而知天命，六十而耳顺，七十而随心所欲不逾矩。如果我到了这个年纪，又会是什么样子呢？正当我陷入更多的思考后，车牌下一位头顶鸭舌帽，带着耳机，穿着短裤，我想她一定是个孤独而又对生活充满激情的人，有着年轻人该有的一切对生活不屈服的骄傲，一种来自内心的共鸣喷涌而出，如果说有什么让我坚持生活在这里，我想一定是在这里，每个人都在努力而又认真的活着。扫视窗外，路旁的清洁工正在打扫落叶，不知不觉，你已经离开我，后知后觉，又过了一个秋。生活就是这样，琐碎而又充满乐趣。\n\n此时此刻，村上春树、三毛更多的占据我的内心，使我迫不及待地想要把这一切记录下来。\n\n村上春树\n>天下的事在许多情况下并没有结论。那事情越是重要，这种倾向就越明显。越是脚踏实地大量收集第一手讯息，花费大量时间采访，事物的真相就越扑朔迷离。结论越发渐行渐远，视点越发四分五裂。注定如此。结果我们走投无路。孰对孰错，孰前孰后，我们渐渐不明就里了。 \n>\n>我们每个人或多或少，都是一只蛋，是拥有独一无二的灵魂和包裹这灵魂的脆弱外壳的蛋。我是这样，你们也是。而且我们每个人或多或少，都面对着一堵坚固的高墙。这堵墙是有名字的，它叫作“体制”。这体制本应是保护我们的东西。可在某些时候，它会自行其是，会杀死我们，会让我们杀人。它冷酷，高效，而且有条不紊。 \n>\n>年轻时音乐也好书也好，哪怕条件差一点，不也照样会不由分说地沁入心灵么？人的心中可以容纳无穷无尽的音乐。\n>\n>结果，大多数东西都烟消云散了。在那个时代里曾经震撼我们心灵、洞穿我们肉体的东西，当十年逝去回首往昔时，我们才知道那大多不过是经过粉饰的约定。我们追求了，于是给了我们。然而我们追求的东西太多，结果给我们的东西大多坠入了类型化。 \n>\n>在某些情况下，虚构会深深吞噬我们的真实存在。就像康拉德的小说将我们实际带入非洲原始森林深处一样。人们必须在某一时刻阖上书本，从那个场所回归现实。我们必须在与虚构不同的地点，恐怕是采取与虚构相互交换力量的形式，打造出抗击现实世界的自己。 \n>\n>与之相比，我们则生活在效率极低的混沌的社会里。阅读每日的报纸便可一目了然。不难理解毫不留恋地想逃出这种鬼地方，迅速融入心旷神怡的同质共同体的心情。 \n> \n>说得再深入些，我认为这里的外在混沌，不应当作他者和障碍加以排斥，而应视为我们内在混沌的反映接纳下来。其间的矛盾、庸俗、伪善和软弱，其实不正与我们内心暗藏的矛盾、庸俗、伪善和软弱相同吗？就像跳进大海时，包围身体的海水与我们内部的体液在成分上彼此呼应…… \n>\n>不过有个肉眼可见的变化。就是乘坐电车时，会极其自然地环视周围的乘客，想道，“这里的这些人，各自都有深刻的人生啊”。想道，“是的。我们在某种意义上是孤独的，但在某种意义上又不孤独”。着手这件工作之前，我根本没有这样的念头。电车仅仅是电车，乘客无非是“陌路人”罢了。\n\n\n对于未来，正如村上春树所说那样：**“世上所有的人终其一生，都在寻求某个宝贵的东西，但能找到的人不多。即使幸运地找到了，那东西也大多受到致命的损伤。但是，我们必须继续寻求。因为不这么做，活着的意义就不复存在。”**\n\n三毛\n>结婚，小半是为荷西情痴，大半仍是为了父母，至于我自己，本可以一辈子光棍下去，人的环境和追求并不只有那么一条狭路，怎么活，都是一场人生，不该在这件事上谈成败，论英雄。\n>\n>“每夜你上床时，一定要觉得——今天可真活了个够——那么你的一生都不会有遗憾”\n>\n>生命，在这样荒僻落后而贫苦的地方，一样欣欣向荣地滋长着，它，并不是挣扎着在生存，对于沙漠的居民而言，他们在此地的生老病死都好似是如此自然的事。我看着那些上升的烟火，觉得他们安详得近乎优雅起来。\n>\n>物质的文明对人类并不能说是必要，但是在我们同样生活着的地球上居然还有连镜子都没有看过的人，的确令我惊愕交加，继而对他们无由地产生了一丝怜悯。这样的无知只是地理环境的限制，还是人为的因素，我久久找不到答案。\n>\n>这条荒野里唯一的柏油路，照样被我日复一日地来回驶着，它乍看上去，好似死寂一片，没有生命，没有哀乐。其实它跟这世界上任何地方的一条街，一条窄弄，一弯溪流一样，载着它的过客和故事，来来往往地度着缓慢流动的年年月月。\n>\n>夏日的撒哈拉就似它漫天飞扬、永不止息的尘埃，好似再也没有过去的一天，岁月在令人欲死的炎热下粘了起来，缓慢而无奈的日子，除了使人懒散和疲倦之外，竟对什么都迷迷糊糊的不起劲，心里空空洞洞地熬着汗渍渍的日子。\n>\n>“看破的，遁入空门，痴迷的，枉送了性命，好一似，食尽鸟投林，落了片白茫茫大地真干净！”\n>\n>我蹲在远远的沙地上，不停地发着抖，发着抖，四周暗得快看不清他们了。风，突然没有了声音，我渐渐地什么也看不见，只听见屠宰房里骆驼嘶叫的悲鸣越来越响，越来越高，整个的天空，渐渐充满了骆驼们哭泣着的巨大的回声，像雷鸣似的向我罩下来。\n\n对于今天，则应该像三毛所说的那样：**“每夜你上床时，一定要觉得——今天可真活了个够——那么你的一生都不会有遗憾”**\n\n\n\n\n","slug":"thinking-in-today","published":1,"updated":"2018-08-13T15:12:48.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde37002ov0f0kso0om9q","content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=410161216&auto=1&height=66\"></iframe>\n\n<p>不知道是因为下雨的原因，还是立秋的原因，今天走出门口，感觉凉凉的，有一点秋天的感觉。我想，也许有两者都有吧。然后赶往另一个地方，不经意间，就想起杨宗纬，想起村上春树，想起三毛。</p>\n<a id=\"more\"></a>\n<p>想想自己来京一年多的时间里，自从去年在春雪未化的时候一个人去了碓臼峪，秋天去了中华民族园，去了香山。已经很久没有认真看过这个城市，正好搭公交去另一个地方。车上的人很少，大多是已上年纪的“老头”、“老太太”，依然选一个靠窗的位置坐下，开始百无聊赖的看窗外的故事。</p>\n<p>窗外有三三两两骑着电动车带小孩子的母亲，我想附近应该是有个学校吧，男孩儿背着书包，安安静静的拉着母亲的衣角，倒是女孩儿显得有点调皮，东张西望的样子，又显得有点可爱。心里暗自在想，如果可以永远当一个长不大的孩子，永远没有烦恼该多好。一会儿，上来一位奶爸，抱着两三岁的女儿，一副很学究气的眼镜，给人一种学者的印象，运动休闲短裤，脚上是休闲的凉鞋，手上爆凸的青筋，正好坐在我的邻座，一路上爸爸和女儿有的没的说话，女儿一概不理，我想，假如有女本柔弱，为母则刚的话，这一定是男本刚强，为父则柔吧，心中顿生温暖。”静安庄到了，有到静安庄下车的乘客请注意”,车窗外是一位老爷爷，头发花白，应该在六十左右，双手背在身后，看着路上的一切，不知道在看些什么，也不知道在想些什么，三十而立，四十不惑，五十而知天命，六十而耳顺，七十而随心所欲不逾矩。如果我到了这个年纪，又会是什么样子呢？正当我陷入更多的思考后，车牌下一位头顶鸭舌帽，带着耳机，穿着短裤，我想她一定是个孤独而又对生活充满激情的人，有着年轻人该有的一切对生活不屈服的骄傲，一种来自内心的共鸣喷涌而出，如果说有什么让我坚持生活在这里，我想一定是在这里，每个人都在努力而又认真的活着。扫视窗外，路旁的清洁工正在打扫落叶，不知不觉，你已经离开我，后知后觉，又过了一个秋。生活就是这样，琐碎而又充满乐趣。</p>\n<p>此时此刻，村上春树、三毛更多的占据我的内心，使我迫不及待地想要把这一切记录下来。</p>\n<p>村上春树</p>\n<blockquote>\n<p>天下的事在许多情况下并没有结论。那事情越是重要，这种倾向就越明显。越是脚踏实地大量收集第一手讯息，花费大量时间采访，事物的真相就越扑朔迷离。结论越发渐行渐远，视点越发四分五裂。注定如此。结果我们走投无路。孰对孰错，孰前孰后，我们渐渐不明就里了。 </p>\n<p>我们每个人或多或少，都是一只蛋，是拥有独一无二的灵魂和包裹这灵魂的脆弱外壳的蛋。我是这样，你们也是。而且我们每个人或多或少，都面对着一堵坚固的高墙。这堵墙是有名字的，它叫作“体制”。这体制本应是保护我们的东西。可在某些时候，它会自行其是，会杀死我们，会让我们杀人。它冷酷，高效，而且有条不紊。 </p>\n<p>年轻时音乐也好书也好，哪怕条件差一点，不也照样会不由分说地沁入心灵么？人的心中可以容纳无穷无尽的音乐。</p>\n<p>结果，大多数东西都烟消云散了。在那个时代里曾经震撼我们心灵、洞穿我们肉体的东西，当十年逝去回首往昔时，我们才知道那大多不过是经过粉饰的约定。我们追求了，于是给了我们。然而我们追求的东西太多，结果给我们的东西大多坠入了类型化。 </p>\n<p>在某些情况下，虚构会深深吞噬我们的真实存在。就像康拉德的小说将我们实际带入非洲原始森林深处一样。人们必须在某一时刻阖上书本，从那个场所回归现实。我们必须在与虚构不同的地点，恐怕是采取与虚构相互交换力量的形式，打造出抗击现实世界的自己。 </p>\n<p>与之相比，我们则生活在效率极低的混沌的社会里。阅读每日的报纸便可一目了然。不难理解毫不留恋地想逃出这种鬼地方，迅速融入心旷神怡的同质共同体的心情。 </p>\n<p>说得再深入些，我认为这里的外在混沌，不应当作他者和障碍加以排斥，而应视为我们内在混沌的反映接纳下来。其间的矛盾、庸俗、伪善和软弱，其实不正与我们内心暗藏的矛盾、庸俗、伪善和软弱相同吗？就像跳进大海时，包围身体的海水与我们内部的体液在成分上彼此呼应…… </p>\n<p>不过有个肉眼可见的变化。就是乘坐电车时，会极其自然地环视周围的乘客，想道，“这里的这些人，各自都有深刻的人生啊”。想道，“是的。我们在某种意义上是孤独的，但在某种意义上又不孤独”。着手这件工作之前，我根本没有这样的念头。电车仅仅是电车，乘客无非是“陌路人”罢了。</p>\n</blockquote>\n<p>对于未来，正如村上春树所说那样：<strong>“世上所有的人终其一生，都在寻求某个宝贵的东西，但能找到的人不多。即使幸运地找到了，那东西也大多受到致命的损伤。但是，我们必须继续寻求。因为不这么做，活着的意义就不复存在。”</strong></p>\n<p>三毛</p>\n<blockquote>\n<p>结婚，小半是为荷西情痴，大半仍是为了父母，至于我自己，本可以一辈子光棍下去，人的环境和追求并不只有那么一条狭路，怎么活，都是一场人生，不该在这件事上谈成败，论英雄。</p>\n<p>“每夜你上床时，一定要觉得——今天可真活了个够——那么你的一生都不会有遗憾”</p>\n<p>生命，在这样荒僻落后而贫苦的地方，一样欣欣向荣地滋长着，它，并不是挣扎着在生存，对于沙漠的居民而言，他们在此地的生老病死都好似是如此自然的事。我看着那些上升的烟火，觉得他们安详得近乎优雅起来。</p>\n<p>物质的文明对人类并不能说是必要，但是在我们同样生活着的地球上居然还有连镜子都没有看过的人，的确令我惊愕交加，继而对他们无由地产生了一丝怜悯。这样的无知只是地理环境的限制，还是人为的因素，我久久找不到答案。</p>\n<p>这条荒野里唯一的柏油路，照样被我日复一日地来回驶着，它乍看上去，好似死寂一片，没有生命，没有哀乐。其实它跟这世界上任何地方的一条街，一条窄弄，一弯溪流一样，载着它的过客和故事，来来往往地度着缓慢流动的年年月月。</p>\n<p>夏日的撒哈拉就似它漫天飞扬、永不止息的尘埃，好似再也没有过去的一天，岁月在令人欲死的炎热下粘了起来，缓慢而无奈的日子，除了使人懒散和疲倦之外，竟对什么都迷迷糊糊的不起劲，心里空空洞洞地熬着汗渍渍的日子。</p>\n<p>“看破的，遁入空门，痴迷的，枉送了性命，好一似，食尽鸟投林，落了片白茫茫大地真干净！”</p>\n<p>我蹲在远远的沙地上，不停地发着抖，发着抖，四周暗得快看不清他们了。风，突然没有了声音，我渐渐地什么也看不见，只听见屠宰房里骆驼嘶叫的悲鸣越来越响，越来越高，整个的天空，渐渐充满了骆驼们哭泣着的巨大的回声，像雷鸣似的向我罩下来。</p>\n</blockquote>\n<p>对于今天，则应该像三毛所说的那样：<strong>“每夜你上床时，一定要觉得——今天可真活了个够——那么你的一生都不会有遗憾”</strong></p>\n","site":{"data":{}},"excerpt":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=410161216&auto=1&height=66\"></iframe>\n\n<p>不知道是因为下雨的原因，还是立秋的原因，今天走出门口，感觉凉凉的，有一点秋天的感觉。我想，也许有两者都有吧。然后赶往另一个地方，不经意间，就想起杨宗纬，想起村上春树，想起三毛。</p>","more":"<p>想想自己来京一年多的时间里，自从去年在春雪未化的时候一个人去了碓臼峪，秋天去了中华民族园，去了香山。已经很久没有认真看过这个城市，正好搭公交去另一个地方。车上的人很少，大多是已上年纪的“老头”、“老太太”，依然选一个靠窗的位置坐下，开始百无聊赖的看窗外的故事。</p>\n<p>窗外有三三两两骑着电动车带小孩子的母亲，我想附近应该是有个学校吧，男孩儿背着书包，安安静静的拉着母亲的衣角，倒是女孩儿显得有点调皮，东张西望的样子，又显得有点可爱。心里暗自在想，如果可以永远当一个长不大的孩子，永远没有烦恼该多好。一会儿，上来一位奶爸，抱着两三岁的女儿，一副很学究气的眼镜，给人一种学者的印象，运动休闲短裤，脚上是休闲的凉鞋，手上爆凸的青筋，正好坐在我的邻座，一路上爸爸和女儿有的没的说话，女儿一概不理，我想，假如有女本柔弱，为母则刚的话，这一定是男本刚强，为父则柔吧，心中顿生温暖。”静安庄到了，有到静安庄下车的乘客请注意”,车窗外是一位老爷爷，头发花白，应该在六十左右，双手背在身后，看着路上的一切，不知道在看些什么，也不知道在想些什么，三十而立，四十不惑，五十而知天命，六十而耳顺，七十而随心所欲不逾矩。如果我到了这个年纪，又会是什么样子呢？正当我陷入更多的思考后，车牌下一位头顶鸭舌帽，带着耳机，穿着短裤，我想她一定是个孤独而又对生活充满激情的人，有着年轻人该有的一切对生活不屈服的骄傲，一种来自内心的共鸣喷涌而出，如果说有什么让我坚持生活在这里，我想一定是在这里，每个人都在努力而又认真的活着。扫视窗外，路旁的清洁工正在打扫落叶，不知不觉，你已经离开我，后知后觉，又过了一个秋。生活就是这样，琐碎而又充满乐趣。</p>\n<p>此时此刻，村上春树、三毛更多的占据我的内心，使我迫不及待地想要把这一切记录下来。</p>\n<p>村上春树</p>\n<blockquote>\n<p>天下的事在许多情况下并没有结论。那事情越是重要，这种倾向就越明显。越是脚踏实地大量收集第一手讯息，花费大量时间采访，事物的真相就越扑朔迷离。结论越发渐行渐远，视点越发四分五裂。注定如此。结果我们走投无路。孰对孰错，孰前孰后，我们渐渐不明就里了。 </p>\n<p>我们每个人或多或少，都是一只蛋，是拥有独一无二的灵魂和包裹这灵魂的脆弱外壳的蛋。我是这样，你们也是。而且我们每个人或多或少，都面对着一堵坚固的高墙。这堵墙是有名字的，它叫作“体制”。这体制本应是保护我们的东西。可在某些时候，它会自行其是，会杀死我们，会让我们杀人。它冷酷，高效，而且有条不紊。 </p>\n<p>年轻时音乐也好书也好，哪怕条件差一点，不也照样会不由分说地沁入心灵么？人的心中可以容纳无穷无尽的音乐。</p>\n<p>结果，大多数东西都烟消云散了。在那个时代里曾经震撼我们心灵、洞穿我们肉体的东西，当十年逝去回首往昔时，我们才知道那大多不过是经过粉饰的约定。我们追求了，于是给了我们。然而我们追求的东西太多，结果给我们的东西大多坠入了类型化。 </p>\n<p>在某些情况下，虚构会深深吞噬我们的真实存在。就像康拉德的小说将我们实际带入非洲原始森林深处一样。人们必须在某一时刻阖上书本，从那个场所回归现实。我们必须在与虚构不同的地点，恐怕是采取与虚构相互交换力量的形式，打造出抗击现实世界的自己。 </p>\n<p>与之相比，我们则生活在效率极低的混沌的社会里。阅读每日的报纸便可一目了然。不难理解毫不留恋地想逃出这种鬼地方，迅速融入心旷神怡的同质共同体的心情。 </p>\n<p>说得再深入些，我认为这里的外在混沌，不应当作他者和障碍加以排斥，而应视为我们内在混沌的反映接纳下来。其间的矛盾、庸俗、伪善和软弱，其实不正与我们内心暗藏的矛盾、庸俗、伪善和软弱相同吗？就像跳进大海时，包围身体的海水与我们内部的体液在成分上彼此呼应…… </p>\n<p>不过有个肉眼可见的变化。就是乘坐电车时，会极其自然地环视周围的乘客，想道，“这里的这些人，各自都有深刻的人生啊”。想道，“是的。我们在某种意义上是孤独的，但在某种意义上又不孤独”。着手这件工作之前，我根本没有这样的念头。电车仅仅是电车，乘客无非是“陌路人”罢了。</p>\n</blockquote>\n<p>对于未来，正如村上春树所说那样：<strong>“世上所有的人终其一生，都在寻求某个宝贵的东西，但能找到的人不多。即使幸运地找到了，那东西也大多受到致命的损伤。但是，我们必须继续寻求。因为不这么做，活着的意义就不复存在。”</strong></p>\n<p>三毛</p>\n<blockquote>\n<p>结婚，小半是为荷西情痴，大半仍是为了父母，至于我自己，本可以一辈子光棍下去，人的环境和追求并不只有那么一条狭路，怎么活，都是一场人生，不该在这件事上谈成败，论英雄。</p>\n<p>“每夜你上床时，一定要觉得——今天可真活了个够——那么你的一生都不会有遗憾”</p>\n<p>生命，在这样荒僻落后而贫苦的地方，一样欣欣向荣地滋长着，它，并不是挣扎着在生存，对于沙漠的居民而言，他们在此地的生老病死都好似是如此自然的事。我看着那些上升的烟火，觉得他们安详得近乎优雅起来。</p>\n<p>物质的文明对人类并不能说是必要，但是在我们同样生活着的地球上居然还有连镜子都没有看过的人，的确令我惊愕交加，继而对他们无由地产生了一丝怜悯。这样的无知只是地理环境的限制，还是人为的因素，我久久找不到答案。</p>\n<p>这条荒野里唯一的柏油路，照样被我日复一日地来回驶着，它乍看上去，好似死寂一片，没有生命，没有哀乐。其实它跟这世界上任何地方的一条街，一条窄弄，一弯溪流一样，载着它的过客和故事，来来往往地度着缓慢流动的年年月月。</p>\n<p>夏日的撒哈拉就似它漫天飞扬、永不止息的尘埃，好似再也没有过去的一天，岁月在令人欲死的炎热下粘了起来，缓慢而无奈的日子，除了使人懒散和疲倦之外，竟对什么都迷迷糊糊的不起劲，心里空空洞洞地熬着汗渍渍的日子。</p>\n<p>“看破的，遁入空门，痴迷的，枉送了性命，好一似，食尽鸟投林，落了片白茫茫大地真干净！”</p>\n<p>我蹲在远远的沙地上，不停地发着抖，发着抖，四周暗得快看不清他们了。风，突然没有了声音，我渐渐地什么也看不见，只听见屠宰房里骆驼嘶叫的悲鸣越来越响，越来越高，整个的天空，渐渐充满了骆驼们哭泣着的巨大的回声，像雷鸣似的向我罩下来。</p>\n</blockquote>\n<p>对于今天，则应该像三毛所说的那样：<strong>“每夜你上床时，一定要觉得——今天可真活了个够——那么你的一生都不会有遗憾”</strong></p>"},{"title":"Java并发编程","date":"2018-07-27T15:12:48.000Z","_content":"synchronized\n\npublic static void synchronized \n\n\n## volatile\n\n当且仅当满足以下所有条件时，才应该使用volatile变量：\n\n对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值；\n\n该变量不会与其它状态变量一起纳入不变性条件中；\n\n在访问变量时不需要加锁。\n\n\n发布：\n\n逸出：\n\n构造过程导致this引用逸出的常见错误：\n\n1、在构造函数中启动一个线程。在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个sart/initialize方法启动它。\n\n2、在构造函数中调用一个可改写的实例方法时(既不是私有方法，也不是终结方法)\n\n如果在构造函数中注册一个事件监听器或者启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法。\n\n\n线程封闭：如果仅在单线程内访问数据，就不需要同步，这种技术被称为线程封闭\n\n应用场景：\n\n> 在Swing中大量使用\n> \n> JDBC的Connection对象\n\n\n1、Ad-hoc线程封闭：维护线程封闭性的职责完全由程序来承担\n\nDemo:\n\n\n2、栈封闭：将对象封闭在栈内，只能通过局部变量才能访问\n\nDemo:\n\n\n3、TreadLocal类:\n\n场景：\n\n> 通常用于防止对可变的单实例变量、全局变量进行共享\n> \n\nDemo:\n\n    private static ThreadLocal<Connection> connection = new ThreadLocal<Connection>(){};\n\n## 同步工具类\n\n闭锁(CountdownLatch)：\n\nFutureTask\n\n信号量(Semphore):\n\n栅栏(CyclicBarrier):\n\n\n### 基本的任务排队方法 ###\n1、无界队列\n\n2、有界队列\n\n3、同步移交\n\nSynchronousQueue\n\nArrayBlockingQueue\n\nLinkedBlockingQueue\n\nPriorityBlockingQueue\n\n### 饱和策略 ###\n\nAbortPolicy\n\nCallerRunsPolicy\n\nDiscardPolicy\n\nDiscardOldestPolicy\n\n\n## ##\n\nSynchronized和ReentrantLock\n\n\n独占锁和读写锁(ReentrantReadWriteLock/ReadWriteLock)\n\nConcurrentHashMap(ConcurrentMap)\n\n\n## AQS ##\n\n基于AQS实现的类：\n\nCountDownLatch\n\nSemaphore\n\nFutureTask\n\nSynchronousQueue\n\nReentrantLock\n\nReentrantReadWriteLock\n\n\n## 原子变量与非阻塞同步机制 ##\n\n\n## Java内存模型 ##\n\nHappens-Before原则：\n\n","source":"_posts/thread-1.md","raw":"---\ntitle: Java并发编程\ndate: 2018-07-27 23:12:48\ntags:\n---\nsynchronized\n\npublic static void synchronized \n\n\n## volatile\n\n当且仅当满足以下所有条件时，才应该使用volatile变量：\n\n对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值；\n\n该变量不会与其它状态变量一起纳入不变性条件中；\n\n在访问变量时不需要加锁。\n\n\n发布：\n\n逸出：\n\n构造过程导致this引用逸出的常见错误：\n\n1、在构造函数中启动一个线程。在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个sart/initialize方法启动它。\n\n2、在构造函数中调用一个可改写的实例方法时(既不是私有方法，也不是终结方法)\n\n如果在构造函数中注册一个事件监听器或者启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法。\n\n\n线程封闭：如果仅在单线程内访问数据，就不需要同步，这种技术被称为线程封闭\n\n应用场景：\n\n> 在Swing中大量使用\n> \n> JDBC的Connection对象\n\n\n1、Ad-hoc线程封闭：维护线程封闭性的职责完全由程序来承担\n\nDemo:\n\n\n2、栈封闭：将对象封闭在栈内，只能通过局部变量才能访问\n\nDemo:\n\n\n3、TreadLocal类:\n\n场景：\n\n> 通常用于防止对可变的单实例变量、全局变量进行共享\n> \n\nDemo:\n\n    private static ThreadLocal<Connection> connection = new ThreadLocal<Connection>(){};\n\n## 同步工具类\n\n闭锁(CountdownLatch)：\n\nFutureTask\n\n信号量(Semphore):\n\n栅栏(CyclicBarrier):\n\n\n### 基本的任务排队方法 ###\n1、无界队列\n\n2、有界队列\n\n3、同步移交\n\nSynchronousQueue\n\nArrayBlockingQueue\n\nLinkedBlockingQueue\n\nPriorityBlockingQueue\n\n### 饱和策略 ###\n\nAbortPolicy\n\nCallerRunsPolicy\n\nDiscardPolicy\n\nDiscardOldestPolicy\n\n\n## ##\n\nSynchronized和ReentrantLock\n\n\n独占锁和读写锁(ReentrantReadWriteLock/ReadWriteLock)\n\nConcurrentHashMap(ConcurrentMap)\n\n\n## AQS ##\n\n基于AQS实现的类：\n\nCountDownLatch\n\nSemaphore\n\nFutureTask\n\nSynchronousQueue\n\nReentrantLock\n\nReentrantReadWriteLock\n\n\n## 原子变量与非阻塞同步机制 ##\n\n\n## Java内存模型 ##\n\nHappens-Before原则：\n\n","slug":"thread-1","published":1,"updated":"2018-08-06T16:02:18.697Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde3a002rv0f0hfev1qqn","content":"<p>synchronized</p>\n<p>public static void synchronized </p>\n<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><p>当且仅当满足以下所有条件时，才应该使用volatile变量：</p>\n<p>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值；</p>\n<p>该变量不会与其它状态变量一起纳入不变性条件中；</p>\n<p>在访问变量时不需要加锁。</p>\n<p>发布：</p>\n<p>逸出：</p>\n<p>构造过程导致this引用逸出的常见错误：</p>\n<p>1、在构造函数中启动一个线程。在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个sart/initialize方法启动它。</p>\n<p>2、在构造函数中调用一个可改写的实例方法时(既不是私有方法，也不是终结方法)</p>\n<p>如果在构造函数中注册一个事件监听器或者启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法。</p>\n<p>线程封闭：如果仅在单线程内访问数据，就不需要同步，这种技术被称为线程封闭</p>\n<p>应用场景：</p>\n<blockquote>\n<p>在Swing中大量使用</p>\n<p>JDBC的Connection对象</p>\n</blockquote>\n<p>1、Ad-hoc线程封闭：维护线程封闭性的职责完全由程序来承担</p>\n<p>Demo:</p>\n<p>2、栈封闭：将对象封闭在栈内，只能通过局部变量才能访问</p>\n<p>Demo:</p>\n<p>3、TreadLocal类:</p>\n<p>场景：</p>\n<blockquote>\n<p>通常用于防止对可变的单实例变量、全局变量进行共享</p>\n</blockquote>\n<p>Demo:</p>\n<pre><code>private static ThreadLocal&lt;Connection&gt; connection = new ThreadLocal&lt;Connection&gt;(){};\n</code></pre><h2 id=\"同步工具类\"><a href=\"#同步工具类\" class=\"headerlink\" title=\"同步工具类\"></a>同步工具类</h2><p>闭锁(CountdownLatch)：</p>\n<p>FutureTask</p>\n<p>信号量(Semphore):</p>\n<p>栅栏(CyclicBarrier):</p>\n<h3 id=\"基本的任务排队方法\"><a href=\"#基本的任务排队方法\" class=\"headerlink\" title=\"基本的任务排队方法\"></a>基本的任务排队方法</h3><p>1、无界队列</p>\n<p>2、有界队列</p>\n<p>3、同步移交</p>\n<p>SynchronousQueue</p>\n<p>ArrayBlockingQueue</p>\n<p>LinkedBlockingQueue</p>\n<p>PriorityBlockingQueue</p>\n<h3 id=\"饱和策略\"><a href=\"#饱和策略\" class=\"headerlink\" title=\"饱和策略\"></a>饱和策略</h3><p>AbortPolicy</p>\n<p>CallerRunsPolicy</p>\n<p>DiscardPolicy</p>\n<p>DiscardOldestPolicy</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"#\"></a>#</h2><p>Synchronized和ReentrantLock</p>\n<p>独占锁和读写锁(ReentrantReadWriteLock/ReadWriteLock)</p>\n<p>ConcurrentHashMap(ConcurrentMap)</p>\n<h2 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h2><p>基于AQS实现的类：</p>\n<p>CountDownLatch</p>\n<p>Semaphore</p>\n<p>FutureTask</p>\n<p>SynchronousQueue</p>\n<p>ReentrantLock</p>\n<p>ReentrantReadWriteLock</p>\n<h2 id=\"原子变量与非阻塞同步机制\"><a href=\"#原子变量与非阻塞同步机制\" class=\"headerlink\" title=\"原子变量与非阻塞同步机制\"></a>原子变量与非阻塞同步机制</h2><h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><p>Happens-Before原则：</p>\n","site":{"data":{}},"excerpt":"","more":"<p>synchronized</p>\n<p>public static void synchronized </p>\n<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><p>当且仅当满足以下所有条件时，才应该使用volatile变量：</p>\n<p>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值；</p>\n<p>该变量不会与其它状态变量一起纳入不变性条件中；</p>\n<p>在访问变量时不需要加锁。</p>\n<p>发布：</p>\n<p>逸出：</p>\n<p>构造过程导致this引用逸出的常见错误：</p>\n<p>1、在构造函数中启动一个线程。在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个sart/initialize方法启动它。</p>\n<p>2、在构造函数中调用一个可改写的实例方法时(既不是私有方法，也不是终结方法)</p>\n<p>如果在构造函数中注册一个事件监听器或者启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法。</p>\n<p>线程封闭：如果仅在单线程内访问数据，就不需要同步，这种技术被称为线程封闭</p>\n<p>应用场景：</p>\n<blockquote>\n<p>在Swing中大量使用</p>\n<p>JDBC的Connection对象</p>\n</blockquote>\n<p>1、Ad-hoc线程封闭：维护线程封闭性的职责完全由程序来承担</p>\n<p>Demo:</p>\n<p>2、栈封闭：将对象封闭在栈内，只能通过局部变量才能访问</p>\n<p>Demo:</p>\n<p>3、TreadLocal类:</p>\n<p>场景：</p>\n<blockquote>\n<p>通常用于防止对可变的单实例变量、全局变量进行共享</p>\n</blockquote>\n<p>Demo:</p>\n<pre><code>private static ThreadLocal&lt;Connection&gt; connection = new ThreadLocal&lt;Connection&gt;(){};\n</code></pre><h2 id=\"同步工具类\"><a href=\"#同步工具类\" class=\"headerlink\" title=\"同步工具类\"></a>同步工具类</h2><p>闭锁(CountdownLatch)：</p>\n<p>FutureTask</p>\n<p>信号量(Semphore):</p>\n<p>栅栏(CyclicBarrier):</p>\n<h3 id=\"基本的任务排队方法\"><a href=\"#基本的任务排队方法\" class=\"headerlink\" title=\"基本的任务排队方法\"></a>基本的任务排队方法</h3><p>1、无界队列</p>\n<p>2、有界队列</p>\n<p>3、同步移交</p>\n<p>SynchronousQueue</p>\n<p>ArrayBlockingQueue</p>\n<p>LinkedBlockingQueue</p>\n<p>PriorityBlockingQueue</p>\n<h3 id=\"饱和策略\"><a href=\"#饱和策略\" class=\"headerlink\" title=\"饱和策略\"></a>饱和策略</h3><p>AbortPolicy</p>\n<p>CallerRunsPolicy</p>\n<p>DiscardPolicy</p>\n<p>DiscardOldestPolicy</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"#\"></a>#</h2><p>Synchronized和ReentrantLock</p>\n<p>独占锁和读写锁(ReentrantReadWriteLock/ReadWriteLock)</p>\n<p>ConcurrentHashMap(ConcurrentMap)</p>\n<h2 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h2><p>基于AQS实现的类：</p>\n<p>CountDownLatch</p>\n<p>Semaphore</p>\n<p>FutureTask</p>\n<p>SynchronousQueue</p>\n<p>ReentrantLock</p>\n<p>ReentrantReadWriteLock</p>\n<h2 id=\"原子变量与非阻塞同步机制\"><a href=\"#原子变量与非阻塞同步机制\" class=\"headerlink\" title=\"原子变量与非阻塞同步机制\"></a>原子变量与非阻塞同步机制</h2><h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><p>Happens-Before原则：</p>\n"},{"title":"synchronized和ReentrantLock","date":"2018-08-06T16:02:44.000Z","_content":"## synchronized ##\n\n### sychronized的几种不同用法： ###\n\n1、修饰类\n\n锁的对象是该类的所有实例\n\n2、修饰静态方法\n\n锁的对象是该类的所有实例对象\n\n\n\n3、修饰方法\n\n锁的对象是调用该方法的实例对象\n\n4、修饰代码块\n\n和修饰方法类似，锁对象都是调用该方法的实例对象\n\n\n## ReentrantLock ##\n\n\n## synchronize和ReentrantLock的比较 ##\n\n\n\nReentranLock使用场景：\n\n> 需要时间锁、可中断锁、无块结构锁、轮询锁、多个条件变量时使用\n>\n> 需要可伸缩性、高度竞争的情况下使用","source":"_posts/thread-lock.md","raw":"---\ntitle: synchronized和ReentrantLock\ndate: 2018-08-07 00:02:44\ntags: java, 多线程\ncategories: java\n---\n## synchronized ##\n\n### sychronized的几种不同用法： ###\n\n1、修饰类\n\n锁的对象是该类的所有实例\n\n2、修饰静态方法\n\n锁的对象是该类的所有实例对象\n\n\n\n3、修饰方法\n\n锁的对象是调用该方法的实例对象\n\n4、修饰代码块\n\n和修饰方法类似，锁对象都是调用该方法的实例对象\n\n\n## ReentrantLock ##\n\n\n## synchronize和ReentrantLock的比较 ##\n\n\n\nReentranLock使用场景：\n\n> 需要时间锁、可中断锁、无块结构锁、轮询锁、多个条件变量时使用\n>\n> 需要可伸缩性、高度竞争的情况下使用","slug":"thread-lock","published":1,"updated":"2018-08-06T17:08:54.489Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde3e002tv0f04w0ou523","content":"<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h2><h3 id=\"sychronized的几种不同用法：\"><a href=\"#sychronized的几种不同用法：\" class=\"headerlink\" title=\"sychronized的几种不同用法：\"></a>sychronized的几种不同用法：</h3><p>1、修饰类</p>\n<p>锁的对象是该类的所有实例</p>\n<p>2、修饰静态方法</p>\n<p>锁的对象是该类的所有实例对象</p>\n<p>3、修饰方法</p>\n<p>锁的对象是调用该方法的实例对象</p>\n<p>4、修饰代码块</p>\n<p>和修饰方法类似，锁对象都是调用该方法的实例对象</p>\n<h2 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h2><h2 id=\"synchronize和ReentrantLock的比较\"><a href=\"#synchronize和ReentrantLock的比较\" class=\"headerlink\" title=\"synchronize和ReentrantLock的比较\"></a>synchronize和ReentrantLock的比较</h2><p>ReentranLock使用场景：</p>\n<blockquote>\n<p>需要时间锁、可中断锁、无块结构锁、轮询锁、多个条件变量时使用</p>\n<p>需要可伸缩性、高度竞争的情况下使用</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h2><h3 id=\"sychronized的几种不同用法：\"><a href=\"#sychronized的几种不同用法：\" class=\"headerlink\" title=\"sychronized的几种不同用法：\"></a>sychronized的几种不同用法：</h3><p>1、修饰类</p>\n<p>锁的对象是该类的所有实例</p>\n<p>2、修饰静态方法</p>\n<p>锁的对象是该类的所有实例对象</p>\n<p>3、修饰方法</p>\n<p>锁的对象是调用该方法的实例对象</p>\n<p>4、修饰代码块</p>\n<p>和修饰方法类似，锁对象都是调用该方法的实例对象</p>\n<h2 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h2><h2 id=\"synchronize和ReentrantLock的比较\"><a href=\"#synchronize和ReentrantLock的比较\" class=\"headerlink\" title=\"synchronize和ReentrantLock的比较\"></a>synchronize和ReentrantLock的比较</h2><p>ReentranLock使用场景：</p>\n<blockquote>\n<p>需要时间锁、可中断锁、无块结构锁、轮询锁、多个条件变量时使用</p>\n<p>需要可伸缩性、高度竞争的情况下使用</p>\n</blockquote>\n"},{"title":"线程池","date":"2018-08-06T16:00:57.000Z","_content":"## 线程池 ##\n\n1、Executors中的静态工厂方法：\n\nnewFixedThreadPool:创建一个固定长度的线程池，(无界的阻塞队列LinkedBlockingQueue)\n\nnewSingleThreadExecutor:创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程代替(无界的阻塞队列LinkedBlockingQueue)\n\n**注意：** 以上两个允许请求队列长度为Integer.MAX_VALUE,可能堆积大量的请求，导致OOM\n\nnewCachedThreadPool:创建一个可缓存的线程池，(队列SynchronizedQueue)\n\nnewScheduledThreadPool:创建一个固定长度的线程池，而且以延迟或者定时的方式来执行任务,类似于Timer\n\n**注意：**以上两个允许创建线程数为Integer.MAX_VALUE,可能创建大量线程，导致OOM\n\n2、ThreadPoolExecutor\n\n### 创建与销毁 ###\n\n\tpublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n\n\t}\n\ncorePoolSize:没有任务执行时线程池的大小，当工作队列满了的时候，才会创建超出该数量的线程\n\nmaximumPoolSize:表示可同时活动的线程数量的上限\n\nkeepAliveTime:空闲线程存活时间，如果某个线程的空闲时间超过了keepAliveTIme，则被标记为可回收，并且当线程池当前大小超出corePoolSize时，这个线程将被终止。\n\n### 管理队列任务 ###\n\n基本的任务队列有3种：\n\n>无界队列\n>\n>有界队列\n>\n>同步移交\n\nArrayBlockingQueue\n\nLinkedBlockingQueue\n\nPriorityBlockingQueue\n\nSynchronouseQueue\n\n### 饱和策略 ###\n\n当队列满了以后，饱和策略发挥作用\n\nJDK提供了4种饱和策略：\n\n> AbortPolicy:默认的饱和策略，当队列满时，将抛出未检查的RejectedExecutionException\n>\n> CallerRunsPolicy:该策略不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量\n>\n> DiscardPolicy:当新提交的任务无法保存到队列时，该策略将抛弃该任务\n>\n> DiscardOldestPolicy:该策略将抛弃下一个被执行的任务，然后重新提交新任务\n\n\n\n### 线程工厂 ###\n\n默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息\n","source":"_posts/thread-pool.md","raw":"---\ntitle: 线程池\ndate: 2018-08-07 00:00:57\ntags: java, 多线程\ncategories: java\n---\n## 线程池 ##\n\n1、Executors中的静态工厂方法：\n\nnewFixedThreadPool:创建一个固定长度的线程池，(无界的阻塞队列LinkedBlockingQueue)\n\nnewSingleThreadExecutor:创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程代替(无界的阻塞队列LinkedBlockingQueue)\n\n**注意：** 以上两个允许请求队列长度为Integer.MAX_VALUE,可能堆积大量的请求，导致OOM\n\nnewCachedThreadPool:创建一个可缓存的线程池，(队列SynchronizedQueue)\n\nnewScheduledThreadPool:创建一个固定长度的线程池，而且以延迟或者定时的方式来执行任务,类似于Timer\n\n**注意：**以上两个允许创建线程数为Integer.MAX_VALUE,可能创建大量线程，导致OOM\n\n2、ThreadPoolExecutor\n\n### 创建与销毁 ###\n\n\tpublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n\n\t}\n\ncorePoolSize:没有任务执行时线程池的大小，当工作队列满了的时候，才会创建超出该数量的线程\n\nmaximumPoolSize:表示可同时活动的线程数量的上限\n\nkeepAliveTime:空闲线程存活时间，如果某个线程的空闲时间超过了keepAliveTIme，则被标记为可回收，并且当线程池当前大小超出corePoolSize时，这个线程将被终止。\n\n### 管理队列任务 ###\n\n基本的任务队列有3种：\n\n>无界队列\n>\n>有界队列\n>\n>同步移交\n\nArrayBlockingQueue\n\nLinkedBlockingQueue\n\nPriorityBlockingQueue\n\nSynchronouseQueue\n\n### 饱和策略 ###\n\n当队列满了以后，饱和策略发挥作用\n\nJDK提供了4种饱和策略：\n\n> AbortPolicy:默认的饱和策略，当队列满时，将抛出未检查的RejectedExecutionException\n>\n> CallerRunsPolicy:该策略不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量\n>\n> DiscardPolicy:当新提交的任务无法保存到队列时，该策略将抛弃该任务\n>\n> DiscardOldestPolicy:该策略将抛弃下一个被执行的任务，然后重新提交新任务\n\n\n\n### 线程工厂 ###\n\n默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息\n","slug":"thread-pool","published":1,"updated":"2018-08-06T16:30:16.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde3i002wv0f0ya2znvl9","content":"<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>1、Executors中的静态工厂方法：</p>\n<p>newFixedThreadPool:创建一个固定长度的线程池，(无界的阻塞队列LinkedBlockingQueue)</p>\n<p>newSingleThreadExecutor:创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程代替(无界的阻塞队列LinkedBlockingQueue)</p>\n<p><strong>注意：</strong> 以上两个允许请求队列长度为Integer.MAX_VALUE,可能堆积大量的请求，导致OOM</p>\n<p>newCachedThreadPool:创建一个可缓存的线程池，(队列SynchronizedQueue)</p>\n<p>newScheduledThreadPool:创建一个固定长度的线程池，而且以延迟或者定时的方式来执行任务,类似于Timer</p>\n<p><strong>注意：</strong>以上两个允许创建线程数为Integer.MAX_VALUE,可能创建大量线程，导致OOM</p>\n<p>2、ThreadPoolExecutor</p>\n<h3 id=\"创建与销毁\"><a href=\"#创建与销毁\" class=\"headerlink\" title=\"创建与销毁\"></a>创建与销毁</h3><pre><code>public ThreadPoolExecutor(int corePoolSize,\n                      int maximumPoolSize,\n                      long keepAliveTime,\n                      TimeUnit unit,\n                      BlockingQueue&lt;Runnable&gt; workQueue,\n                      ThreadFactory threadFactory,\n                      RejectedExecutionHandler handler) {\n\n}\n</code></pre><p>corePoolSize:没有任务执行时线程池的大小，当工作队列满了的时候，才会创建超出该数量的线程</p>\n<p>maximumPoolSize:表示可同时活动的线程数量的上限</p>\n<p>keepAliveTime:空闲线程存活时间，如果某个线程的空闲时间超过了keepAliveTIme，则被标记为可回收，并且当线程池当前大小超出corePoolSize时，这个线程将被终止。</p>\n<h3 id=\"管理队列任务\"><a href=\"#管理队列任务\" class=\"headerlink\" title=\"管理队列任务\"></a>管理队列任务</h3><p>基本的任务队列有3种：</p>\n<blockquote>\n<p>无界队列</p>\n<p>有界队列</p>\n<p>同步移交</p>\n</blockquote>\n<p>ArrayBlockingQueue</p>\n<p>LinkedBlockingQueue</p>\n<p>PriorityBlockingQueue</p>\n<p>SynchronouseQueue</p>\n<h3 id=\"饱和策略\"><a href=\"#饱和策略\" class=\"headerlink\" title=\"饱和策略\"></a>饱和策略</h3><p>当队列满了以后，饱和策略发挥作用</p>\n<p>JDK提供了4种饱和策略：</p>\n<blockquote>\n<p>AbortPolicy:默认的饱和策略，当队列满时，将抛出未检查的RejectedExecutionException</p>\n<p>CallerRunsPolicy:该策略不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量</p>\n<p>DiscardPolicy:当新提交的任务无法保存到队列时，该策略将抛弃该任务</p>\n<p>DiscardOldestPolicy:该策略将抛弃下一个被执行的任务，然后重新提交新任务</p>\n</blockquote>\n<h3 id=\"线程工厂\"><a href=\"#线程工厂\" class=\"headerlink\" title=\"线程工厂\"></a>线程工厂</h3><p>默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>1、Executors中的静态工厂方法：</p>\n<p>newFixedThreadPool:创建一个固定长度的线程池，(无界的阻塞队列LinkedBlockingQueue)</p>\n<p>newSingleThreadExecutor:创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程代替(无界的阻塞队列LinkedBlockingQueue)</p>\n<p><strong>注意：</strong> 以上两个允许请求队列长度为Integer.MAX_VALUE,可能堆积大量的请求，导致OOM</p>\n<p>newCachedThreadPool:创建一个可缓存的线程池，(队列SynchronizedQueue)</p>\n<p>newScheduledThreadPool:创建一个固定长度的线程池，而且以延迟或者定时的方式来执行任务,类似于Timer</p>\n<p><strong>注意：</strong>以上两个允许创建线程数为Integer.MAX_VALUE,可能创建大量线程，导致OOM</p>\n<p>2、ThreadPoolExecutor</p>\n<h3 id=\"创建与销毁\"><a href=\"#创建与销毁\" class=\"headerlink\" title=\"创建与销毁\"></a>创建与销毁</h3><pre><code>public ThreadPoolExecutor(int corePoolSize,\n                      int maximumPoolSize,\n                      long keepAliveTime,\n                      TimeUnit unit,\n                      BlockingQueue&lt;Runnable&gt; workQueue,\n                      ThreadFactory threadFactory,\n                      RejectedExecutionHandler handler) {\n\n}\n</code></pre><p>corePoolSize:没有任务执行时线程池的大小，当工作队列满了的时候，才会创建超出该数量的线程</p>\n<p>maximumPoolSize:表示可同时活动的线程数量的上限</p>\n<p>keepAliveTime:空闲线程存活时间，如果某个线程的空闲时间超过了keepAliveTIme，则被标记为可回收，并且当线程池当前大小超出corePoolSize时，这个线程将被终止。</p>\n<h3 id=\"管理队列任务\"><a href=\"#管理队列任务\" class=\"headerlink\" title=\"管理队列任务\"></a>管理队列任务</h3><p>基本的任务队列有3种：</p>\n<blockquote>\n<p>无界队列</p>\n<p>有界队列</p>\n<p>同步移交</p>\n</blockquote>\n<p>ArrayBlockingQueue</p>\n<p>LinkedBlockingQueue</p>\n<p>PriorityBlockingQueue</p>\n<p>SynchronouseQueue</p>\n<h3 id=\"饱和策略\"><a href=\"#饱和策略\" class=\"headerlink\" title=\"饱和策略\"></a>饱和策略</h3><p>当队列满了以后，饱和策略发挥作用</p>\n<p>JDK提供了4种饱和策略：</p>\n<blockquote>\n<p>AbortPolicy:默认的饱和策略，当队列满时，将抛出未检查的RejectedExecutionException</p>\n<p>CallerRunsPolicy:该策略不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量</p>\n<p>DiscardPolicy:当新提交的任务无法保存到队列时，该策略将抛弃该任务</p>\n<p>DiscardOldestPolicy:该策略将抛弃下一个被执行的任务，然后重新提交新任务</p>\n</blockquote>\n<h3 id=\"线程工厂\"><a href=\"#线程工厂\" class=\"headerlink\" title=\"线程工厂\"></a>线程工厂</h3><p>默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息</p>\n"},{"title":"原子变量与非阻塞同步机制","date":"2018-07-31T09:54:45.000Z","_content":"\n非阻塞算法：用底层的原子机器指令(比较交换指令)代替锁来确保数据并发访问的一致性。\n\n优点：\n\n> 在粒度更细的层次上进行协调，极大地减少调度开销。\n>\n> 不存在死锁和其它活跃性问题。\n\n## 硬件对并发的支持 ##\n\n处理器实现原子指令：\n\nCAS: 比较并交换(Compare-and-Swap)\n\nLL/SC: 关联加载/条件存储(Load-Linked/Store-Conditional)\n\n### 1、比较并交换 ###\n\nCAS包括3个操作数：\n\n> 需要读写的内存位置V\n> \n> 进行比较的值A\n> \n> 拟写入的新值B\n\n当且仅当V=A时，CAS才会通过原子方式用新值B来更新V的值。\n\n优点：\n\n> 在竞争程度不高时，性能远远超过基于锁\n\n缺点：\n\n> 它使调用者处理竞争问题(通过重试、回退、放弃)，而在锁中能自动处理竞争问题(线程在获得锁之前将一直阻塞)\n\n\n2、","source":"_posts/thread-15.md","raw":"---\ntitle: 原子变量与非阻塞同步机制\ndate: 2018-07-31 17:54:45\ntags: java, 多线程\ncategories: 多线程\n---\n\n非阻塞算法：用底层的原子机器指令(比较交换指令)代替锁来确保数据并发访问的一致性。\n\n优点：\n\n> 在粒度更细的层次上进行协调，极大地减少调度开销。\n>\n> 不存在死锁和其它活跃性问题。\n\n## 硬件对并发的支持 ##\n\n处理器实现原子指令：\n\nCAS: 比较并交换(Compare-and-Swap)\n\nLL/SC: 关联加载/条件存储(Load-Linked/Store-Conditional)\n\n### 1、比较并交换 ###\n\nCAS包括3个操作数：\n\n> 需要读写的内存位置V\n> \n> 进行比较的值A\n> \n> 拟写入的新值B\n\n当且仅当V=A时，CAS才会通过原子方式用新值B来更新V的值。\n\n优点：\n\n> 在竞争程度不高时，性能远远超过基于锁\n\n缺点：\n\n> 它使调用者处理竞争问题(通过重试、回退、放弃)，而在锁中能自动处理竞争问题(线程在获得锁之前将一直阻塞)\n\n\n2、","slug":"thread-15","published":1,"updated":"2018-07-31T10:29:38.726Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlbrde3l002zv0f0z56jf1er","content":"<p>非阻塞算法：用底层的原子机器指令(比较交换指令)代替锁来确保数据并发访问的一致性。</p>\n<p>优点：</p>\n<blockquote>\n<p>在粒度更细的层次上进行协调，极大地减少调度开销。</p>\n<p>不存在死锁和其它活跃性问题。</p>\n</blockquote>\n<h2 id=\"硬件对并发的支持\"><a href=\"#硬件对并发的支持\" class=\"headerlink\" title=\"硬件对并发的支持\"></a>硬件对并发的支持</h2><p>处理器实现原子指令：</p>\n<p>CAS: 比较并交换(Compare-and-Swap)</p>\n<p>LL/SC: 关联加载/条件存储(Load-Linked/Store-Conditional)</p>\n<h3 id=\"1、比较并交换\"><a href=\"#1、比较并交换\" class=\"headerlink\" title=\"1、比较并交换\"></a>1、比较并交换</h3><p>CAS包括3个操作数：</p>\n<blockquote>\n<p>需要读写的内存位置V</p>\n<p>进行比较的值A</p>\n<p>拟写入的新值B</p>\n</blockquote>\n<p>当且仅当V=A时，CAS才会通过原子方式用新值B来更新V的值。</p>\n<p>优点：</p>\n<blockquote>\n<p>在竞争程度不高时，性能远远超过基于锁</p>\n</blockquote>\n<p>缺点：</p>\n<blockquote>\n<p>它使调用者处理竞争问题(通过重试、回退、放弃)，而在锁中能自动处理竞争问题(线程在获得锁之前将一直阻塞)</p>\n</blockquote>\n<p>2、</p>\n","site":{"data":{}},"excerpt":"","more":"<p>非阻塞算法：用底层的原子机器指令(比较交换指令)代替锁来确保数据并发访问的一致性。</p>\n<p>优点：</p>\n<blockquote>\n<p>在粒度更细的层次上进行协调，极大地减少调度开销。</p>\n<p>不存在死锁和其它活跃性问题。</p>\n</blockquote>\n<h2 id=\"硬件对并发的支持\"><a href=\"#硬件对并发的支持\" class=\"headerlink\" title=\"硬件对并发的支持\"></a>硬件对并发的支持</h2><p>处理器实现原子指令：</p>\n<p>CAS: 比较并交换(Compare-and-Swap)</p>\n<p>LL/SC: 关联加载/条件存储(Load-Linked/Store-Conditional)</p>\n<h3 id=\"1、比较并交换\"><a href=\"#1、比较并交换\" class=\"headerlink\" title=\"1、比较并交换\"></a>1、比较并交换</h3><p>CAS包括3个操作数：</p>\n<blockquote>\n<p>需要读写的内存位置V</p>\n<p>进行比较的值A</p>\n<p>拟写入的新值B</p>\n</blockquote>\n<p>当且仅当V=A时，CAS才会通过原子方式用新值B来更新V的值。</p>\n<p>优点：</p>\n<blockquote>\n<p>在竞争程度不高时，性能远远超过基于锁</p>\n</blockquote>\n<p>缺点：</p>\n<blockquote>\n<p>它使调用者处理竞争问题(通过重试、回退、放弃)，而在锁中能自动处理竞争问题(线程在获得锁之前将一直阻塞)</p>\n</blockquote>\n<p>2、</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjlbrddyz0000v0f0b1nlcobc","category_id":"cjlbrddzg0004v0f055tozbek","_id":"cjlbrde0c000gv0f07dl7hrw4"},{"post_id":"cjlbrde01000av0f0xq3zil6u","category_id":"cjlbrde08000ev0f0u5zh5jei","_id":"cjlbrde0t000qv0f097uk7ub4"},{"post_id":"cjlbrde0a000fv0f0ing955cj","category_id":"cjlbrde0m000lv0f00avexqz1","_id":"cjlbrde10000wv0f0gygb8k0l"},{"post_id":"cjlbrde0k000kv0f0mus972b5","category_id":"cjlbrde0u000rv0f0ue9c8y7b","_id":"cjlbrde170012v0f0kwuqnrl7"},{"post_id":"cjlbrde12000zv0f0jo87zaj4","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde1e0018v0f0gzf1fxd3"},{"post_id":"cjlbrde0p000nv0f09vauho5d","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde1i001bv0f0ag5c0mxn"},{"post_id":"cjlbrde150011v0f0r3xpoxx0","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde1n001fv0f039eq5epo"},{"post_id":"cjlbrde0w000tv0f0i9itrhnq","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde1r001iv0f00mn86i73"},{"post_id":"cjlbrde1c0017v0f0cxl87p87","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde1u001lv0f04810719d"},{"post_id":"cjlbrde1g001av0f0pjej7fxv","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde1x001ov0f04018db0u"},{"post_id":"cjlbrde0y000vv0f0yypfc0bd","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde21001sv0f0s4repw3o"},{"post_id":"cjlbrde20001rv0f0s8a5lks9","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde2b0020v0f0anm6oqyw"},{"post_id":"cjlbrde1s001kv0f0kjyxudnc","category_id":"cjlbrde1z001qv0f0n3vq6qdk","_id":"cjlbrde2f0023v0f0u8d91yrk"},{"post_id":"cjlbrde1v001nv0f0d4k2lat2","category_id":"cjlbrde28001xv0f041ygreno","_id":"cjlbrde2r0029v0f0d13bfe9o"},{"post_id":"cjlbrde2d0022v0f0ln924jaz","category_id":"cjlbrde1z001qv0f0n3vq6qdk","_id":"cjlbrde2u002dv0f06vjg8yqz"},{"post_id":"cjlbrde23001uv0f0tj0xq2cz","category_id":"cjlbrde2f0024v0f0gag2pbjn","_id":"cjlbrde2y002gv0f0th70swf8"},{"post_id":"cjlbrde2o0028v0f0bh125x57","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde32002jv0f07zfjnlwc"},{"post_id":"cjlbrde2t002cv0f0ca5fgufn","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde35002nv0f09ujufu7p"},{"post_id":"cjlbrde26001wv0f03f6ybh9v","category_id":"cjlbrde2r002av0f0nyxov0lq","_id":"cjlbrde39002qv0f01czd1j3z"},{"post_id":"cjlbrde33002lv0f0c0h4nnzr","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde3g002uv0f0hiu6xu3u"},{"post_id":"cjlbrde37002ov0f0kso0om9q","category_id":"cjlbrddzg0004v0f055tozbek","_id":"cjlbrde3k002xv0f00lbexs3h"},{"post_id":"cjlbrde2w002ev0f0ajgt5gal","category_id":"cjlbrde32002kv0f0eo9bz0i9","_id":"cjlbrde3n0030v0f0cv1mavhi"},{"post_id":"cjlbrde3e002tv0f04w0ou523","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde3p0032v0f0l65lva6q"},{"post_id":"cjlbrde3i002wv0f0ya2znvl9","category_id":"cjlbrde10000xv0f06mx5cnuf","_id":"cjlbrde3r0035v0f0d4frfdqz"},{"post_id":"cjlbrde3l002zv0f0z56jf1er","category_id":"cjlbrde3q0033v0f0i6yp4k4m","_id":"cjlbrde3u0039v0f0izr07jz0"}],"PostTag":[{"post_id":"cjlbrddyz0000v0f0b1nlcobc","tag_id":"cjlbrddzn0005v0f02oio6ont","_id":"cjlbrde04000cv0f0ge5oyuz9"},{"post_id":"cjlbrddzb0002v0f0ocvl25n1","tag_id":"cjlbrde03000bv0f0gdj37kh4","_id":"cjlbrde0j000jv0f01mowr5pn"},{"post_id":"cjlbrde01000av0f0xq3zil6u","tag_id":"cjlbrde03000bv0f0gdj37kh4","_id":"cjlbrde0r000ov0f0b9j31j3q"},{"post_id":"cjlbrde0a000fv0f0ing955cj","tag_id":"cjlbrde0o000mv0f0ja23rpuk","_id":"cjlbrde0x000uv0f08avq6iox"},{"post_id":"cjlbrde0k000kv0f0mus972b5","tag_id":"cjlbrde0v000sv0f07ishhof0","_id":"cjlbrde140010v0f00u840ieg"},{"post_id":"cjlbrde0p000nv0f09vauho5d","tag_id":"cjlbrde11000yv0f0aqbhvtno","_id":"cjlbrde1c0016v0f07s14lh1t"},{"post_id":"cjlbrde1c0017v0f0cxl87p87","tag_id":"cjlbrde11000yv0f0aqbhvtno","_id":"cjlbrde1k001dv0f0mouudn7o"},{"post_id":"cjlbrde0w000tv0f0i9itrhnq","tag_id":"cjlbrde1a0015v0f07wycqvan","_id":"cjlbrde1o001gv0f06kej7h0d"},{"post_id":"cjlbrde0y000vv0f0yypfc0bd","tag_id":"cjlbrde11000yv0f0aqbhvtno","_id":"cjlbrde1u001mv0f0qf2teh2p"},{"post_id":"cjlbrde12000zv0f0jo87zaj4","tag_id":"cjlbrde1r001jv0f05yiyci33","_id":"cjlbrde22001tv0f0h6yfcmoa"},{"post_id":"cjlbrde150011v0f0r3xpoxx0","tag_id":"cjlbrde1r001jv0f05yiyci33","_id":"cjlbrde28001yv0f0pvnuqo42"},{"post_id":"cjlbrde1g001av0f0pjej7fxv","tag_id":"cjlbrde1r001jv0f05yiyci33","_id":"cjlbrde2g0025v0f01g0yir9a"},{"post_id":"cjlbrde1s001kv0f0kjyxudnc","tag_id":"cjlbrde2c0021v0f0ar3uw2cv","_id":"cjlbrde2s002bv0f0unxqhg63"},{"post_id":"cjlbrde1v001nv0f0d4k2lat2","tag_id":"cjlbrde2n0027v0f0ai3jiuah","_id":"cjlbrde2z002hv0f0ummmy3qg"},{"post_id":"cjlbrde20001rv0f0s8a5lks9","tag_id":"cjlbrde2x002fv0f088k1x3jp","_id":"cjlbrde38002pv0f0rp6g7fmh"},{"post_id":"cjlbrde23001uv0f0tj0xq2cz","tag_id":"cjlbrde35002mv0f0m6d0prd9","_id":"cjlbrde3h002vv0f0qqsuw6bs"},{"post_id":"cjlbrde26001wv0f03f6ybh9v","tag_id":"cjlbrde3c002sv0f0w6ymin59","_id":"cjlbrde3o0031v0f0nkj07bv3"},{"post_id":"cjlbrde29001zv0f00chj5hxw","tag_id":"cjlbrde35002mv0f0m6d0prd9","_id":"cjlbrde3s0036v0f0pd5jurvu"},{"post_id":"cjlbrde2d0022v0f0ln924jaz","tag_id":"cjlbrde3q0034v0f0thfn0xjr","_id":"cjlbrde3u0038v0f0ufjo6htp"},{"post_id":"cjlbrde2h0026v0f0o6tenvc0","tag_id":"cjlbrde3t0037v0f0zewtmj71","_id":"cjlbrde3w003bv0f0dd1v5fe7"},{"post_id":"cjlbrde2o0028v0f0bh125x57","tag_id":"cjlbrde3v003av0f06hwrbyl5","_id":"cjlbrde3y003dv0f0tqcfai6b"},{"post_id":"cjlbrde2t002cv0f0ca5fgufn","tag_id":"cjlbrde3x003cv0f0ra30z9po","_id":"cjlbrde40003fv0f0uouaujco"},{"post_id":"cjlbrde2w002ev0f0ajgt5gal","tag_id":"cjlbrde3z003ev0f0rtky28ma","_id":"cjlbrde42003hv0f08t3kjy4h"},{"post_id":"cjlbrde33002lv0f0c0h4nnzr","tag_id":"cjlbrde41003gv0f0q3fpye4m","_id":"cjlbrde46003jv0f0qnfs9hti"},{"post_id":"cjlbrde37002ov0f0kso0om9q","tag_id":"cjlbrde44003iv0f0ty4997dt","_id":"cjlbrde48003lv0f00x4uuwde"},{"post_id":"cjlbrde3e002tv0f04w0ou523","tag_id":"cjlbrde47003kv0f0m4ly0l3b","_id":"cjlbrde49003nv0f0qazkcmja"},{"post_id":"cjlbrde3i002wv0f0ya2znvl9","tag_id":"cjlbrde47003kv0f0m4ly0l3b","_id":"cjlbrde4c003pv0f0zktulv6h"},{"post_id":"cjlbrde3l002zv0f0z56jf1er","tag_id":"cjlbrde47003kv0f0m4ly0l3b","_id":"cjlbrde4d003qv0f0efrgvbm6"}],"Tag":[{"name":"life, thirty","_id":"cjlbrddzn0005v0f02oio6ont"},{"name":"周报, 技术","_id":"cjlbrde03000bv0f0gdj37kh4"},{"name":"algorithms, java, go","_id":"cjlbrde0o000mv0f0ja23rpuk"},{"name":"语言, go","_id":"cjlbrde0v000sv0f07ishhof0"},{"name":"java, 集合","_id":"cjlbrde11000yv0f0aqbhvtno"},{"name":"java, annotation","_id":"cjlbrde1a0015v0f07wycqvan"},{"name":"java, jvm","_id":"cjlbrde1r001jv0f05yiyci33"},{"name":"mysql, 索引","_id":"cjlbrde2c0021v0f0ar3uw2cv"},{"name":"java, 爬虫","_id":"cjlbrde2n0027v0f0ai3jiuah"},{"name":"java, threadlocal","_id":"cjlbrde2x002fv0f088k1x3jp"},{"name":"树莓派","_id":"cjlbrde35002mv0f0m6d0prd9"},{"name":"raspberry, python, 人脸识别","_id":"cjlbrde3c002sv0f0w6ymin59"},{"name":"mysql,","_id":"cjlbrde3q0034v0f0thfn0xjr"},{"name":"Scala, 函数式编程","_id":"cjlbrde3t0037v0f0zewtmj71"},{"name":"java, spring, ioc","_id":"cjlbrde3v003av0f06hwrbyl5"},{"name":"java","_id":"cjlbrde3x003cv0f0ra30z9po"},{"name":"spring, 事务","_id":"cjlbrde3z003ev0f0rtky28ma"},{"name":"java, springboot, 源码","_id":"cjlbrde41003gv0f0q3fpye4m"},{"name":"life, reading","_id":"cjlbrde44003iv0f0ty4997dt"},{"name":"java, 多线程","_id":"cjlbrde47003kv0f0m4ly0l3b"}]}}