<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[oracle-login]]></title>
    <url>%2F2019%2F12%2F06%2Foracle-login%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js中的编译管理]]></title>
    <url>%2F2019%2F11%2F27%2Fjs-compile%2F</url>
    <content type="text"><![CDATA[最开始接触过scss文件的编译，BootStrap还是在使用scss编写样式 BabelWebpackLessgruntgulpyarnnpmBrowserifyCommonJSRequireJSSystemJS]]></content>
  </entry>
  <entry>
    <title><![CDATA[jvm日志分析]]></title>
    <url>%2F2019%2F11%2F14%2Fjava-jvm-gclog%2F</url>
    <content type="text"><![CDATA[通用参数-Xmx-Xms-Xmn-XX:+PrintGC / -XX:+PrintGCDetails-XX:+PrintHeapAtGC-Xloggc 日志文件存放位置-XX:+PrintGCDateStamps 打印每个年代对象分布情况-XX:+PrintGCDateStamps / -XX:+PrintGCTimeStamps-XX:+PrintGCApplicationStoppedTime-XX:+PrintGCApplicationConcurrentTime 打印除了GC之外引起JVM STW的时间-XX:+PrintSafepointStatistics-XX:PrintSafepointStatisticsCount=1 收集器特殊参数]]></content>
  </entry>
  <entry>
    <title><![CDATA[java永久代、元数据区]]></title>
    <url>%2F2019%2F11%2F14%2Fjava-jvm-permgen%2F</url>
    <content type="text"><![CDATA[今天在维护一个jsp + tomcat的老项目中，开始使用JRE1.8运行，没有问题，切换到JRE1.7运行就报错: java.lang.OutOfMemoryError: PermGen space 添加运行时参数-XX:MaxPermSize=512m解决问题，这里涉及到jvm运行时内存的变化。 永久代 Perm GenPermGen存在于jdk1.7-版本中，主要存储内容： class类的名称、字段、方法字节码常量池对象数组/类型数组的classJIT编译后的class信息 元数据区 Metaspace]]></content>
  </entry>
  <entry>
    <title><![CDATA[mqtt-base]]></title>
    <url>%2F2019%2F10%2F30%2Fmqtt-base%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[DevOps软件架构师行动指南]]></title>
    <url>%2F2019%2F10%2F12%2Fread-devops%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[瓶颈期]]></title>
    <url>%2F2019%2F10%2F09%2Fthinking-in-bottleneck%2F</url>
    <content type="text"><![CDATA[这一段时间，我一直在思考的一个问题就是：我和别人到底差在哪里？我迷茫、困惑，陷入一个万劫不复的僵局，困在其中，却无法突破。也许这就是所谓的瓶颈期。 从去年开始，我一直待在教育这个行业。在大的方向上，我喜欢过两个行业–教育、文化，每一个都是那种真挚而热烈的喜欢。可让我困惑的是，竟然始终未找到自己真心热爱去创造的东西。我承认自己多多少少有点理想主义，但我真心希望能够做出让人惊艳的产品。在这短短的时间里，我竟然一直换了好几份工作，辞职后的这段时间里，我在想为什么？ 某联科技：你为什么离职？：产品规划了一年，还是没有落地，而且方向越来越不明确 某德教育：你为什么离职？：你经历过女领导给你穿小鞋吗？公司新起的项目，前期一直没有一个统筹的领导，中间突然来了一个女产品，任产品总监，为了争夺权力，开始勾心斗角 某来教育：你为什么离职？我开始思考经历的一切，让我得出一下结论：1、部门对接问题，你很难理解，在这样的公司，对接竟然一直存在问题，尤其是前期，两个系统并行开发， 就导致很多开发的内容需要不断的调整，更为恶心的是产品不画原型！我是从来没有经历过这种事情的，激情慢慢的消褪；2、同事的问题，中间内部对接的有一位同事是某理毕业，虽然我并非名校，但是一些经验上，明明是对的，她竟然为自己辩护，原来接受过高等教育的人也会这么不辨是非；3、领导的问题，一次述职，我觉得自己表达的虽然没有那么完美，但是过程中领导那种傲慢的姿态，还因为一个http状态码的问题问我看过RFC文档吗？实际上跟RFC没有任何关系 某浦教育：你为什么离职？：三个月内，同事换了好几波，公司文化氛围实在让人不理解 有时候，我在想，是不是互联网产品注定了快速试水、快速迭代、最后快速消失？而当初那些怀着梦想–’代码改变世界’的人注定消失在人海？期间我甚至想过去当一个图书管理员，Linux毫无疑问是最伟大的软件，可如何用软件改变人们的生活？让我一直在问：make the world better or worse?]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务--链路监控()]]></title>
    <url>%2F2019%2F09%2F11%2Fspring-cloud-slueth%2F</url>
    <content type="text"><![CDATA[链路监控主要用来监控 SleuthCAT]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kong网关--]]></title>
    <url>%2F2019%2F08%2F29%2Fkong-base%2F</url>
    <content type="text"><![CDATA[Centos7安装yum install -y gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel 如果配置了yum源，可以直接yum安装 配置yum源sudo yum update -y sudo yum install -y wget wget https://bintray.com/kong/kong-rpm/rpm -O bintray-kong-kong-rpm.repo export major_version=`grep -oE &apos;[0-9]+\.[0-9]+&apos; /etc/redhat-release | cut -d &quot;.&quot; -f1` sed -i -e &apos;s/baseurl.*/&amp;\/centos\/&apos;$major_version&apos;&apos;/ bintray-kong-kong-rpm.repo sudo mv bintray-kong-kong-rpm.repo /etc/yum.repos.d/ sudo yum update -y sudo yum install -y kong 有数据库模式依赖于PostgreSQL 创建kong.conf cp /etc/kong/kong.conf.default /etc/kong/kong.conf 报错： Error: [PostgreSQL error] failed to check legacy schema state: ERROR: function to_regclass(unknown) does not exist (12) Run with –v (verbose) or –vv (debug) for more details解决方案：postgresql版本不兼容问题，升级psql 无数据库模式启动kong监控UIkong-dashboard 1、2、重新启动报错：kong-dashboard start –kong-url http://kong:8001Connecting to Kong on http://kong:8001 …Could not reach Kong on http://kong:8001Error details:{ Error: getaddrinfo ENOTFOUND kong kong:8001 at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:56:26) errno: ‘ENOTFOUND’, code: ‘ENOTFOUND’, syscall: ‘getaddrinfo’, hostname: ‘kong’, host: ‘kong’, port: ‘8001’ } konga]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-assign]]></title>
    <url>%2F2019%2F08%2F20%2Fes6-assign%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Serverless是什么]]></title>
    <url>%2F2019%2F08%2F16%2Fserverless-base%2F</url>
    <content type="text"><![CDATA[Serverless是什么？很多地方看到serverless的文章，官方文档说：首先是一个框架。包含多个微服务的应用；事件响应，自动扩容；仅仅在运行时收费，更高于云服务平台。 从IaaS， 到SaaS，再到Paas。重新提出一种新的架构FaaS 教程阿里云也有在做，以下以AWS为例。 附录中间需要用到AWS账号，没有账号的需要申请。 创建AWS账号]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud微服务--网关]]></title>
    <url>%2F2019%2F08%2F15%2Fspring-cloud-zuul%2F</url>
    <content type="text"><![CDATA[nginx、zuul、gateway、kong都是网管组件。 Nginx限流模块nginx使用漏桶算法 limit_req_zonelimit_req_conn 限流Zuul1 / Zuul2过滤器Filter按照生命周期大约有4种过滤器： pre routing post error 限流主流的有4种限流方式： 根据认证用户 根据原始请求 根据URL 根据ServiceId 插件zuul-ratelimit Kongkong可以说是nginx的升级版，基于OpenResty。 核心 upstream target service route]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置文件加载bug]]></title>
    <url>%2F2019%2F08%2F14%2Fspring-boot-bootstrap%2F</url>
    <content type="text"><![CDATA[IDEA环境以前曾经遇到过，通过添加依赖包可以解决，而且，创建的maven模块有时候正常，有时候出现该问题，问题的根本还是不太懂 问题描述未加载前bootstrap文件为yml格式，但是并未识别为配置文件 查看模块设置Open Module Settings - Module，发现并未自动检测，没有找到任何手动添加设置 加载后添加spring-cloud-context，bootstrap文件可以被正常检测 迷 加载原理]]></content>
  </entry>
  <entry>
    <title><![CDATA[mac-multi-mysql]]></title>
    <url>%2F2019%2F08%2F08%2Fmac-multi-mysql%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络--概览]]></title>
    <url>%2F2019%2F08%2F03%2Fnet-overview%2F</url>
    <content type="text"></content>
      <tags>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go--csp并发模型]]></title>
    <url>%2F2019%2F07%2F16%2Fgo-csp%2F</url>
    <content type="text"><![CDATA[go引入了协程的概念，使用goroutine通过channel通信]]></content>
  </entry>
  <entry>
    <title><![CDATA[Consul环境]]></title>
    <url>%2F2019%2F07%2F03%2Fconsul-base%2F</url>
    <content type="text"><![CDATA[原来一直用Eureka Server，现在尝试用Consul. LinuxMac安装brew install consul 启动consul agent -dev 访问管理页面地址 http://127.0.0.1:8500/ui/dc1/services Docker]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue-lifecycle]]></title>
    <url>%2F2019%2F06%2F28%2Fvue-lifecycle%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Vue--数据传递]]></title>
    <url>%2F2019%2F06%2F28%2Fvue-data%2F</url>
    <content type="text"><![CDATA[组件之间的数据传递 父传子子传父Event Bus可以平级传数 Vuex传递]]></content>
  </entry>
  <entry>
    <title><![CDATA[js-icon]]></title>
    <url>%2F2019%2F06%2F24%2Fjs-icon%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity--SAAS平台设计思路(七)]]></title>
    <url>%2F2019%2F06%2F21%2Fspring-security-saas%2F</url>
    <content type="text"><![CDATA[最近要做一个saas平台，20171年的时候选用的是Shiro实现，考虑到SpringSecurity可以完美的整合Oauth2.0/OpenID RBAC模型 安全原则 最小权限原则 责任分离原则 数据抽象原则 页面权限功能权限数据权限 数据模型用户 角色：可以按照部门、岗位、]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity--原理与流程(二)]]></title>
    <url>%2F2019%2F06%2F21%2Fspring-security-flow%2F</url>
    <content type="text"><![CDATA[从启动，到权限认证过程 流程图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity--过滤器(三)]]></title>
    <url>%2F2019%2F06%2F21%2Fspring-security-filter%2F</url>
    <content type="text"><![CDATA[实现权限的框架，无非都是一些filter过滤 SpringSecurity有十多种filter， filter流程时序图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity--整合jwt(六)]]></title>
    <url>%2F2019%2F06%2F21%2Fspring-security-jwt%2F</url>
    <content type="text"><![CDATA[jwt模式，web请求模式中分：有状态模无状态模式。一般基于session的就是有状态模式，基于token的是无状态模式。而jwt的token可以存储用户信息，个人认为也算是一种有状态模式。 实战原理Securtiy默认是基于session会话的模式，jwt既然基于token的模式，就要关闭session。 宏观上来看执行流程：源码分析Security对SecurityContext的存储也是分session状态：(1) 完全无session状态，可以看到SecurityContext使用NullSecurityContextRepository存储，每次请求创建新的上下文context。 (2) session禁用状态，使用HttpSessionSecurityContextRepository存储，每次请求根据session会话获取上下文context。这样如果请求request中携带JSESSIONID就会存储相应的用户信息 SecurityContextRepository类从名字也可看出就是一个存储仓库，对比两个不同的实现。 而且，注意tomcat本身也有session，如果请求中带有session会话，也会导致tomcat存储信息]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity--整合oauth2(五)]]></title>
    <url>%2F2019%2F06%2F21%2Fspring-security-oauth2%2F</url>
    <content type="text"><![CDATA[oauth2.0有4种认证模型 原理在客户端和服务端中间，设置了一个授权层，客户端不能登陆服务端，只能登录中间授权层。 第一阶段使用account + secret登录中间层，获得token 第二阶段开始使用token进行权限验证]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity--概览(一)]]></title>
    <url>%2F2019%2F06%2F21%2Fspring-security-base%2F</url>
    <content type="text"><![CDATA[权限模型 权限控制模型自主访问控制 DAC强制访问控制 MAC通过硬件实现 场景：安全要求较高的军事系统 基于角色的访问控制 RBACRBAC0 基本模型U 用户R 角色P 权限 RBAC1 角色分级模型 一般继承关系：允许角色之间多继承关系 受限继承关系：角色继承是一个树形的单继承关系 优点：缺点：适用场景： RBAC2 角色限制模型 静态分离：互斥的角色不能赋给同一个用户 动态分离：用户不能使用两个互斥的角色登录 RBAC3 统一模型用户管理角色角色关联权限 基于属性的访问控制 ABAC属性 用户属性 用户年龄 环境属性 当前时间 操作属性 读/写 资源属性 文章/图片 权限对象模型按 分类：页面权限 用户可以看到那些页面；操作权限 用户可以在页面内进行那些操作，增删改查等；数据权限 用户可以看到那些数据或内容； 按 分类：功能权限数据权限]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux--零拷贝]]></title>
    <url>%2F2019%2F06%2F17%2Flinux-zerocopy%2F</url>
    <content type="text"><![CDATA[linux中的零拷贝技术 I/O原理普通I/O：应用程序或者运行在用户模式下的库函数访问硬件设备时，I/O操作需要 硬件和系统之间的零拷贝 软件和系统之间的零拷贝 mmap局限性SIGBUS中断其他进程同时对文件的操作导致write系统调用中断 解决方法： 方案1. 增加SIGBUS错误信号处理方案2. 对文件加锁，当有其它的进程对文件进行操作时，触发SIGBUS中断 sendfile局限性数据污染叶缓存可能被污染 改进版sendfile文件描述符拷贝 splice应用FileChannel类 MappedByteBuffer类]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat--类加载模型(五)]]></title>
    <url>%2F2019%2F06%2F16%2Ftomcat-classloader%2F</url>
    <content type="text"><![CDATA[tomcat类加载器破坏了jvm的双亲委派机制 原理1234567891011121314151617181920212223242526package org.apache.catalina.startup;/** * Daemon reference. */private Object catalinaDaemon = null;ClassLoader commonLoader = null;ClassLoader catalinaLoader = null;ClassLoader sharedLoader = null;private void initClassLoaders() &#123; try &#123; commonLoader = createClassLoader("common", null); if (commonLoader == null) &#123; // no config file, default to this loader - we might be in a 'single' env. commonLoader = this.getClass().getClassLoader(); &#125; catalinaLoader = createClassLoader("server", commonLoader); sharedLoader = createClassLoader("shared", commonLoader); &#125; catch (Throwable t) &#123; handleThrowable(t); log.error("Class loader creation threw exception", t); System.exit(1); &#125;&#125; 类加载器 tomcat可见性 webapp可见性 commonLoader 可见 可见 catalinaLoader 可见 不可见 sharedLoader 不可见 可见 WebappClassLoader 不可见 只对当前web可见 原因 jar类库隔离：tomcat可以部署多个应用，如果引用多个不同版本的jar，类实现不同，所以需要加载不同的jar包 jar类库共享：如果jar版本相同，则只加载一份 安全隔离：tomcat自身的类加载器和web应用的类加载器隔离 热加载：jsp修改后不需要重启也可以刷新，这样就需要动态加载jsp文件]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-jmx]]></title>
    <url>%2F2019%2F06%2F16%2Fjava-jmx%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[前端中的布局方式]]></title>
    <url>%2F2019%2F06%2F16%2Fjs-layout%2F</url>
    <content type="text"><![CDATA[不同的布局方式 Flex布局特点： 伸缩容器 主轴、侧轴配置简单 子元素沿着容器对齐 微信小程序中的应用displayflex 行内元素block 块元素 flex-directionrowrow-reversecolumncolumn-reverse 轴对齐方式justify-contentalign-items Grid布局实际场景两列自适应布局margin + float左列定宽，右列自适应 absolutefloat + BFCtable布局flex布局]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tomcat启动流程(二)]]></title>
    <url>%2F2019%2F06%2F15%2Ftomcat-startup%2F</url>
    <content type="text"><![CDATA[tomcat启动流程]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析JavaScript ECMAScript TypeScript COffeScript]]></title>
    <url>%2F2019%2F06%2F14%2Fes6-ts%2F</url>
    <content type="text"><![CDATA[JS框架层出不穷， ECMAScript ECMAScript6的目标是使得JavaScript语言可以用来编写大型的复杂的应用程序，于是增添了许多特性，例如：模块和类，Maps、Sets、Promises、生成器（Generators）等。尽管ECMAScript6做了大量的更新，但标准化委员会仍然决定要兼容以前的版本，但随之而来的问题是，目前主流的宿主环境（无论是浏览器环境还是服务器环境）不能完全支持ES6，导致了开发者真正要使用ECMAScript6时，需要将ECMAScript6代码进行转译。 TypeScript TypeScript 是一种微软开源的编程语言。由于JavaScript是弱类型的，TypeScript为JavaScript扩展类和模块的概念。正是由于TypeScript最大的特点是类型化，因此才叫做TypeScript。TypeScript支持ECMAScript6标准（实际上相当于是对ECMAScript6的提前实现），并且能将代码根据需求转换为 ES3/5/6。这意味着开发者可以通过TypeScript使用最新的ECMAScript特性，无需再考虑兼容性的问题。 TypeScript分类 一个是类似 Babel 的阵营，坚持JavaScript 的语法风格编写，为开发者提供最新的 ECMAScript 特性； 另一个则是Coffeescript、Clojure、Dart等的阵营，它们的语法与 JavaScript 迥然不同，但最终会编译为JavaScript；]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tomcat--设计模式(四)]]></title>
    <url>%2F2019%2F06%2F13%2Ftomcat-pattern%2F</url>
    <content type="text"></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat请求过程--NIO(三)]]></title>
    <url>%2F2019%2F06%2F13%2Ftomcat-nio%2F</url>
    <content type="text"><![CDATA[tomcat处理请求的NIO是基于jdk的NIO操作]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo-base]]></title>
    <url>%2F2019%2F06%2F13%2Fdubbo-base%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[微服务--路由器(五)]]></title>
    <url>%2F2019%2F06%2F12%2Fspring-cloud-ribbon%2F</url>
    <content type="text"><![CDATA[在wei服务中刚开始使用dubbo通信，后来改为ribbon/feign，feign实际上是在ribbon上又封装了一层 RibbonFeignOpenFeign]]></content>
  </entry>
  <entry>
    <title><![CDATA[java中特殊类Object]]></title>
    <url>%2F2019%2F06%2F10%2Fjava-object%2F</url>
    <content type="text"><![CDATA[Object是所有类的父类。 Object类方法结构： equals、hashCodewait、notify、notifyAll原理：obj.wait(), obj.notify()必须在synchronized(obj)语句块内，wait释放对象锁，线程休眠。notify唤醒线程，但不会马上释放对象锁。synchronized执行结束，自动释放锁后，jvm层在持有wait对象锁的线程中随机选取一线程，赋予对象锁，唤醒线程。 虚假唤醒： 注意：lost wake up问题 wait/notify/notify必须在锁对象的synchronized同步块内。 因为这三个方法都是释放锁的，如果没有synchronized先获取锁就调用释放锁会引起异常. java.util.concurrent.locks.Condition类中的await/signal也必须在同步块内 案例： 12 wait/notify的缺点： 线程B通知线程A时，线程A必须在wait调用上等待，否则线程A永远不会被唤醒 notify只能唤醒一个线程，而notifyAll则唤醒全部线程 改进方案LockSupport: 原理：LockSupport使用：park：等待许可，类似于waitunpark：提供许可，类似于notifypark和unpark之间没有时序问题，最底层通过Posix的mutex、condition实现。 12 对比相同点： wait/park都会阻塞线程，释放锁 上层表现机制不一样，系统层面都是通过中断实现 不同点： wait/notify/notifyAll针对的是对象，而且notify不能唤醒某个具体线程；LockSupport可以具体到某一个线程 实现原理不同，wait/notify基于；LockSupport底层基于Unsafe.park实现 wait完成同步，需要依赖监视器锁；LockSupport可以使用getBlocker监视锁的持有情况]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络中的NAT、P2P]]></title>
    <url>%2F2019%2F06%2F07%2Fnet-nat%2F</url>
    <content type="text"><![CDATA[网络其实相当有意思，接触NAT主要是在VMware中用到过，一种是懵懵懂懂。 Bridge桥接模式， 每个新建的虚拟机系统都是局域网内和宿主机对等的独立主机，需要手动分配一个和宿主机同IP段的IP地址可以访问公网 Host-only主机模式， 虚拟环境和宿主真实环境隔离，虚拟机无法访问公网 NAT网络地址转换器， 可以通过宿主机访问公网虚拟机和宿主机可以互相访问，但是和宿主机之外的局域网主机无法互通 Basic NATNAPT网络地址-端口转换器 Cone NAT锥形NAT Full Cone NAT全锥形NAT Restricted Cone NAT受限锥形NAT Port-Restricted Cone NAT端口受限型NAT 对称NATP2P通信Relaying中继 Connection reversal逆向连接 UDP hole punchingUDP打洞 端点在不同的NAT之下端点在相同的NAT之下固定端口绑定]]></content>
      <tags>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis概览(一)]]></title>
    <url>%2F2019%2F06%2F07%2Fredis-base%2F</url>
    <content type="text"><![CDATA[Redis作为NoSQL数据库，第一次接触就感觉简直让人惊艳 版本介绍单机模式集群模式]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis中的跳表(二)]]></title>
    <url>%2F2019%2F06%2F07%2Fredis-skiplist%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis哨兵机制(七)]]></title>
    <url>%2F2019%2F06%2F07%2Fredis-election%2F</url>
    <content type="text"><![CDATA[redis引入了哨兵机制 哨兵机制一主一从启动哨兵机制，可以对主从数据库进行监控 一主多从启动多个哨兵(建议3个，并且使用奇数个哨兵)，可以对主从数据库进行监控，哨兵之间也可以互相通信。哨兵主要功能： 监控：监控master和slave是否运行正常 提醒：某个redis出现故障，可以发起通知 自动故障转移：当一个master不能正常工作时，将master下其中一个slave转为master 补充：为什么哨兵至少3个？ 原理每个哨兵会向其它哨兵、master、slave定时发送消息，保持心跳。如果指定时间未回应，则认为对方主观下线；若多数哨兵都认为某一服务没响应，则认为客观下线 Gossip协议用于接收master是否下线的消息 选举master协议用来决定是否执行故障转移，以及slave中的选主选主会有两个过程： Sentinel哨兵选出leader当某个哨兵节点确认master主管下线后，发出广播请求其它哨兵选举自己为leader，被请求的哨兵如果没有选举过其它哨兵的请求，则同意该请求，否则不同意当哨兵节点票数达到Max(quorum, num(sentinel)/2 + 1)，则升级为leader Sentinel Leader选举主节点mastermaster选举： slave-priority在conf中配置]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[etcd-raft]]></title>
    <url>%2F2019%2F06%2F06%2Fetcd-raft%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ZooKeeper基于TCP的FastLeader(四)]]></title>
    <url>%2F2019%2F06%2F06%2Fzk-fastleader3%2F</url>
    <content type="text"><![CDATA[TCP选举算法 核心结构myid对应服务器在集群中的唯一ID zxid类似于事务ID，顺序递增 | 高32位 | 低32位 |epoch_h：用于标记leader的epoch，从1开始，每次选举出新的leader，epoch_h加1， epoch_l：用于标记epoch_h内的版本，epoch_h改变后，epoch_l会被重置 状态服务器状态：looking：leading：following：observing: 选票数据结构选举领导时会进行投票，投票的数据结构： logicClock: 表示该服务器发起的是第几轮投票，每个服务器都维护一个自增的logicClockstate: 当前服务器状态self_id: 当前服务器的myidself_zxid: zxidvote_id: 被推选的的服务器的myidvote_zxid: 被推选的服务器zxid 选举流程选举过程很重要，也很复杂，做了一个流程图，不合理的回头补充： 投票过程数据结构: (logicClock, myid, zxid)投票箱存储结构：(投票服务器id, 被推选服务器id)]]></content>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZooKeeper选举算法基础(三)]]></title>
    <url>%2F2019%2F06%2F06%2Fzk-election-base%2F</url>
    <content type="text"><![CDATA[选举算法有多种 选举算法electionAlg配置： 0：基于UDP的LeaderElection 1：基于UDP的FastLeaderElection 2：基于UDP和认证的FastLeaderElection 3：基于TCP的FastLeaderElection(新版本默认算法)]]></content>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZooKeeper选举过程(五)]]></title>
    <url>%2F2019%2F06%2F06%2Fzk-crash-election%2F</url>
    <content type="text"><![CDATA[zk集群有正常启动过程，也会有leader/follower崩溃重启、网络分区问题，这样就导致需要重新选举 正常集群启动选举Leader重启选举leader由于故障崩溃、或者网络分区导致不可连接。选举流程图： Follower重启选举follower由于故障崩溃、或者网络分区导致不可连接。选举流程图：]]></content>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZooKeeper分布式锁(六)]]></title>
    <url>%2F2019%2F06%2F06%2Fzk-lock%2F</url>
    <content type="text"><![CDATA[zk典型的应用是可以作为分布式锁。 zk分布式锁的特性zk作为分布式锁主要利用的还是临时节点、顺序性的特性 最多只有一个获取锁：最多只有一个进程获取锁 释放锁：获取锁的进程可以主动释放锁；进程宕机后也可以释放锁 锁重入：获取锁的进程在释放锁之前可以重新进入 感知释放锁：等待锁的进程可以感知到锁的释放，并且重新竞争锁 锁实现公平式锁基于临时节点 + 顺序性，这样创建相同的节点时，都可以创建成功，但是节点具有顺序性，每个获取锁的进程判断自己是否是最小顺序的节点来获取锁 非公平式锁基于临时节点 + 非顺序性，这样创建相同的节点时，只能有一个创建成功，即获得锁 排他锁共享锁]]></content>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis概览(一)]]></title>
    <url>%2F2019%2F06%2F04%2Fmybatis-base%2F</url>
    <content type="text"><![CDATA[终究还是要自己来分析源码了，网上有很多MyBatis的源码分析，自己决定做，一来是加深印象；二来摸索源码分析的方法论。很多时候看源码一脸懵逼，不知道该从哪里看，看完没有形成思路。 MyBatismybatis结构图： 在我看来mybatis核心功能主要有3个：1、xml/注解的解析(包括config配置、mapper)2、一级缓存，二级缓存3、事务 MyBatis和Spring整合mybatis和Spring整合插件结构图：]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis缓存(三)]]></title>
    <url>%2F2019%2F06%2F04%2Fmybatis-cache%2F</url>
    <content type="text"><![CDATA[mybatis分为一级缓存、二级缓存]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis中的事务管理(五)]]></title>
    <url>%2F2019%2F06%2F04%2Fmybatis-transaction%2F</url>
    <content type="text"></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务--服务编排]]></title>
    <url>%2F2019%2F06%2F03%2Fservicemesh-serverless%2F</url>
    <content type="text"><![CDATA[服务编排 Dubbo/SpringCloudServiceMesh服务网格 Linkerd/Envoy Istio Serverless无服务器架构 Knative]]></content>
  </entry>
  <entry>
    <title><![CDATA[Maven依赖冲突问题]]></title>
    <url>%2F2019%2F06%2F03%2Fmaven-conflict%2F</url>
    <content type="text"><![CDATA[maven依赖冲突 冲突分类：第一类Jar包问题：依赖的同一个Jar出现不同的版本。第二类Jar包问题：同样的类Class出现在多个不同的Jar包中。 冲突原因：maven的依赖机制：优先按照依赖管理元素中指定的版本声明进行仲裁，此时下面的两个原则都无效了若无版本声明，则按照“短路径优先”的原则（Maven2.0）进行仲裁，即选择依赖树中路径最短的版本若路径长度一致，则按照“第一声明优先”的原则进行仲裁，即选择POM中最先声明的版本 冲突解决1、依赖管理针对第一类冲突方法1）通过排除传递依赖方法2）使用对依赖包统一版本管理 2、冲突检测插件针对第二类冲突maven-enforcer-plugin插件 + extra-enforcer-rules工具，注意：应用在子模块上，]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[断路器hystrix]]></title>
    <url>%2F2019%2F06%2F03%2Farchitecture-hystrix%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[talk-in-wangxiaobo]]></title>
    <url>%2F2019%2F05%2F31%2Ftalk-in-wangxiaobo%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于失去]]></title>
    <url>%2F2019%2F05%2F30%2Fthinking-in-lost%2F</url>
    <content type="text"><![CDATA[关于失去，说是老了也好，说是闲的也好，总之，这一刻，因为一些人，一些事儿。总想说点什么。 自从开始写代码这个行业，大多的时间忙于各种新技术的更新换代，怕自己被淘汰，就陷于无尽的焦虑当中。很少有时间享受读一本书，出去骑行的慢时光。即便这样，仍然面临被很多人拍死在沙滩上的处境。最近得闲，因为某种原因，李志的专辑被全平台下线，网上遍寻，有幸发现一个网站《麦田音乐网》，这是一个运营了十多年的网站，而且是个人运营，很是惊讶，竟然还有这种佛系的地方。大致浏览了一下，猜测站长应该是个很厉害、又有点文艺的人，我看大家称呼他鬼哥。网站中除了歌单，最精彩的地方是，还有个麦游记，然后就有很多人会写下自己的故事，感觉类似于那个很有创意的淘宝卖家《CY故事 • 一家卖故事的淘宝店》(有点忘了，可以去查了一下)，这些故事总能触动内心深处的某些东西。 网站有个很醒目的flag：”我没法像个农民那样善良，只是麦子还在对着太阳愤怒生长”，第一印象就是《麦田里的守望者》，然后一层一层的“扒光”，在留言本的地方，站长的： 欢迎来到“麦田音乐网”，如果您有什么想说的话，请在这里留言！麦田音乐网建于2006年，是一个简单纯粹的音乐、文字分享网站。在浮躁、喧嚣的互联网中，希望你能在这里静下来。网站取名于《麦田里的守望者》、《小王子》、海子的诗、梵高与麦田。站长QQ:40589302 微信:linfox微信公众号“麦音乐”：maiyinyue不换友情链接。 留言本下有些留言真的是别有意味，这种感觉恐怕就是旧友久别重逢而不曾遗忘的感觉吧。 猪诺 2019-01-29 11:42 上午初中时开始听，现在我研三即将毕业。一晃这么多年。QQ上还加着你，但是QQ已经不用了。走了好久，发现麦田还在，真好。 在留言本后还有个淘宝店铺，也是十多年的老店，打开店铺，果然做生意也是很佛系的，我比较喜欢的是里面的文化衫，”grunge is dead”，”we are young”。真是一个很有趣的人。 总之，这是一个很有内容的网站，作为一个技术人，接触了太多的网站，这算是网站中的一股清流了。意犹未尽之余，去查了一下”伍尔芙”，著名的一句话–你不能通过逃避生活以寻找安宁，有机会读一下《海浪》；“科特柯本”，摇滚乐、朋克，这些东西没有系统的了解过，瞬间感觉自己的孤陋寡闻，不禁反思“我究竟是个有趣的人吗？”，因为最近也在读王小波，颇多感慨，也许自己还是太晚熟了，失去了太多宝贵的时间；“麦田里的守望者”，这本书其实很早有了解，但是一直没读过，去豆瓣了解了一下，中间刘瑜老师在2009年的一条评论还是令人深思的，的确，生活有美好，也有颓废，但是不能只看到颓废。然后打开刘瑜老师的个人博客，域名早已变成一个机械公司的网站… 生活，究竟是什么？可能我们每个人都问过自己，也在不断的寻找答案，尤其是这个快速迭代的时代，很多的东西终会被新的事物掩盖，但是她的美好，或者对她的依恋，却仍然在散发着光辉。 就好像这个网站，有一天会不会突然不能用了？我不知道，但我会尽力维护下去，当成一种信仰。我想要看清这个世界！]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于今天某思面试的思考]]></title>
    <url>%2F2019%2F05%2F29%2Fthinking-in-20190529%2F</url>
    <content type="text"><![CDATA[今天下午参加了某思的面试，天挺热的，某思去了两次，第一次面到总监，莫名其妙的杳无音讯。这次是第二次。面试过程前HR提前说明了面试官喜欢问算法，也没怎么准备，只是为了白板，简单看了一下基础的算法。 面试中因为面试官看到我不是科班出身，就问了我两道题，一道关于系统中进程和线程，我答的不是很好，面试官说再考考你的基础，就出了一道算法题，大约五分钟后， 面试官问我有思路吗，其实这个并不难，我就把思路大致讲了一下，然后面试官就要结束，习惯性的说，你还有什么要问我的吗我说，我表现很差吗？接着，他说不问上层应用层的东西，比较注重基础 blablabla…我接着问，这道算法题是有什么模式吗？您是怎么做的？其实这个，blabla…讲了一堆我说，我这个用Map有问题吗？你这个主要是太占空间(这时候，我其实很无奈，就是一个优化的问题，但是我也没办法)然后，我说前辈有什么要指导的吗？你既然是非科班出身，就应该在一年内把计算机系统、编译原理、数据结构、网络这些都学习一下(此时，我知道面试官只是对我的出身比较有看法吧，所谓的这几道题无非是不显得那么明显) 面试出来，我知道这个行业门槛越来越高，而我们这些非科班出身的人，未来的路将越来越难走，我觉得自己在这个级别上，表现并没有那么差，但是依然会有人用自己的偏见去看待这一切。 虽然有点不甘，但是给自己加油吧！希望未来的自己越来越强大！ 拆分目标，把每年的计划拆分到每个月，每一周，然后不断的复盘，总结，看看自己能不能突破当前的桎梏 6月计划： 一、读完《CSAPP》，并整理出博客 二、读完《HTTP/IP详解卷1》，并整理出博客]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络中的网桥、交换机、集线器]]></title>
    <url>%2F2019%2F05%2F29%2Fnet-hub-bridge-switch%2F</url>
    <content type="text"></content>
      <tags>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go-iris-websocket]]></title>
    <url>%2F2019%2F05%2F27%2Fgo-iris-websocket%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Dart和Flutter的那些事儿]]></title>
    <url>%2F2019%2F05%2F27%2Fflutter-base%2F</url>
    <content type="text"><![CDATA[Flutter是一门]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对一些事情的思考]]></title>
    <url>%2F2019%2F05%2F04%2Fthinking-in-youthday%2F</url>
    <content type="text"><![CDATA[从2019-04-22开始第一次面试，到现在半个月的时间。个中经历不用言语，最大的感受就是发现自己越来越菜，需要学习的东西越来越多。 从五一开始也一直在整理收藏的技术博客，面试中很多东西说不明白，终究还是没有真正明白。每次面对面试官无法回答问题，都感觉好尴尬，默默地骂自己一句：“辣鸡”。 针对面试的弱点主要以下几点： 1、缺乏深入 很多知识点，只能说个大概，底层的概念很模糊。 将来要循序渐进的对弱点进行源码分析，分析源码可以更好的成长。 2、对新技术缺乏认识。 分布式、高并发、JVM调优，这些虽然很少接触，还是要抽时间模拟实践一下。 要能实现基本的Demo，才算对新技术的简单了解 3、坚持算法 算法和实际工作关系不大，但是刷算法能保证不断的思考，加深问题的分析能力 每天坚持算法 今年的目标就是把知识点串成面，写出精品，而不是每天制造垃圾。]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZooKeeper原子广播协议ZAB(二)]]></title>
    <url>%2F2019%2F04%2F12%2Fzk-zab%2F</url>
    <content type="text"><![CDATA[ZAB 源自一致性协议 Paxos协议Paxos(帕索克斯)：Chubby技术架构 ZAB协议ZAB(Zookeeper Atomic Broadcast)：ZooKeeper原子消息广播协议，因为paxos太过于复杂，zk基于paxos实现了ZAB协议 特性 保证各个服务器之间的数据一致性 leader节点无法工作后，ZAB协议自动从Follower节点中选举新的leader 写操作写请求分为leader、follower/observer两种接收 写leader写follower/observerfollower/observer接收到写请求都会转发到leader，再由leader做一些ACK机制处理 读操作leader/follower/observer都可以处理读请求，直接返回结果给客户端 数据一致性问题因为leader负责写操作，leader随时可能挂掉，接着进入选举过程，这个期间如何保证数据一致性 leader可能挂掉的场景： 数据到达Leader节点前 数据到达 Leader 节点，但未复制到 Follower 节点 数据到达 Leader 节点，成功复制到 Follower 所有节点，但还未向 Leader 响应接收 数据到达 Leader 节点，成功复制到 Follower 部分节点，但还未向 Leader 响应接收 数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在 Leader 处于已提交状态，但在 Follower 处于未提交状态 数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在所有节点都处于已提交状态，但还未响应 Client 网络分区导致的脑裂情况，出现双 Leader]]></content>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java特殊类Unsafe]]></title>
    <url>%2F2019%2F03%2F23%2Fjava-unsafe%2F</url>
    <content type="text"><![CDATA[Unsafe类，可以用来直接访问系统内存资源、自主管理内存资源 原理特性 虚拟机“集约化”（VM intrinsification）：如用于无锁Hash表中的CAS（比较和交换）。再比如compareAndSwapInt这个方法用JNI调用，包含了对CAS有特殊引导的本地代码。在这里你能读到更多关于CAS的信息：http://en.wikipedia.org/wiki/Compare-and-swap。 主机虚拟机（译注：主机虚拟机主要用来管理其他虚拟机。而虚拟平台我们看到只有guest VM）的sun.misc.Unsafe功能能够被用于未初始化的对象分配内存（用allocateInstance方法），然后将构造器调用解释为其他方法的调用。 你可以从本地内存地址中追踪到这些数据。使用java.lang.Unsafe类获取内存地址是可能的。而且可以通过unsafe方法直接操作这些变量！ 使用allocateMemory方法，内存可以被分配到堆外。例如当allocateDirect方法被调用时DirectByteBuffer构造器内部会使用allocateMemory。 arrayBaseOffset和arrayIndexScale方法可以被用于开发arraylets，一种用来将大数组分解为小对象、限制扫描的实时消耗或者在大对象上做更新和移动。 API 内存操作 例如：堆外内存操作DirectByteBuffer CAS操作 例如：atomic原子类；AQS类；ConcurrentHashMap类 Class类： 对象操作：对象成员属性操作；非常规的对象实例化方式 线程调度：挂起、唤醒 例如：LockSupport.park()/unpark() 系统信息获取：系统指针大小；内存页大小 例如：java.nio.Bits使用pageSize计算内存页 内存屏障：jdk1.8引入，用来避免重排序 例如：java.util.concurrent.locks.StampedLock改进版读写锁实现 数组操作： AtomicINtegerArray类使用arrayBaseOffset和arrayIndexScale来定位元素 使用Unsafe类通过Bootstrap ClassLoader加载，有诸多限制。使用有两种方法。 使用命令行实现调用Unsafe类使用Application ClassLoader加载，要想使用Unsafe类，需要使用Boostrap类加载器加载。 注意：(分隔符与classpath参数类似，unix使用:号,windows使用;号，这里以unix为例) 1java -Xbootclasspath/a:/usrhome/thirdlib.jar: -jar yourJarExe.jar]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构中的网关]]></title>
    <url>%2F2019%2F03%2F23%2Farchitecture-gateway%2F</url>
    <content type="text"><![CDATA[网关在微服务中的应用 特性： 认证、鉴权、缓存、服务编排、监控告警 权限分级、流量管控、超时熔断 场景： 组件对比Nginx原理：异步非阻塞 Zuul特性身份认证与安全：识别每个资源的验证要求，并拒绝那些与要求不符的请求。 审查与监控：与边缘位置追踪有意义的数据和统计结果，从而带来精确的生产视图。 动态路由：动态地将请求路由到不同的后端集群。 压力测试：逐渐增加指向集群的流量，以了解性能。 负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求。 静态响应处理：在边缘位置直接建立部分响应，从而避免其转发到内部集群。 多区域弹性：跨越 AWS Region 进行请求路由，旨在实现 ELB（Elastic Load Balancing，弹性负载均衡）使用的多样化，以及让系统的边缘更贴近系统的使用者。 zuul1 原理：阻塞+多线程的过滤器，线程激增 zuul2 异步非阻塞，事件+回调 高可用方案： zuul集群 + eureka serverNginx/HAproxy/F5 + zuul LinkerdEnvoyUndertowSpring Cloud Gateway]]></content>
      <tags>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于写作]]></title>
    <url>%2F2019%2F03%2F23%2Fthinking-in-writing%2F</url>
    <content type="text"><![CDATA[关于我，对于感兴趣的事情，会尽力克服拖延症，带着乐趣去做一些事情。但是往往有时候因为忙或者其他原因，一直拖延，直到欠下的债太多，才会强迫自己重新开始。 写作其实是一件很费力的事情，尤其是写技术博客，更是需要很多精力，关于写的一些东西，有时间会结合一些方法论补充一下。强化一下自己的写作意识:(待续…]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark基础]]></title>
    <url>%2F2019%2F03%2F16%2Fspark-scala-loader%2F</url>
    <content type="text"><![CDATA[依赖包provided assembly打包 RDD转化操作 – 惰性求值]]></content>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搬瓦工搭建Shadowsocks服务器完整教程]]></title>
    <url>%2F2019%2F03%2F07%2Fss-bwh%2F</url>
    <content type="text"><![CDATA[利用国外服务器搭建翻墙服务。 1、搜索搬瓦工，注册账号，购买服务器 先借用赛风搜索搬瓦工网站，由于国内对搬瓦工的封锁，无法确定一个固定的域名，比如我原来使用https://bwh8.net，后来突然就不能访问了，搜索后，发现bwh1.net可以访问 2、安装Shadowsocks server，配置服务器信息 3、下载Shadowsocks client，配置代理信息]]></content>
      <tags>
        <tag>SS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer]]></title>
    <url>%2F2019%2F02%2F13%2Fcomputer%2F</url>
    <content type="text"><![CDATA[大型机特点： RAS 小型机RISC、MIPS指令 x86架构服务器CISC指令 ARM架构服务器RISC指令 power、sparc、安腾、xeon]]></content>
      <tags>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet Web容器对比]]></title>
    <url>%2F2019%2F02%2F12%2Ftomcat-jetty-undertow%2F</url>
    <content type="text"><![CDATA[tomcatjettyundertow]]></content>
  </entry>
  <entry>
    <title><![CDATA[线上错误排查]]></title>
    <url>%2F2019%2F02%2F12%2Fjava-btrace-arthas%2F</url>
    <content type="text"><![CDATA[线上排查问题一般通过查看日志的方式，这篇博客目的在于整理一些线上排查的工具 Btracebtrace Arthasarthas tt命令watch命令greys-anatomygreys-anatomy]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务治理]]></title>
    <url>%2F2019%2F02%2F12%2Fspring-service-manage%2F</url>
    <content type="text"><![CDATA[简单了解服务治理 OCTO框架]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在2019上班的第二天]]></title>
    <url>%2F2019%2F02%2F12%2Fthinking-in-2019%2F</url>
    <content type="text"><![CDATA[从2019年元旦开始，就在筹划写一篇总结，一直拖到今天。 写博客其实是一件很费时的事情，也只有在冷静的时候，才会静下心来思考这件事情，这可能也是迟迟未写的原因之一吧。 2018回顾2018这一年，经历了很多的事情，主题是工作，也关乎风月。 经历工作上，3月1号出门面试，第一家面的x德，3月2号去面的x东。刚开始不太喜欢加班，就接了x德的offer，是一个全新的团队，也为后来埋了很多坑，具体的就不再吐槽了，主要说说自己的问题。这半年里，了解了一下区块链，没多久，国内外接连出台了很多对区块链比特币的整顿政策，一下子凉凉。在工作中开始使用SpringBoot、SpringCloud的一整套架构。半年后接受不了团队混乱的管理，打算出来。甚至怀疑所谓的技术理想。 4月初清明节上午加班，下午赶飞机飞到重庆。对重庆的好感来自于《从你的全世界路过》，就这样一个人在重庆呆了三天，这是一座很有特色的城市，但是景点过于商业化，未来有机会和另一个人一起过来。 5月初独自骑车子从沙河一直骑到十三陵，这是在北京的第一次骑行，而且是一个人，路上车轱辘散架、大卡车、回来的路上遇到下雨，晚上直到十一点多才回到家里，又累又困，可以说真的是一次记忆深刻的骑行了。 从x德出来后，困惑了一段时间，想起自己一直想去未去的西藏，果断买了票过去。去到一个完全陌生而又向往的地方，一开始充满了期待。布达拉宫、大昭寺、巴松错、羊湖、日喀则、珠峰，一切都是新的。在林芝的时间，去见了朋友。而在西藏的这段时间里，让我有了更多的独处时间去思考，想起这半年来的各种事情，突然就感到豁然开朗。就这样待到11月份，后来的几天有点审美疲劳了吧，就天天坐在布达拉宫广场晒太阳。有拍婚纱照的，有朝圣的。后来甚至有点期待返京的日子。这可能就是“旅行就是从自己厌倦的地方去到一个别人厌倦的地方吧”。如果说旅行的意义是什么，我想，就是让自己进入慢节奏的生活，去思考，把自己的生活捋顺吧。意外的是收获了一首好歌–《狗屁青春》，朴树唱的，在路上听的时候还别有一番滋味。 从西藏回来后，心态好了很多，一些事情想通后也没有必要再去在乎或者纠结。只把心思放在工作上，希望能有更多的产出， 阅读看过的电影：华尔街之子 大空头 互联网之子 驴得水 狗十三 人生果实 看过的书：《回来》 《人类简史》 《商业的本质》 《引爆点》 《黑客与画家》 《独居的一年》 《小王子》 《我们都是孤独的行路人》 《只是为了好玩儿》 2019展望 考驾照，一直拖到现在还未完成的计划今年必须完成 学习吉他，虽然五音不全，年少不再，还是要学习一门乐器 坚持健身(跑步)，这个年龄总该意识到这个问题 工作上有一些突破 买一辆更好的山地车去骑行 读30本书，那些一年读100本书的人真的很厉害了 人生需要不断的前行、试错、复盘。前面走了太多的弯路，未来要跑起来鸭！以后会尽量把经历记录下来，也不免是人生的一些回忆。]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务--注册中心(二)]]></title>
    <url>%2F2019%2F01%2F23%2Fspring-cloud-eureka%2F</url>
    <content type="text"><![CDATA[著名的CAP理论，Eureka满足AP理论，ZK、Consul满足CP理论 最早接触的是zk，当时没怎么分析，水货 Zookeeper原理特点Eureka原理特点 服务注册快，不需要将注册信息同步到其他节点 不同的节点注册信息可以不一致，保证了高可用A Consul原理特点为了满足强一致性C，导致以下缺点 服务注册慢，必须满足半数的节点写入成功才认为注册成功 Leader宕机，为了强一致性，整个集群不可用，牺牲了高可用 EtcdNacos]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务--断路器(三)]]></title>
    <url>%2F2019%2F01%2F17%2Fspring-cloud-hystrix%2F</url>
    <content type="text"><![CDATA[服务之间的依赖，导致一个环节出问题，如果遇到高并发，就会导致资源耗尽，从而影响其它服务的调用，所以引入了断路器的概念 Hystrix原理 分为线程隔离、信号量隔离，线程隔离相对信号量隔离比较消耗资源。默认采用HystrixCommand线程隔离， 微服务之间的调用包裹在HystrixCommand类中，这样每次都会启动一个新的线程执行 熔断：默认超过50%的请求失败，将打开断路器，不再调用后端服务而直接失败，过一段时间后尝试一部分请求到后端，如果成功则关闭断路器 超时时间：可以手动设置，当调用后端服务超过超时时间时，直接返回/执行fallback逻辑 请求结果：成功、失败(异常、超时、拒绝、短路) 配置属性：1234circuitBreaker: requestVolumeThreshold: 20 #滑动窗口大小 sleepWindowInMilliseconds: 5000 #过多久断路器再次检测是否开启 errorThresholdPercentage: 50 #错误率 应用场景： 隔离（线程隔离、信号量隔离）：主要是限制调用分布式服务的资源，避免个别服务出现问题时对其他服务产生影响 熔断（容错）：当失败率达到一定阈值时，熔断器触发快速失败 降级（超时降级、熔断降级）：触发降级时可以使用回调方法返回托底数据 缓存：请求缓存、请求合并 实时监控、报警 Sentinel原理特性： 轻量级、高性能： sentinel-core不到200KB，单机超过25W QPS才会有影响 流量控制：以不同的运行指标为基准， 直接拒绝模式慢启动预热模式匀速度模式 系统负载保护 应用场景： 和Dubbo整合，通过限流实现服务的高可用 和RocketMQ整合，通过匀速请求和冷启动保障服务的稳定性 Hystrix和Sentinel的对比]]></content>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot的启动类]]></title>
    <url>%2F2019%2F01%2F17%2Fspring-boot-runner%2F</url>
    <content type="text"><![CDATA[项目启动之前，可以有一些初始化动作：读取配置文件、数据库连接。SpringBoot提供了两个接口：’CommandLineRunner’和’ApplicationRunner’，通过‘@Order’注解定义启动顺序 CommandLineRunner12345678910111213@Component@Order(10)@Slf4jpublic class ApplicationStartup implements CommandLineRunner &#123; @Autowired private DataService dataService; @Override public void run(String... args) throws Exception &#123; return; &#125;&#125; ApplicationRunner该接口的run方法参数是一个ApplicationArguments类 12345678910111213141516@Component@Order(10)@Slf4jpublic class AppApplicationStartup implements ApplicationRunner &#123; @Autowired private AppPushService appPushService; @Override public void run(ApplicationArguments args) throws Exception &#123; /** * 定时推送消息 */ appPushService.pushSimplePayload(); &#125;&#125;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务--组件]]></title>
    <url>%2F2019%2F01%2F14%2Fspring-cloud-components%2F</url>
    <content type="text"><![CDATA[SpringCloud社区非常火热，组件的更新频率也比较高，这里对一些大版本的组件更新做一些记录 Spring Boot和Spring Cloud组件的命名： Feignspring-cloud-starter-feign(已废弃) spring-cloud-starter-openfeign Eurekaspring-cloud-starter-eureka(已废弃)spring-cloud-starter-eureka-server(已废弃) spring-cloud-starter-netflix-eureka-client spring-cloud-starter-netflix-eureka-server]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cat-architecture]]></title>
    <url>%2F2019%2F01%2F07%2Fcat-architecture%2F</url>
    <content type="text"><![CDATA[应用场景 一段代码的执行时间，一段代码可以是URL执行耗时，也可以是SQL的执行耗时。 一段代码的执行次数，比如Java抛出异常记录次数，或者一段逻辑的执行次数。 定期执行某段代码，比如定期上报一些核心指标：JVM内存、GC等指标。 关键的业务监控指标，比如监控订单数、交易额、支付成功率等。 埋点 HTTP/REST、RPC/SOA、MQ、Job、Cache、DAL; 搜索/查询引擎、业务应用、外包系统、遗留系统; 第三方网关/银行, 合作伙伴/供应商之间； 各类业务指标，如用户登录、订单数、支付状态、销售额。 模块cat-client cat-consumer cat-home 组件Transaction Event Heartbeat Metric]]></content>
  </entry>
  <entry>
    <title><![CDATA[html5-doctype]]></title>
    <url>%2F2019%2F01%2F07%2Fhtml5-doctype%2F</url>
    <content type="text"><![CDATA[HTML5基本声明： &lt;!DOCTYPE html&gt; 使用外部svg时， &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;]]></content>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat--概览(一)]]></title>
    <url>%2F2019%2F01%2F03%2Ftomcat-base%2F</url>
    <content type="text"><![CDATA[Tomcat作为常见的Servlet容器，我接触的从最初的SSH/SSM架构，Tomcat需要单独维护，到SpringBoot的嵌入式容器。 整体架构架构示意图： ServerServer包含一个或多个Service ServiceService是多个Connector和一个Container的集合，因为有不同的协议，需要用相应的Connector接收请求，转发给Container ConnectorConnector安装不同的协议分为： HTTP Connector AJP Connector ContainerEngine负责处理Service的请求，Connector作为中间媒介 Host表示一个虚拟主机，每个虚拟主机和一个网络域名对应 Context每个Context对应一个Web应用 Wrapper：代表一个Servlet，使用门面设计模式 Connector有两种：可以在server.xml中看到配置1) 监听8080端口2) 监听8009端口 Wrapper其它组件manager主要用来管理会话 loader启动Context，管理context的ClassLoader。 piplineEnging/Host/Context都有一个管道，在每个管道中设置了不同的valve，由valve做一些处理 valve用来做一些拦截处理， logger优化1、 3、并行类加载 常见问题独立容器1、日志乱码问题 SpringBoot1、URL路径转义问题]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot--启动流程(一)]]></title>
    <url>%2F2018%2F12%2F31%2Fspring-boot-starter%2F</url>
    <content type="text"><![CDATA[SpringBoot集成了Spring、Servlet容器 主流程 读取配置文件：spring.factories 启动监听器：SpringApplicationRunListeners 配置环境变量：ConfigurableEnvironment，判断是否是web环境。实质就是启动Servlet容器 创建上下文：ApplicationContext，核心方法主要’createContext’ ‘refreshContext’ ‘afterRefresh’。本质上是启动Spring IoC。]]></content>
  </entry>
  <entry>
    <title><![CDATA[java--范型]]></title>
    <url>%2F2018%2F12%2F26%2Fjava-pattern%2F</url>
    <content type="text"><![CDATA[范型是一种语法糖， 范型擦除范型只在编译阶段有效，在生成字节码后类型会被擦除。范型可以用在范型类、范型接口、范型方法 范型标识 E - Element (在集合中使用，因为集合中存放的是元素)，E是对各方法中的泛型类型进行限制，以保证同一个对象调用不同的方法时，操作的类型必定是相同的。E可以用其它任意字母代替 T - Type（Java 类），T代表在调用时的指定类型。会进行类型推断 K - Key（键） V - Value（值） N - Number（数值类型） ？ - 表示不确定的java类型，是类型通配符，代表所有类型。？不会进行类型推断 通配符，范型上下边界&lt;?&gt; &lt;? extends T&gt; &lt;? super T&gt; 范型数组注意： 不能创建一个确定类型的范型数组 例如：123List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10]; // 错误List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10]; // 正确List&lt;String&gt;[] ls = new ArrayList[10]; // 正确 静态方法和范型12public static &lt;T&gt; void test(T t) &#123;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeanUtils工具类]]></title>
    <url>%2F2018%2F12%2F25%2Fjava-beanutils%2F</url>
    <content type="text"><![CDATA[BeanUtils和PropertyUtils 1org.springframework.beans.BeanUtils.copyProperties(src, dest); 1org.apache.commons.beanutils.BeanUtils.copyProperties(src, dest); 1org.apache.commons.beanutils.BeanUtilsBean.getInstance().copyProperties(src, dest); 1org.apache.commons.beanutils.PropertyUtils.copyProperties(src, dest); BeanUtils和PropertyUtils的区别 beanutils支持name相同、类型兼容的属性转换；propertyutils仅支持name相同、类型相同的属性转换 beanutils对部分属性不支持null的转换；propertyutils支持null的转换 对于Long和Date类型的转换，BeanUtils转换正常；PropertyUtils报错 自定义的对象属性类型，都是浅拷贝 BeanUtils支持自定义Converter接口，PropertyUtils没有]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java序列化Serializable]]></title>
    <url>%2F2018%2F12%2F25%2Fjava-serializable%2F</url>
    <content type="text"><![CDATA[类要实例化必须实现Serializable接口，类的序列化/反序列化通过serialVersionUID唯一确认，当没有显式设置时，系统会默认生成一个，同一个类每次实例生成不同的serialVersionUID。 Serializable和Externalizable序列化类型是String、Array、Enum、Serializable时，则序列化，否则抛出不允许序列化的异常’NotSerializableException’。 123456public interface Externalizable extends java.io.Serializable &#123; void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;&#125; 使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写 writeExternal()与readExternal()方法。否则所有变量的值都会变成默认值。 transienttransient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后， transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 自定义序列化策略在序列化过程中，如果被序列化的类中定义了writeObject 和 readObject 方法，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化。 如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。 serialVersionUID注意 在做兼容性升级时，不要修改serialVersionUID的值。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis中sql的解析过程(四)]]></title>
    <url>%2F2018%2F12%2F25%2Fmybatis-sql%2F</url>
    <content type="text"></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作maven插件]]></title>
    <url>%2F2018%2F12%2F25%2Fmaven-plugin%2F</url>
    <content type="text"><![CDATA[开发Maven插件，原来做过，但是今天看，竟然没有留下记录，以后新东西必须强迫自己写博客！！！]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中paralelStream方法的坑]]></title>
    <url>%2F2018%2F12%2F24%2Fjava-parallelstream%2F</url>
    <content type="text"><![CDATA[今天在项目开发中使用parallelStream遍历ArrayList，发现数据有时候多有时候少，有时候出现’null’的对象，在本地甚至出现’Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException: 6246‘]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-contenttype]]></title>
    <url>%2F2018%2F12%2F24%2Fjs-contenttype%2F</url>
    <content type="text"><![CDATA[noneform-datax-www.form-urlencodedraw]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring--注解(三)]]></title>
    <url>%2F2018%2F12%2F21%2Fspring-annotation%2F</url>
    <content type="text"><![CDATA[Spring注解 注入注解@AutowiredbyType注入， @Resource默认byName注入，有两个属性：name、type，可以自由定义 注解 @Resource 的装配顺序： 如果同时指定了 name 和 type，则从 Spring 上下文中找到唯一匹配的 bean 进行装配，找不到则抛出异常； 如果指定了 name，则从上下文中查找名称（id）匹配的 bean 进行装配，找不到则抛出异常； 如果指定了 type，则从上下文中找到类型匹配的唯一 bean 进行装配，找不到或者找到多个，都会抛出异常； 如果既没有指定 name，又没有指定 type，则自动按照 byName 方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配成功，则进行自动装配。 @Inject约定@Service，用于标注业务层组件（通常定义的 Service 层就用这个注解）；@Controller，用于标注控制层组件（如 Struts 中的 action）；@Repository，用于标注数据访问组件，即 DAO 层组件；@Component，泛指组件，当组件不好归类的时候，咱们就可以用这个注解进行标注。 自定义注解]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-monitor]]></title>
    <url>%2F2018%2F12%2F21%2Fjava-monitor%2F</url>
    <content type="text"><![CDATA[Btracejpdagreys]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[session-cookie-token]]></title>
    <url>%2F2018%2F12%2F19%2Fsession-cookie-token%2F</url>
    <content type="text"><![CDATA[Session原理：存储在服务器上，服务器使用session把用户信息存储在服务器上(内存存放)，用户离开网站后，一般是30分钟后失效。 结构： 弊端：不适合分布式，如果有负载均衡，如果登录后，操作请求到另外的服务器，session不起作用 Cookiecookie是保存在浏览器本地的kv数据，由服务器生成，返给客户端(浏览器)， 结构： 名称 值 有效域 路径 失效时间 安全标志 Token原理： 结构： 用户唯一身份标识time 当前时间时间戳sign 签名，hash(token前几位+salt)，可以防止第三方拼接不变参数 session和cookiesession和token token是无状态的，存储在客户端；session有状态，状态存储在服务器端。REST是无状态的，app不需要像浏览器那样存储cookie token安全性比较好，可以防止监听、重防攻击；session保证安全需要靠链路层实现 token是唯一的，提供认证 + 鉴权；session是把用户信息存在服务器，只要有sessionid，即认为有全部权利。如果接口给第三方调用，使用token，否则两者都可]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql-date]]></title>
    <url>%2F2018%2F12%2F19%2Fmysql-date%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[mysql-int]]></title>
    <url>%2F2018%2F12%2F19%2Fmysql-int%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hystrix-sentinel-rs4j]]></title>
    <url>%2F2018%2F12%2F19%2Fhystrix-sentinel-rs4j%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js跨域问题]]></title>
    <url>%2F2018%2F12%2F16%2Fjs-cors%2F</url>
    <content type="text"><![CDATA[跨域其实很早就用，当时也没有整理。 CORS: CORS的目的不是为了解决CSRF，无法防止CSRF发生 CSRF: (Cross-site request forgery，跨站请求伪造)，CSRF攻击的发起方式有很多种，src资源标签、form表单、js代码 跨域:阮老师的博客 同源策略同源： 协议相同 域名相同 端口相同 受限制的策略： Ajax请求 无法获取DOM元素并操作 无法读取Cookie、LocalStorage、IndexDB 不受限制的策略： WebSocket、Script、img、iframe、video、audio的src属性 跨域场景调用API接口 前后端分离 解决方案 代理模式。分为正向代理、反向代理，自己伪造一个后端服务(例如Nodejs)接收并转发 CORS标准。服务端设置’Access-Control-Allow-Origin’ + ‘Access-Control-Allow-Credentials’，客户端设置withCredentials 注意：CORS默认不发送Cookie和HTTP认证信息，Credentials用来指定发送Cookie信息。如果要发送Cookie，’Access-Control-Allow-Origin’不能设置为’*’，而必须指定明确的、与请求网页一致的域名。 JSONP方式。通过script标签发起请求，服务端把数据放在js脚本里返回给客户端，但是只支持GET请求。CDN就是典型的应用。jQuery封装的JSONP]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis缓存过期策略(四)]]></title>
    <url>%2F2018%2F12%2F16%2Fredis-cache-policy%2F</url>
    <content type="text"><![CDATA[简单记录，回头需要深入再做整理 策略方式： 定期过期：每隔一段固定时间，去扫描一定数量的数据库中expires字典表的key，到过期时间自动清除；占用CPU资源 惰性过期：当访问key时，才判断是否过期，过期则清除；如果大量key没有被访问，则不会被清除 Redis中同时使用了惰性过期和定期过期策略]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis内存淘汰策略(三)]]></title>
    <url>%2F2018%2F12%2F16%2Fredis-mem-policy%2F</url>
    <content type="text"><![CDATA[Redis用于缓存的内存不足时，如何处理新写入需要申请额外空间的数据。 32bit系统最大不能超过3G，64bit系统设置为0表示不限制 设置淘汰策略： config get maxmemory config get maxmemory-policy 6种淘汰策略 volatile-lru:从已设置过期时间的内存数据集中挑选最近最少使用的数据 淘汰； volatile-ttl: 从已设置过期时间的内存数据集中挑选即将过期的数据 淘汰； volatile-random:从已设置过期时间的内存数据集中任意挑选数据 淘汰； allkeys-lru:从内存数据集中挑选最近最少使用的数据 淘汰； allkeys-random:从数据集中任意挑选数据 淘汰； no-enviction(驱逐)：禁止驱逐数据。（默认淘汰策略。当redis内存数据达到maxmemory，在该策略下，直接返回OOM错误）；]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础]]></title>
    <url>%2F2018%2F12%2F15%2Fmysql-base%2F</url>
    <content type="text"><![CDATA[MySQL有三种版本， MySQLPerconaXtraDB引擎 MariaDB]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb开发中的字段验证]]></title>
    <url>%2F2018%2F12%2F15%2Fjava-web-validate%2F</url>
    <content type="text"><![CDATA[Web开发中传参需要验证，JSR303定义了校验模型，不同的实现方式： javax validation hibernate validation spring validation 自定义校验 JSR303空检查 @Null 验证对象是否为null @NotNull 验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查 @AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查 @Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) Validates that the annotated string is between min and max included. 日期检查 @Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern 验证 String 对象是否符合正则表达式的规则 数值检查，建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为&quot;&quot;,Integer为null @Min 验证 Number 和 String 对象是否大等于指定的值 @Max 验证 Number 和 String 对象是否小等于指定的值 @DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度 @DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度 @Digits 验证 Number 和 String 的构成是否合法 @Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。 @Range(min=, max=) Checks whether the annotated value lies between (inclusive) the specified minimum and maximum. @Range(min=10000,max=50000,message=&quot;range.bean.wage&quot;) private BigDecimal wage; @Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证) @CreditCardNumber信用卡验证 @Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。 @ScriptAssert(lang= ,script=, alias=) @URL(protocol=,host=, port=,regexp=, flags=) javax validation@Valid 分组校验 @NotEmpty(groups={Person.class} hibernate validationHibernate validation有两种验证模式： 普通模式 快速失败模式 ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class ).configure().failFast( true ).buildValidatorFactory(); Validator validator = validatorFactory.getValidator(); spring validation注意：注解需要和BindingResult相邻，校验结果放在BindingResult对象中，例如： (@Validated Foo foo, BindingResult fooBindingResult ，@Validated Bar bar, BindingResult barBindingResult) 注解类型@Validated @Valid和@Validated的区别： @Valid不提供分组类型 @Validated({Person.class}) 应用场景可以进行：数据库校验、组合校验(前后密码一致) @NotNull、@NotEmpty和@NotBlank的区别注意： 可以在controller内参数上直接加注解，但是必须在controller上@Validated 对象级联校验(即对象内部嵌套对象)时，嵌套对象上必须加注解@Valid 验证有时候可能被filter、swagger拦截，需要注意]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域请求]]></title>
    <url>%2F2018%2F12%2F13%2Fhttp-cors%2F</url>
    <content type="text"><![CDATA[Spring跨域文档 跨域原理前端方案后端方案1. 局部跨域 添加在Cotroller上 添加在Method上 同时添加在Controller + Method上 注意： 如果使用到Spring Security框架，确保在Spring Security层次上配置，同时允许使用Spring MVC层面的配置 @EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.cors().and()... } } 2. 全局跨域1. 基于JavaConfig方式使用全局方式 @Configuration @EnableWebMvc public class WebConfig extends WebMvcConfigurerAdapter { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;); } } 如果使用Spring Boot，推荐： @Configuration public class MyConfiguration { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurerAdapter() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;); } }; } } CORS跨域的规则可以自由定制： @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/api/**&quot;) .allowedOrigins(&quot;http://domain2.com&quot;) .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;) .allowedHeaders(&quot;header1&quot;, &quot;header2&quot;, &quot;header3&quot;) .exposedHeaders(&quot;header1&quot;, &quot;header2&quot;) .allowCredentials(false).maxAge(3600); } 注意：如果使用Spring Security，配置方式和局部跨域中相同 基于XML方式 1234567891011&lt;mvc:cors&gt; &lt;mvc:mapping path="/api/**" allowed-origins="http://domain1.com, http://domain2.com" allowed-methods="GET, PUT" allowed-headers="header1, header2, header3" exposed-headers="header1, header2" allow-credentials="false" max-age="123" /&gt; &lt;mvc:mapping path="/resources/**" allowed-origins="http://domain1.com" /&gt; &lt;/mvc:cors&gt; 注意：使用Spring Security &lt;http&gt; &lt;!-- Default to Spring MVC&apos;s CORS configuration --&gt; &lt;cors /&gt; ... &lt;/http&gt; 基于Filter方式 1234567891011121314151617@Configurationpublic class MyConfiguration &#123; @Bean public FilterRegistrationBean corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedOrigin("http://domain1.com"); config.addAllowedHeader("*"); config.addAllowedMethod("*"); source.registerCorsConfiguration("/**", config); FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source)); bean.setOrder(0); return bean; &#125;&#125; 参考1 参考2 注意：使用Spring Security @EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http // by default uses a Bean by the name of corsConfigurationSource .cors().and() ... } @Bean CorsConfigurationSource corsConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOrigins(Arrays.asList(&quot;https://example.com&quot;)); configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;,&quot;POST&quot;)); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, configuration); return source; } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Web中身份验证和授权]]></title>
    <url>%2F2018%2F12%2F06%2Fjava-web-auth%2F</url>
    <content type="text"><![CDATA[OpenAPI2.0OpenAPI3.01234567891011121314151617181920212223242526272829components: securitySchemes: BasicAuth: type: http scheme: basic BearerAuth: type: http scheme: bearer ApiKeyAuth: type: apikey in: header name: X-API-Key OAuth2: type: oauth2 flows: authorizationCode: authorizationUrl: https:// tokenUrl: https:// scopes: read: Grants read access write: Grants write access admin: Grants access to admin operations OpenID: type: openIdConnect openIdConnectUrl: http://xxx HTTP认证方案标头中的API密钥用于API密钥和cookie认证， OAuth2.0 授权码模式 简化模式 密码模式 客户端模式 OpenID Connect实现ShiroJWT基本思路： 用户首次访问提供用户名 + 密码到认证服务器 服务器验证用户提交信息的合法性，如果验证成功，生成一个token到客户端 客户端每次访问携带token token包含信息： header： typ声明类型 alg生成签名的算法 { &quot;alg&quot; :&quot;AES256&quot;, &quot;typ&quot; :&quot;JWT&quot;} claims sub name admin { &quot;sub&quot;:&quot;1234567890&quot;, &quot;name&quot;:&quot;John Doe&quot;, &quot;admin&quot;:true} signature JWT和OAuth2.0、ShiroShiro:]]></content>
      <tags>
        <tag>Auth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka和Zookeeper的对比]]></title>
    <url>%2F2018%2F12%2F04%2Fdistribute-eureka-zk%2F</url>
    <content type="text"><![CDATA[服务注册中心的组件主要有：Eureka、Zookeeper、Consule、Etcd。都是围绕CAP理论，P是必须保证的，而C和A不能同时满足。zk保证的是CP，Eureka保证的是AP。它们的原理都是维护一张注册列表，客户端在服务列表中查询服务端信息，进行通信 ZookeeperEurekazk保证CP的原理zk集群需要维护一个leader，当master选举过程中，整个集群不可用，无法注册服务，无法保证A可用性 Eureka保证AP的原理Eureka集群没有leader的概念，所有节点都是平等的，当某一个节点不可用时，会自动切换到其它可用的节点上。这样无法保证C一致性 Eureka还有一种自我保护机制，当在15min之内超过85%的节点没有正常的心跳，eureka会认为出现网络故障： 长时间没有心跳时，eureka不会从注册列表移除服务 eureka节点仍然能接受新服务的注册、查询，不会被同步到其它节点 网络恢复时，同步注册信息到其它节点 当所有Eureka节点/ZK节点挂掉后，RPC是否可以进行正常通信？]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm垃圾收集器CMS和G1比较(四)]]></title>
    <url>%2F2018%2F12%2F04%2Fjava-jvm-cms-g1%2F</url>
    <content type="text"><![CDATA[结合GC日志对CMS、G1分析 CMS参数： 参数 详解 -XX:+UseConcMarkSweepGC 激活CMS收集器 -XX:ConcGCThreads 设置CMS线程的数量 -XX:+UseCMSInitiatingOccupancyOnly 只根据老年代使用比例来决定是否进行CMS -XX:CMSInitiatingOccupancyFraction 设置触发CMS老年代回收的内存使用率占比 -XX:+CMSParallelRemarkEnabled 并行运行最终标记阶段，加快最终标记的速度 -XX:+UseCMSCompactAtFullCollection 每次触发CMS Full GC的时候都整理一次碎片 -XX:CMSFullGCsBeforeCompaction 经过几次CMS Full GC的时候整理一次碎片 -XX:+CMSClassUnloadingEnabled 让CMS可以收集永久带，默认不会收集 -XX:+CMSScavengeBeforeRemark 最终标记之前强制进行一个Minor GC -XX:+ExplicitGCInvokesConcurrent 当调用System.gc()的时候，执行并行gc，只有在CMS或者G1下该参数才 日志：G1参数： 参数 详解 -XX:+UseG1GC 使用 G1 垃圾收集器 -XX:MaxGCPauseMillis=200 设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到） -XX:InitiatingHeapOccupancyPercent=45 启动并发GC周期时的堆内存占用百分比. G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比. 值为 0 则表示”一直执行GC循环”. 默认值为 45 -XX:NewRatio=n 新生代与老生代(new/old generation)的大小比例(Ratio). 默认值为 2 -XX:SurvivorRatio=n eden/survivor 空间大小的比例(Ratio). 默认值为 8. -XX:MaxTenuringThreshold=n 提升年老代的最大临界值(tenuring threshold). 默认值15 -XX:ParallelGCThreads=n 设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平台不同而不同. -XX:ConcGCThreads=n 并发垃圾收集器使用的线程数量. 默认值随JVM运行的平台不同而不同. -XX:G1ReservePercent=n 设置堆内存保留为假天花板的总量,以降低提升失败的可能性. 默认值是 10. -XX:G1HeapRegionSize=n 使用G1时Java堆会被分为大小统一的的区(region)。此参数可以指定每个heap区的大小. 默认值将根据 heap size 算出最优解. 最小值为 1Mb, 最大值为 32Mb. 日志：]]></content>
      <tags>
        <tag>java, jvm</tag>
      </tags>
  </entry>
</search>
