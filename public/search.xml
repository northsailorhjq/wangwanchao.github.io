<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ZooKeeper基于TCP的FastLeader(三)</title>
      <link href="/2019/06/06/zk-fastleader3/"/>
      <url>/2019/06/06/zk-fastleader3/</url>
      
        <content type="html"><![CDATA[<p>TCP选举算法</p><a id="more"></a><h2 id="核心结构"><a href="#核心结构" class="headerlink" title="核心结构"></a>核心结构</h2><h3 id="myid"><a href="#myid" class="headerlink" title="myid"></a>myid</h3><p>对应服务器在集群中的唯一ID</p><h3 id="zxid"><a href="#zxid" class="headerlink" title="zxid"></a>zxid</h3><p>类似于事务ID，顺序递增</p><p>|  高32位  |  低32位  |<br>epoch_h：用于标记leader的epoch，从1开始，每次选举出新的leader<br>，epoch_h加1，</p><p>epoch_l：用于标记epoch_h内的版本，epoch_h改变后，epoch_l会被重置</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>服务器状态：<br>looking：<br>leading：<br>following：<br>observing:</p><h3 id="选票数据结构"><a href="#选票数据结构" class="headerlink" title="选票数据结构"></a>选票数据结构</h3><p>选举领导时会进行投票，投票的数据结构：</p><p>logicClock: 表示该服务器发起的是第几轮投票，每个服务器都维护一个自增的logicClock<br>state: 当前服务器状态<br>self_id: 当前服务器的myid<br>self_zxid: zxid<br>vote_id: 被推选的的服务器的myid<br>vote_zxid: 被推选的服务器zxid</p><h2 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h2><p>选举过程很重要，也很复杂，做了一个流程图，不合理的回头补充：</p><image src="https://impwang.oss-cn-beijing.aliyuncs.com/zookeeper/FastLeaderElection%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86.png"><p>投票过程数据结构: (logicClock, myid, zxid)<br>投票箱存储结构：(投票服务器id, 被推选服务器id)</p></image>]]></content>
      
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper选举算法基础(三)</title>
      <link href="/2019/06/06/zk-select-base/"/>
      <url>/2019/06/06/zk-select-base/</url>
      
        <content type="html"><![CDATA[<p>选举算法有多种</p><a id="more"></a><h2 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h2><p>electionAlg配置：</p><ol><li>0：基于UDP的LeaderElection</li><li>1：基于UDP的FastLeaderElection</li><li>2：基于UDP和认证的FastLeaderElection</li><li>3：基于TCP的FastLeaderElection(新版本默认算法)</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zk-crash-select</title>
      <link href="/2019/06/06/zk-crash-select/"/>
      <url>/2019/06/06/zk-crash-select/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>zk-lock</title>
      <link href="/2019/06/06/zk-lock/"/>
      <url>/2019/06/06/zk-lock/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>netty-transport</title>
      <link href="/2019/06/05/netty-transport/"/>
      <url>/2019/06/05/netty-transport/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>netty-codec</title>
      <link href="/2019/06/05/netty-codec/"/>
      <url>/2019/06/05/netty-codec/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty概览(一)</title>
      <link href="/2019/06/05/netty-base/"/>
      <url>/2019/06/05/netty-base/</url>
      
        <content type="html"><![CDATA[<p>基于Netty4.1分支，可以看到代码已经非常复杂</p><a id="more"></a><p>netty结构图<br>基础部分：</p><image width="200" height="300" src="https://impwang.oss-cn-beijing.aliyuncs.com/netty/netty-base1.png"><p>test组件：</p><image width="250" height="100" src="https://impwang.oss-cn-beijing.aliyuncs.com/netty/netty-base2.png"><p>transport组件：</p><image width="250" height="100" src="https://impwang.oss-cn-beijing.aliyuncs.com/netty/netty-base3.png"><h2 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h2><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p>示意图：</p><p>Reactor模型主要有2部分：</p><blockquote><p>Reactor：单独的线程，负责监听、分发事件，<br>Handlers：</p></blockquote><h4 id="1-单Reactor、单线程"><a href="#1-单Reactor、单线程" class="headerlink" title="1. 单Reactor、单线程"></a>1. 单Reactor、单线程</h4><h4 id="2-单Reactor、多线程"><a href="#2-单Reactor、多线程" class="headerlink" title="2. 单Reactor、多线程"></a>2. 单Reactor、多线程</h4><h4 id="3-主从Reactor、多线程"><a href="#3-主从Reactor、多线程" class="headerlink" title="3. 主从Reactor、多线程"></a>3. 主从Reactor、多线程</h4><p>模型：</p><blockquote><p>MainReactor：负责连接请求，把请求转交给SubReactor<br>SubReactor：负责相应Channel的I/O读写请求<br>非I/O请求则直接写入队列，等待worker threads(工作线程)处理</p></blockquote><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>传输服务，支持 BIO 和 NIO。<br>容器集成，支持 OSGI、JBossMC、Spring、Guice 容器。<br>协议支持，HTTP、Protobuf、二进制、文本、WebSocket、RTSP等，还支持通过实行编码解码逻辑来实现自定义协议。<br>Core 核心，可扩展事件模型、通用通信 API、支持零拷贝的 ByteBuf 缓冲对象。</p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>Netty基于主从Reactor、多线程模型。</p><blockquote><p>bossGroup：线程池，在绑定某个端口后，从线程池获取一个线程处理Accept事件(相当于MainReactor)，这样每个端口对应一个Boss线程<br>workerGroup：线程池，SubReactor和Worker线程会共用该线程池</p></blockquote><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>Bootstrap/ServerBootstrap<br>Future/ChannelFuture<br>Channel/ChannelHandler/ChannelPipline<br>Selector<br>NioEventLoop/NioEventLoopGroup</p><p>总结：从结构上看，核心功能主要有2个：</p><ol><li>I/O模型</li><li>解析协议(编码/解码)</li></ol></image></image></image>]]></content>
      
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis概览(一)</title>
      <link href="/2019/06/04/mybatis-base/"/>
      <url>/2019/06/04/mybatis-base/</url>
      
        <content type="html"><![CDATA[<p>终究还是要自己来分析源码了，网上有很多MyBatis的源码分析，自己决定做，一来是加深印象；二来摸索源码分析的方法论。很多时候看源码一脸懵逼，不知道该从哪里看，看完没有形成思路。</p><a id="more"></a><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>mybatis结构图：</p><p><img width="200" height="300" src="https://impwang.oss-cn-beijing.aliyuncs.com/mybatis/mybatis-arc.png"></p><p>在我看来mybatis核心功能主要有3个：<br>1、xml/注解的解析(包括config配置、mapper)<br>2、一级缓存，二级缓存<br>3、事务</p><h2 id="MyBatis和Spring整合"><a href="#MyBatis和Spring整合" class="headerlink" title="MyBatis和Spring整合"></a>MyBatis和Spring整合</h2><p>mybatis和Spring整合插件结构图：</p><p><img width="200" height="300" src="https://impwang.oss-cn-beijing.aliyuncs.com/mybatis/mybatis-spring.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis缓存(三)</title>
      <link href="/2019/06/04/mybatis-cache/"/>
      <url>/2019/06/04/mybatis-cache/</url>
      
        <content type="html"><![CDATA[<p>mybatis分为一级缓存、二级缓存</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis中的事务管理(五)</title>
      <link href="/2019/06/04/mybatis-transaction/"/>
      <url>/2019/06/04/mybatis-transaction/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务--服务编排</title>
      <link href="/2019/06/03/servicemesh-serverless/"/>
      <url>/2019/06/03/servicemesh-serverless/</url>
      
        <content type="html"><![CDATA[<p>服务编排</p><a id="more"></a><h2 id="Dubbo-SpringCloud"><a href="#Dubbo-SpringCloud" class="headerlink" title="Dubbo/SpringCloud"></a>Dubbo/SpringCloud</h2><h2 id="ServiceMesh"><a href="#ServiceMesh" class="headerlink" title="ServiceMesh"></a>ServiceMesh</h2><p>服务网格</p><p>Linkerd/Envoy</p><p>Istio</p><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><p>无服务器架构</p><p>Knative</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven依赖冲突问题</title>
      <link href="/2019/06/03/maven-conflict/"/>
      <url>/2019/06/03/maven-conflict/</url>
      
        <content type="html"><![CDATA[<p>maven依赖冲突</p><a id="more"></a><h3 id="冲突分类："><a href="#冲突分类：" class="headerlink" title="冲突分类："></a>冲突分类：</h3><p>第一类Jar包问题：依赖的同一个Jar出现不同的版本。<br>第二类Jar包问题：同样的类Class出现在多个不同的Jar包中。</p><h3 id="冲突原因："><a href="#冲突原因：" class="headerlink" title="冲突原因："></a>冲突原因：</h3><p>maven的依赖机制：<br>优先按照依赖管理<dependencymanagement>元素中指定的版本声明进行仲裁，此时下面的两个原则都无效了<br>若无版本声明，则按照“短路径优先”的原则（Maven2.0）进行仲裁，即选择依赖树中路径最短的版本<br>若路径长度一致，则按照“第一声明优先”的原则进行仲裁，即选择POM中最先声明的版本</dependencymanagement></p><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><h4 id="1、依赖管理"><a href="#1、依赖管理" class="headerlink" title="1、依赖管理"></a>1、依赖管理</h4><p>针对第一类冲突<br>方法1）通过<excludes>排除传递依赖<br>方法2）使用<dependencymanagement>对依赖包统一版本管理</dependencymanagement></excludes></p><h3 id="2、冲突检测插件"><a href="#2、冲突检测插件" class="headerlink" title="2、冲突检测插件"></a>2、冲突检测插件</h3><p>针对第二类冲突<br>maven-enforcer-plugin插件 + extra-enforcer-rules工具，注意：应用在子模块上，</p>]]></content>
      
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>断路器hystrix</title>
      <link href="/2019/06/03/architecture-hystrix/"/>
      <url>/2019/06/03/architecture-hystrix/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统--异常控制流</title>
      <link href="/2019/06/01/csapp-exception/"/>
      <url>/2019/06/01/csapp-exception/</url>
      
        <content type="html"><![CDATA[<p>异常</p><a id="more"></a><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>异常控制流：现代系统通过使控制流发生突变来对这些情况做出反应，这些突变称为异常控制流。</p><p>异常：控制流中的突变。一部分由硬件实现，一部分由操作系统实现。</p><p>异常号：系统中可能的每种类型的异常都分配了一个唯一的非负整数，称为异常号。</p><blockquote><p>其中一些异常号由CPU设计中分配。例如：被零除、缺页、内存访问违例、断点、算术运算溢出<br>其它号码由操作系统内核的设计者分配。例如：系统调用、来自外部I/O设备的信号</p></blockquote><p>异常表：系统启动时，分配和初始化一张跳转表，称为异常表。表中维护了异常号-异常处理程序地址的关系。异常表的起始地址放在一个‘异常表基址寄存器’的特殊CPU寄存器内。</p><h3 id="异常种类"><a href="#异常种类" class="headerlink" title="异常种类"></a>异常种类</h3><table><thead><tr><th>类别</th><th style="text-align:center">原因</th><th style="text-align:center">异步/同步</th><th style="text-align:center">返回行为</th></tr></thead><tbody><tr><td>中断</td><td style="text-align:center">来自I/O设备的信号</td><td style="text-align:center">异步</td><td style="text-align:center">总是返回到下一条指令</td></tr><tr><td>陷阱</td><td style="text-align:center">有意的异常。</td><td style="text-align:center">同步</td><td style="text-align:center">总是返回到下一条指令</td></tr><tr><td>故障</td><td style="text-align:center">潜在的可恢复的错误</td><td style="text-align:center">同步</td><td style="text-align:center">可能返回到当前指令</td></tr><tr><td>终止</td><td style="text-align:center">不可恢复的错误</td><td style="text-align:center">同步</td><td style="text-align:center">不会返回</td></tr></tbody></table><h4 id="故障指令"><a href="#故障指令" class="headerlink" title="故障指令"></a>故障指令</h4><p>陷阱(系统调用)：普通程序运行在<code>用户模式</code>，系统调用运行在<code></code>内核模式<code>，系统为用户提供了特殊的</code>syscall n`指令，用户进行系统调用时进入陷阱模式。</p><p>故障：故障是由错误引起的，如果错误可以被修复，则将控制返回到引起故障的指令；如果不可修复，则返回到内核中的abort例程，abort例程会终止引起故障的应用程序。</p><p>终止：由不可恢复的致命错误引起，通常是一些硬件错误。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>并发流：并发流的思想与流运行的CPU核数、计算机数无关。</p><p>并行流：</p><h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><p>进程间内存空间私有</p><h3 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h3><p>模式位：CPU通过设置某个寄存器的模式位，指定进程处于内核模式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统--CPU</title>
      <link href="/2019/06/01/csapp-cpu/"/>
      <url>/2019/06/01/csapp-cpu/</url>
      
        <content type="html"><![CDATA[<p>决定计算机性能的3个关键因素：</p><blockquote><p>指令数目 (编译器和指令集决定)<br>时钟周期长度 (CPU决定)<br>每条指令所需要的时钟周期数 (CPU决定)</p></blockquote><a id="more"></a><h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><h3 id="1-组合单元："><a href="#1-组合单元：" class="headerlink" title="1. 组合单元："></a>1. 组合单元：</h3><h3 id="2-状态单元："><a href="#2-状态单元：" class="headerlink" title="2. 状态单元："></a>2. 状态单元：</h3><p>两个输入 + 一个输出<br>    输入：<br>    写入单元的数据值<br>    决定何时写入的时钟信号</p><p>时钟方法：规定信号可以独处和写入的时间<br>    边沿触发的时钟</p><p>寄存器堆：寄存器集合，存放32个通用寄存器<br>    R型指令：<code>add $t1, $t2, $t3</code></p><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>指令执行顺序：<br>取指<br>译码<br>执行<br>访存<br>写回<br>更新PC</p><h3 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h3><ol><li><p>结构冒险</p></li><li><p>数据冒险</p></li><li><p>控制冒险(分支冒险)：</p><p> 解决方法：</p><blockquote><p>阻塞<br>预测<br>延迟决定</p></blockquote></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>talk-in-wangxiaobo</title>
      <link href="/2019/05/31/talk-in-wangxiaobo/"/>
      <url>/2019/05/31/talk-in-wangxiaobo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csapp-lab</title>
      <link href="/2019/05/31/csapp-lab/"/>
      <url>/2019/05/31/csapp-lab/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统--指令集</title>
      <link href="/2019/05/31/csapp-instructions/"/>
      <url>/2019/05/31/csapp-instructions/</url>
      
        <content type="html"><![CDATA[<p>MIPS的2种实现方式：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于失去</title>
      <link href="/2019/05/30/thinking-in-lost/"/>
      <url>/2019/05/30/thinking-in-lost/</url>
      
        <content type="html"><![CDATA[<p>关于失去，说是老了也好，说是闲的也好，总之，这一刻，因为一些人，一些事儿。总想说点什么。</p><a id="more"></a><p>自从开始写代码这个行业，大多的时间忙于各种新技术的更新换代，怕自己被淘汰，就陷于无尽的焦虑当中。很少有时间享受读一本书，出去骑行的慢时光。即便这样，仍然面临被很多人拍死在沙滩上的处境。<br>最近得闲，因为某种原因，李志的专辑被全平台下线，网上遍寻，有幸发现一个网站《麦田音乐网》，这是一个运营了十多年的网站，而且是个人运营，很是惊讶，竟然还有这种佛系的地方。<br>大致浏览了一下，猜测站长应该是个很厉害、又有点文艺的人，我看大家称呼他鬼哥。网站中除了歌单，最精彩的地方是，还有个麦游记，然后就有很多人会写下自己的故事，感觉类似于那个很有创意的淘宝卖家《CY故事 • 一家卖故事的淘宝店》(有点忘了，可以去查了一下)，这些故事总能触动内心深处的某些东西。</p><p>网站有个很醒目的flag：”我没法像个农民那样善良，只是麦子还在对着太阳愤怒生长”，第一印象就是《麦田里的守望者》，然后一层一层的“扒光”，在留言本的地方，站长的：</p><blockquote><p>欢迎来到“麦田音乐网”，如果您有什么想说的话，请在这里留言！<br>麦田音乐网建于2006年，是一个简单纯粹的音乐、文字分享网站。<br>在浮躁、喧嚣的互联网中，希望你能在这里静下来。<br>网站取名于《麦田里的守望者》、《小王子》、海子的诗、梵高与麦田。<br>站长QQ:40589302 微信:linfox<br>微信公众号“麦音乐”：maiyinyue<br>不换友情链接。</p></blockquote><p>留言本下有些留言真的是别有意味，这种感觉恐怕就是旧友久别重逢而不曾遗忘的感觉吧。</p><blockquote><p>猪诺 2019-01-29    11:42 上午<br>初中时开始听，现在我研三即将毕业。一晃这么多年。<br>QQ上还加着你，但是QQ已经不用了。<br>走了好久，发现麦田还在，真好。</p></blockquote><p>在留言本后还有个淘宝店铺，也是十多年的老店，打开店铺，果然做生意也是很佛系的，我比较喜欢的是里面的文化衫，”grunge is dead”，”we are young”。真是一个很有趣的人。</p><p>总之，这是一个很有内容的网站，作为一个技术人，接触了太多的网站，这算是网站中的一股清流了。<br>意犹未尽之余，去查了一下”伍尔芙”，著名的一句话–你不能通过逃避生活以寻找安宁，有机会读一下《海浪》；<br>“科特柯本”，摇滚乐、朋克，这些东西没有系统的了解过，瞬间感觉自己的孤陋寡闻，不禁反思“我究竟是个有趣的人吗？”，因为最近也在读王小波，颇多感慨，也许自己还是太晚熟了，失去了太多宝贵的时间；<br>“麦田里的守望者”，这本书其实很早有了解，但是一直没读过，去豆瓣了解了一下，中间刘瑜老师在2009年的一条评论还是令人深思的，的确，生活有美好，也有颓废，但是不能只看到颓废。然后打开刘瑜老师的个人博客，域名早已变成一个机械公司的网站…</p><p>生活，究竟是什么？可能我们每个人都问过自己，也在不断的寻找答案，尤其是这个快速迭代的时代，很多的东西终会被新的事物掩盖，但是她的美好，或者对她的依恋，却仍然在散发着光辉。</p><p>就好像这个网站，有一天会不会突然不能用了？我不知道，但我会尽力维护下去，当成一种信仰。我想要看清这个世界！</p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统--并发和并行</title>
      <link href="/2019/05/29/csapp-concurrent/"/>
      <url>/2019/05/29/csapp-concurrent/</url>
      
        <content type="html"><![CDATA[<p>看了一遍，感觉并没有解释的很深刻，也许是自己理解的问题。</p><a id="more"></a><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>现代操作系统构建并发程序的方式：</p><ol><li>进程<br> 接收到请求后，fork一个子进程，由子进程来处理任务。因为每个进程的虚拟内存空间是独立的，所以进程间通信需要显式进行。常见的有：<br> 优点：共享文件表，不共享用户地址空间<br> 缺点：通信困难</li></ol><ol start="2"><li><p>I/O多路复用模型<br> 由select来监听接收请求，没有数据时CPU挂起，只有发生I/O事件时，才会处理。状态机模型，流之间的通信通过状态实现。例如：jdk的NIO模型、Netty的I/O模型</p><p> 改进：基于多路复用的事件驱动模型</p><p> 状态机模型：</p><pre><code>状态：等待描述符 $d_i$ 准备好可读，是否可读就是一种true/false的状态输入事件：描述符 $d_i$ 准备好可读，其实就是一个触发事件转移：从描述符 $d_i$ 读取数据，即状态转移，</code></pre><p> 优点：处于同一进程内，所有的流可以共享该进程的全部地址空间<br> 缺点：编码复杂度上升</p></li><li><p>线程<br> 多个线程在单一进程中，由内核统一调度，像进程一样，但是共享进程的虚拟内存空间。<br> 每个线程有自己的执行上下文，线程代码和局部数据被封装在一个线程例程中。每个独立的线程中的线程栈通常不能被其它线程访问，除非线程得到指向其他线程的访问指针。除此之外，线程中的全局变量、静态变量只存在进程的虚拟内存中，可以被其它线程访问</p><p> Posix线程：在C程序中处理线程的一个标准接口</p><p> 可结合线程：线程能够被其它线程收回和杀死，内存也可以被其它线程回收。<br> 可分离线程：线程不能够被其它线程收回和杀死，内存由系统管理</p></li></ol><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>共享变量存在线程安全的问题，可以使用一种进度图模型分析指令执行顺序问题。然后引入了信号量机制</p><h3 id="进度图"><a href="#进度图" class="headerlink" title="进度图"></a>进度图</h3><p>进度图：n个并发线程的执行模型。进度图模型存在局限性，多处理器并发执行，不能使用进度图解释<br>临界区：</p><p>互斥</p><p>不安全区</p><p>安全轨迹<br>不安全轨迹</p><h3 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h3><p>主要包含2个操作P(s)、V(s)，<br>P(s): 对s减1。如果s非0，则执行P线程s减1，否则P挂起，等待V唤醒<br>V(s): 对s加1。V可以重启P线程</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统--概览</title>
      <link href="/2019/05/29/csapp-base/"/>
      <url>/2019/05/29/csapp-base/</url>
      
        <content type="html"><![CDATA[<p>2014年就接触CSAPP，一直拖一直拖，直到今天才决定完完整整深耕，并产生输出。无论什么原因吧，种一棵树的最好时机就是十年前，还有就是今天。</p><a id="more"></a><h2 id="7-操作系统"><a href="#7-操作系统" class="headerlink" title="7. 操作系统"></a>7. 操作系统</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统：处于应用程序和底层硬件之间，对应用程序提供API接口。例如Windows、Linux、MacOS等。</p><p>主要的作用：</p><blockquote><p>防止硬件被应用程序随意调用<br>提供统一的接口。因为底层硬件商不同，内部实现也不一样，操作系统对所有的硬件提供一个统一的实现标准</p></blockquote><p>标准：<br>    Unix：贝尔实验室开发的一套系统<br>    Posix标准：IEEE为了规范Unix的开发，制定了一些标准。系统调用的C语言接口、shell程序、工具、线程、网络编程<br>    标准Unix规范：”标准Unix规范”工作组和Posix一起创建的Unix系统标准</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件：对I/O设备的抽象</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存：对主存、磁盘等I/O设备的抽象，和文件的描述存在交集，很难说谁包含谁</p><p>虚拟内存分为<br>内核虚拟内存：存储操作系统的代码和数据，对所有进程不可见<br>进程虚拟内存：存放所有进程信息</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程：对处理器、主存、磁盘I/O的抽象</p><p>进程是对操作系统中正在运行的程序的一种抽象。<br>计算机CPU分单核、多核，即使一个CPU，看起来好像并发执行多个进程，实际上内部是通过进程间切换实现的，即’上下文切换’</p><p>上下文：进程在运行状态下，操作系统会维护进程所有的信息(主存内容、寄存器文件的当前值)。进程各自的这些信息就是上下文。</p><p>上下文切换：每个CPU每个时刻只能有一个进程运行，把CPU的控制权交给别的进行，换取CPU的进程可以继续上次的执行，进程间运行的切换就是上下文切换</p><p>线程：一个进程可以由多个线程组成，每个线程运行在进程的上下文中，共享同样的代码和全局变量。</p><h4 id="并发、并行"><a href="#并发、并行" class="headerlink" title="并发、并行"></a>并发、并行</h4><p>并发运行：</p><p>并行运行：</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于今天某思面试的思考</title>
      <link href="/2019/05/29/thinking-in-20190529/"/>
      <url>/2019/05/29/thinking-in-20190529/</url>
      
        <content type="html"><![CDATA[<p>今天下午参加了某思的面试，天挺热的，某思去了两次，第一次面到总监，莫名其妙的杳无音讯。这次是第二次。<br>面试过程前HR提前说明了面试官喜欢问算法，也没怎么准备，只是为了白板，简单看了一下基础的算法。</p><a id="more"></a><p>面试中因为面试官看到我不是科班出身，就问了我两道题，一道关于系统中进程和线程，我答的不是很好，面试官说再考考你的基础，就出了一道算法题，大约五分钟后，</p><blockquote><p>面试官问我有思路吗，<br>其实这个并不难，我就把思路大致讲了一下，<br>然后面试官就要结束，习惯性的说，你还有什么要问我的吗<br>我说，我表现很差吗？<br>接着，他说不问上层应用层的东西，比较注重基础 blablabla…<br>我接着问，这道算法题是有什么模式吗？您是怎么做的？<br>其实这个，blabla…讲了一堆<br>我说，我这个用Map有问题吗？<br>你这个主要是太占空间(这时候，我其实很无奈，就是一个优化的问题，但是我也没办法)<br>然后，我说前辈有什么要指导的吗？<br>你既然是非科班出身，就应该在一年内把计算机系统、编译原理、数据结构、网络这些都学习一下(此时，我知道面试官只是对我的出身比较有看法吧，所谓的这几道题无非是不显得那么明显)</p></blockquote><p>面试出来，我知道这个行业门槛越来越高，而我们这些非科班出身的人，未来的路将越来越难走，我觉得自己在这个级别上，表现并没有那么差，但是依然会有人用自己的偏见去看待这一切。</p><p>虽然有点不甘，但是给自己加油吧！希望未来的自己越来越强大！</p><p>拆分目标，把每年的计划拆分到每个月，每一周，然后不断的复盘，总结，看看自己能不能突破当前的桎梏</p><p>6月计划：</p><p>一、读完《CSAPP》，并整理出博客</p><p>二、读完《HTTP/IP详解卷1》，并整理出博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络中的网桥、交换机、集线器</title>
      <link href="/2019/05/29/net-hub-bridge-switch/"/>
      <url>/2019/05/29/net-hub-bridge-switch/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统--I/O</title>
      <link href="/2019/05/29/csapp-io/"/>
      <url>/2019/05/29/csapp-io/</url>
      
        <content type="html"><![CDATA[<p>看了CSAPP中关于I/O部分，感觉找不到重点，又浏览了一下《Linux内核设计与实现》，总感觉缺点意思，下一步希望能够结合《计算机组成与设计》分析一下</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-iris-websocket</title>
      <link href="/2019/05/27/go-iris-websocket/"/>
      <url>/2019/05/27/go-iris-websocket/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dart和Flutter的那些事儿</title>
      <link href="/2019/05/27/flutter-base/"/>
      <url>/2019/05/27/flutter-base/</url>
      
        <content type="html"><![CDATA[<p>Flutter是一门</p>]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对一些事情的思考</title>
      <link href="/2019/05/04/thinking-in-youthday/"/>
      <url>/2019/05/04/thinking-in-youthday/</url>
      
        <content type="html"><![CDATA[<p>从2019-04-22开始第一次面试，到现在半个月的时间。个中经历不用言语，最大的感受就是发现自己越来越菜，需要学习的东西越来越多。</p><p>从五一开始也一直在整理收藏的技术博客，面试中很多东西说不明白，终究还是没有真正明白。每次面对面试官无法回答问题，都感觉好尴尬，默默地骂自己一句：“辣鸡”。</p><a id="more"></a><p>针对面试的弱点主要以下几点：</p><p>1、缺乏深入</p><p>很多知识点，只能说个大概，底层的概念很模糊。</p><p>将来要循序渐进的对弱点进行源码分析，分析源码可以更好的成长。</p><p>2、对新技术缺乏认识。</p><p>分布式、高并发、JVM调优，这些虽然很少接触，还是要抽时间模拟实践一下。</p><p>要能实现基本的Demo，才算对新技术的简单了解</p><p>3、坚持算法</p><p>算法和实际工作关系不大，但是刷算法能保证不断的思考，加深问题的分析能力</p><p>每天坚持算法</p><p>今年的目标就是把知识点串成面，写出精品，而不是每天制造垃圾。</p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper原子广播协议ZAB(二)</title>
      <link href="/2019/04/12/zk-zab/"/>
      <url>/2019/04/12/zk-zab/</url>
      
        <content type="html"><![CDATA[<p>ZAB 源自一致性协议</p><a id="more"></a><h2 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h2><p>Chubby技术架构</p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>Zookeeper Atomic Broadcast，ZooKeeper原子消息广播协议</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>保证各个服务器之间的数据一致性</li><li>leader节点无法工作后，ZAB协议自动从Follower节点中选举新的leader</li></ol><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>写请求分为leader、follower/observer两种接收</p><h4 id="写leader"><a href="#写leader" class="headerlink" title="写leader"></a>写leader</h4><h4 id="写follower-observer"><a href="#写follower-observer" class="headerlink" title="写follower/observer"></a>写follower/observer</h4><p>follower/observer接收到写请求都会转发到leader，再由leader<br>做一些ACK机制处理</p><h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>leader/follower/observer都可以处理读请求，直接返回结果给客户端</p>]]></content>
      
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java特殊类Unsafe</title>
      <link href="/2019/03/23/java-unsafe/"/>
      <url>/2019/03/23/java-unsafe/</url>
      
        <content type="html"><![CDATA[<p>Unsafe类，回头整理</p><a id="more"></a><p>特性</p><ol><li><p>虚拟机“集约化”（VM intrinsification）：如用于无锁Hash表中的CAS（比较和交换）。再比如compareAndSwapInt这个方法用JNI调用，包含了对CAS有特殊引导的本地代码。在这里你能读到更多关于CAS的信息：<a href="http://en.wikipedia.org/wiki/Compare-and-swap。" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Compare-and-swap。</a></p></li><li><p>主机虚拟机（译注：主机虚拟机主要用来管理其他虚拟机。而虚拟平台我们看到只有guest VM）的sun.misc.Unsafe功能能够被用于未初始化的对象分配内存（用allocateInstance方法），然后将构造器调用解释为其他方法的调用。</p></li><li><p>你可以从本地内存地址中追踪到这些数据。使用java.lang.Unsafe类获取内存地址是可能的。而且可以通过unsafe方法直接操作这些变量！</p></li><li><p>使用allocateMemory方法，内存可以被分配到堆外。例如当allocateDirect方法被调用时DirectByteBuffer构造器内部会使用allocateMemory。</p></li><li><p>arrayBaseOffset和arrayIndexScale方法可以被用于开发arraylets，一种用来将大数组分解为小对象、限制扫描的实时消耗或者在大对象上做更新和移动。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构中的网关</title>
      <link href="/2019/03/23/architecture-gateway/"/>
      <url>/2019/03/23/architecture-gateway/</url>
      
        <content type="html"><![CDATA[<p>网关在微服务中的应用</p><p>特性：</p><p>认证、鉴权、缓存、服务编排、监控告警</p><p>权限分级、流量管控、超时熔断</p><a id="more"></a><p>场景：</p><h2 id="组件对比"><a href="#组件对比" class="headerlink" title="组件对比"></a>组件对比</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>原理：异步非阻塞</p><h3 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>身份认证与安全：识别每个资源的验证要求，并拒绝那些与要求不符的请求。</p><p>审查与监控：与边缘位置追踪有意义的数据和统计结果，从而带来精确的生产视图。</p><p>动态路由：动态地将请求路由到不同的后端集群。</p><p>压力测试：逐渐增加指向集群的流量，以了解性能。</p><p>负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求。</p><p>静态响应处理：在边缘位置直接建立部分响应，从而避免其转发到内部集群。</p><p>多区域弹性：跨越 AWS Region 进行请求路由，旨在实现 ELB（Elastic Load Balancing，弹性负载均衡）使用的多样化，以及让系统的边缘更贴近系统的使用者。</p><p>zuul1 </p><p>原理：阻塞+多线程的过滤器，线程激增</p><p>zuul2</p><p>异步非阻塞，事件+回调</p><p>高可用方案：</p><blockquote><p>zuul集群 + eureka server<br>Nginx/HAproxy/F5 + zuul</p></blockquote><h3 id="Linkerd"><a href="#Linkerd" class="headerlink" title="Linkerd"></a>Linkerd</h3><h3 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h3><h3 id="Undertow"><a href="#Undertow" class="headerlink" title="Undertow"></a>Undertow</h3><h3 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于写作</title>
      <link href="/2019/03/23/thinking-in-writing/"/>
      <url>/2019/03/23/thinking-in-writing/</url>
      
        <content type="html"><![CDATA[<p>关于我，对于感兴趣的事情，会尽力克服拖延症，带着乐趣去做一些事情。但是往往有时候因为忙或者其他原因，一直拖延，直到欠下的债太多，才会强迫自己重新开始。</p><a id="more"></a><p>写作其实是一件很费力的事情，尤其是写技术博客，更是需要很多精力，关于写的一些东西，有时间会结合一些方法论补充一下。强化一下自己的写作意识:(待续…</p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark基础</title>
      <link href="/2019/03/16/spark-scala-loader/"/>
      <url>/2019/03/16/spark-scala-loader/</url>
      
        <content type="html"><![CDATA[<p>依赖包provided</p><p>assembly打包</p><h2 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h2><p>转化操作 – 惰性求值</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搬瓦工搭建Shadowsocks服务器完整教程</title>
      <link href="/2019/03/07/ss-bwh/"/>
      <url>/2019/03/07/ss-bwh/</url>
      
        <content type="html"><![CDATA[<p>利用国外服务器搭建翻墙服务。</p><p>1、搜索搬瓦工，注册账号，购买服务器</p><p>先借用赛风搜索搬瓦工网站，由于国内对搬瓦工的封锁，无法确定一个固定的域名，比如我原来使用<a href="https://bwh8.net，后来突然就不能访问了，搜索后，发现bwh1.net可以访问" target="_blank" rel="noopener">https://bwh8.net，后来突然就不能访问了，搜索后，发现bwh1.net可以访问</a></p><p>2、安装Shadowsocks server，配置服务器信息</p><p>3、下载Shadowsocks client，配置代理信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> SS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>computer</title>
      <link href="/2019/02/13/computer/"/>
      <url>/2019/02/13/computer/</url>
      
        <content type="html"><![CDATA[<h2 id="大型机"><a href="#大型机" class="headerlink" title="大型机"></a>大型机</h2><p>特点：</p><ol><li>RAS</li></ol><h2 id="小型机"><a href="#小型机" class="headerlink" title="小型机"></a>小型机</h2><p>RISC、MIPS指令</p><h2 id="x86架构服务器"><a href="#x86架构服务器" class="headerlink" title="x86架构服务器"></a>x86架构服务器</h2><p>CISC指令</p><h2 id="ARM架构服务器"><a href="#ARM架构服务器" class="headerlink" title="ARM架构服务器"></a>ARM架构服务器</h2><p>RISC指令</p><h2 id="power、sparc、安腾、xeon"><a href="#power、sparc、安腾、xeon" class="headerlink" title="power、sparc、安腾、xeon"></a>power、sparc、安腾、xeon</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Computer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet Web容器对比</title>
      <link href="/2019/02/12/tomcat-jetty-undertow/"/>
      <url>/2019/02/12/tomcat-jetty-undertow/</url>
      
        <content type="html"><![CDATA[<h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><h2 id="jetty"><a href="#jetty" class="headerlink" title="jetty"></a>jetty</h2><h2 id="undertow"><a href="#undertow" class="headerlink" title="undertow"></a>undertow</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线上错误排查</title>
      <link href="/2019/02/12/java-btrace-arthas/"/>
      <url>/2019/02/12/java-btrace-arthas/</url>
      
        <content type="html"><![CDATA[<p>线上排查问题一般通过查看日志的方式，这篇博客目的在于整理一些线上排查的工具</p><a id="more"></a><h2 id="Btrace"><a href="#Btrace" class="headerlink" title="Btrace"></a>Btrace</h2><p><a href="https://github.com/btraceio/btrace" target="_blank" rel="noopener">btrace</a></p><h2 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h2><p><a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">arthas</a></p><h3 id="tt命令"><a href="#tt命令" class="headerlink" title="tt命令"></a>tt命令</h3><h3 id="watch命令"><a href="#watch命令" class="headerlink" title="watch命令"></a>watch命令</h3><h2 id="greys-anatomy"><a href="#greys-anatomy" class="headerlink" title="greys-anatomy"></a>greys-anatomy</h2><p><a href="https://github.com/oldmanpushcart/greys-anatomy" target="_blank" rel="noopener">greys-anatomy</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务治理</title>
      <link href="/2019/02/12/spring-service-manage/"/>
      <url>/2019/02/12/spring-service-manage/</url>
      
        <content type="html"><![CDATA[<p>简单了解服务治理</p><h2 id="OCTO框架"><a href="#OCTO框架" class="headerlink" title="OCTO框架"></a>OCTO框架</h2>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在2019上班的第二天</title>
      <link href="/2019/02/12/thinking-in-2019/"/>
      <url>/2019/02/12/thinking-in-2019/</url>
      
        <content type="html"><![CDATA[<p>从2019年元旦开始，就在筹划写一篇总结，一直拖到今天。</p><p>写博客其实是一件很费时的事情，也只有在冷静的时候，才会静下心来思考这件事情，这可能也是迟迟未写的原因之一吧。</p><a id="more"></a><h1 id="2018回顾"><a href="#2018回顾" class="headerlink" title="2018回顾"></a>2018回顾</h1><p>2018这一年，经历了很多的事情，主题是工作，也关乎风月。</p><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>工作上，3月1号出门面试，第一家面的x德，3月2号去面的x东。刚开始不太喜欢加班，就接了x德的offer，是一个全新的团队，也为后来埋了很多坑，具体的就不再吐槽了，主要说说自己的问题。这半年里，了解了一下区块链，没多久，国内外接连出台了很多对区块链比特币的整顿政策，一下子凉凉。在工作中开始使用SpringBoot、SpringCloud的一整套架构。半年后接受不了团队混乱的管理，打算出来。甚至怀疑所谓的技术理想。</p><p>4月初清明节上午加班，下午赶飞机飞到重庆。对重庆的好感来自于《从你的全世界路过》，就这样一个人在重庆呆了三天，这是一座很有特色的城市，但是景点过于商业化，未来有机会和另一个人一起过来。</p><p>5月初独自骑车子从沙河一直骑到十三陵，这是在北京的第一次骑行，而且是一个人，路上车轱辘散架、大卡车、回来的路上遇到下雨，晚上直到十一点多才回到家里，又累又困，可以说真的是一次记忆深刻的骑行了。</p><p>从x德出来后，困惑了一段时间，想起自己一直想去未去的西藏，果断买了票过去。去到一个完全陌生而又向往的地方，一开始充满了期待。布达拉宫、大昭寺、巴松错、羊湖、日喀则、珠峰，一切都是新的。在林芝的时间，去见了朋友。而在西藏的这段时间里，让我有了更多的独处时间去思考，想起这半年来的各种事情，突然就感到豁然开朗。就这样待到11月份，后来的几天有点审美疲劳了吧，就天天坐在布达拉宫广场晒太阳。有拍婚纱照的，有朝圣的。后来甚至有点期待返京的日子。这可能就是“旅行就是从自己厌倦的地方去到一个别人厌倦的地方吧”。如果说旅行的意义是什么，我想，就是让自己进入慢节奏的生活，去思考，把自己的生活捋顺吧。意外的是收获了一首好歌–《狗屁青春》，朴树唱的，在路上听的时候还别有一番滋味。</p><p>从西藏回来后，心态好了很多，一些事情想通后也没有必要再去在乎或者纠结。只把心思放在工作上，希望能有更多的产出，</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><h3 id="看过的电影："><a href="#看过的电影：" class="headerlink" title="看过的电影："></a>看过的电影：</h3><p>华尔街之子</p><p>大空头</p><p>互联网之子</p><p>驴得水</p><p>狗十三</p><p>人生果实</p><h3 id="看过的书："><a href="#看过的书：" class="headerlink" title="看过的书："></a>看过的书：</h3><p>回来</p><p>人类简史</p><p>商业的本质</p><p>引爆点</p><p>黑客与画家</p><p>独居的一年</p><p>小王子</p><p>我们都是孤独的行路人</p><p>只是为了好玩儿</p><h1 id="2019展望"><a href="#2019展望" class="headerlink" title="2019展望"></a>2019展望</h1><ol><li>考驾照，一直拖到现在还未完成的计划今年必须完成</li><li>学习吉他，虽然五音不全，年少不再，还是要学习一门乐器</li><li>坚持健身(跑步)，这个年龄总该意识到这个问题</li><li>工作上有一些突破</li><li>买一辆更好的山地车去骑行</li><li>读30本书，那些一年读100本书的人真的很厉害了</li></ol><p>人生需要不断的前行、试错、复盘。前面走了太多的弯路，未来要跑起来鸭！以后会尽量把经历记录下来，也不免是人生的一些回忆。</p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-cloud-eureka</title>
      <link href="/2019/01/23/spring-cloud-eureka/"/>
      <url>/2019/01/23/spring-cloud-eureka/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>断路器</title>
      <link href="/2019/01/17/spring-cloud-hystrix/"/>
      <url>/2019/01/17/spring-cloud-hystrix/</url>
      
        <content type="html"><![CDATA[<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>特性：</p><p>应用场景：</p><ol><li>隔离（线程隔离、信号量隔离）：主要是限制调用分布式服务的资源，避免个别服务出现问题时对其他服务产生影响</li><li>熔断（容错）：当失败率达到一定阈值时，熔断器触发快速失败</li><li>降级（超时降级、熔断降级）：触发降级时可以使用回调方法返回托底数据</li><li>缓存：请求缓存、请求合并</li><li>实时监控、报警</li></ol><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>特性：</p><ol><li>轻量级、高性能： sentinel-core不到200KB，单机超过25W QPS才会有影响</li><li>流量控制：以不同的运行指标为基准，<blockquote><p>直接拒绝模式<br>慢启动预热模式<br>匀速度模式</p></blockquote></li><li>系统负载保护</li></ol><p>应用场景：</p><ol><li>和Dubbo整合，通过限流实现服务的高可用</li><li>和RocketMQ整合，通过匀速请求和冷启动保障服务的稳定性</li></ol><h3 id="Hystrix和Sentinel的对比"><a href="#Hystrix和Sentinel的对比" class="headerlink" title="Hystrix和Sentinel的对比"></a>Hystrix和Sentinel的对比</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot的启动类</title>
      <link href="/2019/01/17/spring-boot-runner/"/>
      <url>/2019/01/17/spring-boot-runner/</url>
      
        <content type="html"><![CDATA[<p>项目启动之前，可以有一些初始化动作：读取配置文件、数据库连接。SpringBoot提供了两个接口：’CommandLineRunner’和’ApplicationRunner’，通过‘@Order’注解定义启动顺序</p><a id="more"></a><h2 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Order</span>(<span class="number">10</span>)</span><br><span class="line"><span class="variable">@Slf4j</span></span><br><span class="line">public class ApplicationStartup implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">   <span class="variable">@Autowired</span></span><br><span class="line">   private DataService dataService;</span><br><span class="line">   </span><br><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void run(String... args) throws Exception &#123;</span><br><span class="line"><span class="selector-tag">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ApplicationRunner"><a href="#ApplicationRunner" class="headerlink" title="ApplicationRunner"></a>ApplicationRunner</h2><p>该接口的run方法参数是一个ApplicationArguments类</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Order</span>(<span class="number">10</span>)</span><br><span class="line"><span class="variable">@Slf4j</span></span><br><span class="line">public class AppApplicationStartup implements ApplicationRunner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private AppPushService appPushService;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定时推送消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="selector-tag">appPushService</span><span class="selector-class">.pushSimplePayload</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-cloud-components</title>
      <link href="/2019/01/14/spring-cloud-components/"/>
      <url>/2019/01/14/spring-cloud-components/</url>
      
        <content type="html"><![CDATA[<h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>spring-cloud-starter-feign(已废弃)</p><p>spring-cloud-starter-openfeign</p><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>spring-cloud-starter-eureka(已废弃)</p><p>spring-cloud-starter-eureka-server(已废弃)</p><p>spring-cloud-starter-netflix-eureka-client</p><p>spring-cloud-starter-netflix-eureka-server</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cat-architecture</title>
      <link href="/2019/01/07/cat-architecture/"/>
      <url>/2019/01/07/cat-architecture/</url>
      
        <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>一段代码的执行时间，一段代码可以是URL执行耗时，也可以是SQL的执行耗时。</li><li>一段代码的执行次数，比如Java抛出异常记录次数，或者一段逻辑的执行次数。</li><li>定期执行某段代码，比如定期上报一些核心指标：JVM内存、GC等指标。</li><li>关键的业务监控指标，比如监控订单数、交易额、支付成功率等。</li></ol><h3 id="埋点"><a href="#埋点" class="headerlink" title="埋点"></a>埋点</h3><ol><li>HTTP/REST、RPC/SOA、MQ、Job、Cache、DAL;</li><li>搜索/查询引擎、业务应用、外包系统、遗留系统;</li><li>第三方网关/银行, 合作伙伴/供应商之间；</li><li>各类业务指标，如用户登录、订单数、支付状态、销售额。</li></ol><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>cat-client</p><p>cat-consumer</p><p>cat-home</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>Transaction</p><p>Event</p><p>Heartbeat</p><p>Metric</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>html5-doctype</title>
      <link href="/2019/01/07/html5-doctype/"/>
      <url>/2019/01/07/html5-doctype/</url>
      
        <content type="html"><![CDATA[<p>HTML5基本声明：</p><pre><code>&lt;!DOCTYPE html&gt; </code></pre><p>使用外部svg时，</p><pre><code>&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot;      &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat--概览</title>
      <link href="/2019/01/03/tomcat-base/"/>
      <url>/2019/01/03/tomcat-base/</url>
      
        <content type="html"><![CDATA[<p>Tomcat作为常见的Servlet容器，我接触的从最初的SSH/SSM架构，Tomcat需要单独维护，到SpringBoot的嵌入式容器。</p><a id="more"></a><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><h3 id="Connector-amp-Container"><a href="#Connector-amp-Container" class="headerlink" title="Connector &amp; Container"></a>Connector &amp; Container</h3><h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>负责处理Service的请求，Connector作为中间媒介</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>表示一个虚拟主机，每个虚拟主机和一个网络域名对应</p><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>每个Context对应一个Web应用</p><p>Wrapper：代表一个Servlet，使用门面设计模式</p><p>Connector有两种：可以在server.xml中看到配置<br>1) 监听8080端口<br>2) 监听8009端口</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>1、</p><p>3、并行类加载</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="独立容器"><a href="#独立容器" class="headerlink" title="独立容器"></a>独立容器</h3><p>1、日志乱码问题</p><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>1、URL路径转义问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-boot-starter</title>
      <link href="/2018/12/31/spring-boot-starter/"/>
      <url>/2018/12/31/spring-boot-starter/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java--范型</title>
      <link href="/2018/12/26/java-pattern/"/>
      <url>/2018/12/26/java-pattern/</url>
      
        <content type="html"><![CDATA[<p>范型是一种语法糖，</p><a id="more"></a><h3 id="范型擦除"><a href="#范型擦除" class="headerlink" title="范型擦除"></a>范型擦除</h3><p>范型只在编译阶段有效，在生成字节码后类型会被擦除。范型可以用在范型类、范型接口、范型方法</p><h3 id="范型标识"><a href="#范型标识" class="headerlink" title="范型标识"></a>范型标识</h3><ol><li>E - Element (在集合中使用，因为集合中存放的是元素)，E是对各方法中的泛型类型进行限制，以保证同一个对象调用不同的方法时，操作的类型必定是相同的。E可以用其它任意字母代替</li><li>T - Type（Java 类），T代表在调用时的指定类型。会进行类型推断</li><li>K - Key（键）</li><li>V - Value（值）</li><li>N - Number（数值类型）</li><li>？ -  表示不确定的java类型，是类型通配符，代表所有类型。？不会进行类型推断</li></ol><h3 id="通配符，范型上下边界"><a href="#通配符，范型上下边界" class="headerlink" title="通配符，范型上下边界"></a>通配符，范型上下边界</h3><p>&lt;?&gt;</p><p>&lt;? extends T&gt;</p><p>&lt;? super T&gt;</p><h3 id="范型数组"><a href="#范型数组" class="headerlink" title="范型数组"></a>范型数组</h3><p>注意：<strong> 不能创建一个确定类型的范型数组 </strong></p><p>例如：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;[<span class="number">10</span>];  <span class="comment">// 错误</span></span><br><span class="line"><span class="built_in">List</span>&lt;?&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>];  <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p><h3 id="静态方法和范型"><a href="#静态方法和范型" class="headerlink" title="静态方法和范型"></a>静态方法和范型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanUtils工具类</title>
      <link href="/2018/12/25/java-beanutils/"/>
      <url>/2018/12/25/java-beanutils/</url>
      
        <content type="html"><![CDATA[<p>BeanUtils和PropertyUtils</p><a id="more"></a><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.beans</span><span class="selector-class">.BeanUtils</span><span class="selector-class">.copyProperties</span>(<span class="selector-tag">src</span>, <span class="selector-tag">dest</span>);</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.commons</span><span class="selector-class">.beanutils</span><span class="selector-class">.BeanUtils</span><span class="selector-class">.copyProperties</span>(<span class="selector-tag">src</span>, <span class="selector-tag">dest</span>);</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.commons</span><span class="selector-class">.beanutils</span><span class="selector-class">.BeanUtilsBean</span><span class="selector-class">.getInstance</span>()<span class="selector-class">.copyProperties</span>(<span class="selector-tag">src</span>, <span class="selector-tag">dest</span>);</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.commons</span><span class="selector-class">.beanutils</span><span class="selector-class">.PropertyUtils</span><span class="selector-class">.copyProperties</span>(<span class="selector-tag">src</span>, <span class="selector-tag">dest</span>);</span><br></pre></td></tr></table></figure><h2 id="BeanUtils和PropertyUtils的区别"><a href="#BeanUtils和PropertyUtils的区别" class="headerlink" title="BeanUtils和PropertyUtils的区别"></a>BeanUtils和PropertyUtils的区别</h2><ol><li>beanutils支持name相同、类型兼容的属性转换；propertyutils仅支持name相同、类型相同的属性转换</li><li><p>beanutils对部分属性不支持null的转换；propertyutils支持null的转换</p></li><li><p>对于Long和Date类型的转换，BeanUtils转换正常；PropertyUtils报错</p></li><li>自定义的对象属性类型，都是浅拷贝</li><li>BeanUtils支持自定义Converter接口，PropertyUtils没有</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java序列化Serializable</title>
      <link href="/2018/12/25/java-serializable/"/>
      <url>/2018/12/25/java-serializable/</url>
      
        <content type="html"><![CDATA[<p>类要实例化必须实现Serializable接口，类的序列化/反序列化通过serialVersionUID唯一确认，当没有显式设置时，系统会默认生成一个，同一个类每次实例生成不同的serialVersionUID。</p><a id="more"></a><h2 id="Serializable和Externalizable"><a href="#Serializable和Externalizable" class="headerlink" title="Serializable和Externalizable"></a>Serializable和Externalizable</h2><p>序列化类型是String、Array、Enum、Serializable时，则序列化，否则抛出不允许序列化的异常’NotSerializableException’。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写 writeExternal()与readExternal()方法。否则所有变量的值都会变成默认值。</strong></p><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后， transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p><h2 id="自定义序列化策略"><a href="#自定义序列化策略" class="headerlink" title="自定义序列化策略"></a>自定义序列化策略</h2><p>在序列化过程中，如果被序列化的类中定义了writeObject 和 readObject 方法，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化。</p><p>如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。</p><h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p><strong>注意</strong> 在做兼容性升级时，不要修改serialVersionUID的值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis中sql的解析过程(四)</title>
      <link href="/2018/12/25/mybatis-sql/"/>
      <url>/2018/12/25/mybatis-sql/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作maven插件</title>
      <link href="/2018/12/25/maven-plugin/"/>
      <url>/2018/12/25/maven-plugin/</url>
      
        <content type="html"><![CDATA[<p>开发Maven插件，原来做过，但是今天看，竟然没有留下记录，以后新东西必须强迫自己写博客！！！</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中paralelStream方法的坑</title>
      <link href="/2018/12/24/java-parallelstream/"/>
      <url>/2018/12/24/java-parallelstream/</url>
      
        <content type="html"><![CDATA[<p>今天在项目开发中使用parallelStream遍历ArrayList，发现数据有时候多有时候少，有时候出现’null’的对象，在本地甚至出现’Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException: 6246<br>‘</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-contenttype</title>
      <link href="/2018/12/24/js-contenttype/"/>
      <url>/2018/12/24/js-contenttype/</url>
      
        <content type="html"><![CDATA[<h2 id="none"><a href="#none" class="headerlink" title="none"></a>none</h2><h2 id="form-data"><a href="#form-data" class="headerlink" title="form-data"></a>form-data</h2><h2 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www.form-urlencoded"></a>x-<a href="http://www.form-urlencoded" target="_blank" rel="noopener">www.form-urlencoded</a></h2><h2 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h2>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-autowired-resource-service</title>
      <link href="/2018/12/21/spring-autowired-resource-service/"/>
      <url>/2018/12/21/spring-autowired-resource-service/</url>
      
        <content type="html"><![CDATA[<h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p>byType注入，</p><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><p>默认byName注入，有两个属性：name、type，可以自由定义</p><p>注解 @Resource 的装配顺序：</p><ol><li>如果同时指定了 name 和 type，则从 Spring 上下文中找到唯一匹配的 bean 进行装配，找不到则抛出异常； </li><li>如果指定了 name，则从上下文中查找名称（id）匹配的 bean 进行装配，找不到则抛出异常；</li><li>如果指定了 type，则从上下文中找到类型匹配的唯一 bean 进行装配，找不到或者找到多个，都会抛出异常；</li><li>如果既没有指定 name，又没有指定 type，则自动按照 byName 方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配成功，则进行自动装配。</li></ol><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>@Service，用于标注业务层组件（通常定义的 Service 层就用这个注解）；<br>@Controller，用于标注控制层组件（如 Struts 中的 action）；<br>@Repository，用于标注数据访问组件，即 DAO 层组件；<br>@Component，泛指组件，当组件不好归类的时候，咱们就可以用这个注解进行标注。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java-monitor</title>
      <link href="/2018/12/21/java-monitor/"/>
      <url>/2018/12/21/java-monitor/</url>
      
        <content type="html"><![CDATA[<h2 id="Btrace"><a href="#Btrace" class="headerlink" title="Btrace"></a>Btrace</h2><h2 id="jpda"><a href="#jpda" class="headerlink" title="jpda"></a>jpda</h2><h2 id="greys"><a href="#greys" class="headerlink" title="greys"></a>greys</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>session-cookie-token</title>
      <link href="/2018/12/19/session-cookie-token/"/>
      <url>/2018/12/19/session-cookie-token/</url>
      
        <content type="html"><![CDATA[<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>原理：存储在服务器上，服务器使用session把用户信息存储在服务器上(内存存放)，用户离开网站后，一般是30分钟后失效。</p><p>结构：</p><p>弊端：不适合分布式，如果有负载均衡，如果登录后，操作请求到另外的服务器，session不起作用</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>cookie是保存在浏览器本地的kv数据，由服务器生成，返给客户端(浏览器)，</p><p>结构：</p><blockquote><p>名称</p><p>值</p><p>有效域</p><p>路径</p><p>失效时间</p><p>安全标志</p></blockquote><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>原理：</p><p>结构：</p><blockquote><p>用户唯一身份标识<br>time 当前时间时间戳<br>sign 签名，hash(token前几位+salt)，可以防止第三方拼接<br>不变参数</p></blockquote><h3 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h3><h3 id="session和token"><a href="#session和token" class="headerlink" title="session和token"></a>session和token</h3><ol><li>token是无状态的，存储在客户端；session有状态，状态存储在服务器端。REST是无状态的，app不需要像浏览器那样存储cookie</li><li>token安全性比较好，可以防止监听、重防攻击；session保证安全需要靠链路层实现</li><li>token是唯一的，提供认证 + 鉴权；session是把用户信息存在服务器，只要有sessionid，即认为有全部权利。如果接口给第三方调用，使用token，否则两者都可</li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql-date</title>
      <link href="/2018/12/19/mysql-date/"/>
      <url>/2018/12/19/mysql-date/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql-int</title>
      <link href="/2018/12/19/mysql-int/"/>
      <url>/2018/12/19/mysql-int/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hystrix-sentinel-rs4j</title>
      <link href="/2018/12/19/hystrix-sentinel-rs4j/"/>
      <url>/2018/12/19/hystrix-sentinel-rs4j/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js跨域问题</title>
      <link href="/2018/12/16/js-cors/"/>
      <url>/2018/12/16/js-cors/</url>
      
        <content type="html"><![CDATA[<p>跨域其实很早就用，当时也没有整理。</p><p>CORS: CORS的目的不是为了解决CSRF，无法防止CSRF发生</p><p>CSRF: (Cross-site request forgery，跨站请求伪造)，CSRF攻击的发起方式有很多种，src资源标签、form表单、js代码</p><p><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域:阮老师的博客</a></p><a id="more"></a><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源：</p><blockquote><p>协议相同</p><p>域名相同</p><p>端口相同</p></blockquote><p>受限制的策略：</p><ol><li>Ajax请求</li><li>无法获取DOM元素并操作</li><li>无法读取Cookie、LocalStorage、IndexDB</li></ol><p>不受限制的策略：</p><p>WebSocket、Script、img、iframe、video、audio的src属性</p><h2 id="跨域场景"><a href="#跨域场景" class="headerlink" title="跨域场景"></a>跨域场景</h2><p>调用API接口</p><p>前后端分离</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>代理模式。分为正向代理、反向代理，自己伪造一个后端服务(例如Nodejs)接收并转发</li><li><p>CORS标准。服务端设置’Access-Control-Allow-Origin’ + ‘Access-Control-Allow-Credentials’，客户端设置withCredentials</p><p> <strong>注意：</strong>CORS默认不发送Cookie和HTTP认证信息，Credentials用来指定发送Cookie信息。如果要发送Cookie，’Access-Control-Allow-Origin’不能设置为’*’，而必须指定明确的、与请求网页一致的域名。</p></li><li><p>JSONP方式。通过script标签发起请求，服务端把数据放在js脚本里返回给客户端，但是只支持GET请求。CDN就是典型的应用。jQuery封装的JSONP</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存过期策略</title>
      <link href="/2018/12/16/redis-cache-policy/"/>
      <url>/2018/12/16/redis-cache-policy/</url>
      
        <content type="html"><![CDATA[<p>简单记录，回头需要深入再做整理</p><a id="more"></a><p>定时过期：每个设置过期时间的key分配定时器，到过期时间自动清除；占用CPU资源</p><p>惰性过期：当访问key时，才判断是否过期，过期则清除；如果大量key没有被访问，则不会被清除</p><p>定期过期：每隔一段固定时间，去扫描一定数量的数据库中expires字典表的key，</p><p><strong>Redis中同时使用了惰性过期和定期过期策略</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis内存淘汰策略</title>
      <link href="/2018/12/16/redis-mem-policy/"/>
      <url>/2018/12/16/redis-mem-policy/</url>
      
        <content type="html"><![CDATA[<p>Redis用于缓存的内存不足时，如何处理新写入需要申请额外空间的数据。</p><a id="more"></a><p><strong>32bit系统最大不能超过3G，64bit系统设置为0表示不限制</strong></p><p>设置淘汰策略：<br>    config get maxmemory<br>    config get maxmemory-policy</p><h2 id="6种淘汰策略"><a href="#6种淘汰策略" class="headerlink" title="6种淘汰策略"></a>6种淘汰策略</h2><ol><li>volatile-lru:从已设置过期时间的内存数据集中挑选最近最少使用的数据 淘汰；</li><li>volatile-ttl: 从已设置过期时间的内存数据集中挑选即将过期的数据 淘汰；</li><li>volatile-random:从已设置过期时间的内存数据集中任意挑选数据 淘汰；</li><li>allkeys-lru:从内存数据集中挑选最近最少使用的数据 淘汰；</li><li>allkeys-random:从数据集中任意挑选数据 淘汰；</li><li>no-enviction(驱逐)：禁止驱逐数据。（默认淘汰策略。当redis内存数据达到maxmemory，在该策略下，直接返回OOM错误）；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2018/12/15/mysql-base/"/>
      <url>/2018/12/15/mysql-base/</url>
      
        <content type="html"><![CDATA[<p>MySQL有三种版本，</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h2 id="Percona"><a href="#Percona" class="headerlink" title="Percona"></a>Percona</h2><p>XtraDB引擎</p><h2 id="MariaDB"><a href="#MariaDB" class="headerlink" title="MariaDB"></a>MariaDB</h2>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb开发中的字段验证</title>
      <link href="/2018/12/15/java-web-validate/"/>
      <url>/2018/12/15/java-web-validate/</url>
      
        <content type="html"><![CDATA[<p>Web开发中传参需要验证，JSR303定义了校验模型，不同的实现方式：</p><ol><li>javax validation</li><li>hibernate validation</li><li>spring validation</li><li>自定义校验</li></ol><a id="more"></a><h2 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h2><pre><code>空检查@Null       验证对象是否为null@NotNull    验证对象是否不为null, 无法查检长度为0的字符串@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.@NotEmpty 检查约束元素是否为NULL或者是EMPTY.Booelan检查@AssertTrue     验证 Boolean 对象是否为 true  @AssertFalse    验证 Boolean 对象是否为 false  长度检查@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  @Length(min=, max=) Validates that the annotated string is between min and max included.日期检查@Past           验证 Date 和 Calendar 对象是否在当前时间之前  @Future     验证 Date 和 Calendar 对象是否在当前时间之后  @Pattern    验证 String 对象是否符合正则表达式的规则数值检查，建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为&quot;&quot;,Integer为null@Min            验证 Number 和 String 对象是否大等于指定的值  @Max            验证 Number 和 String 对象是否小等于指定的值  @DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度@DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度@Digits     验证 Number 和 String 的构成是否合法  @Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。@Range(min=, max=) Checks whether the annotated value lies between (inclusive) the specified minimum and maximum.@Range(min=10000,max=50000,message=&quot;range.bean.wage&quot;)private BigDecimal wage;@Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证)@CreditCardNumber信用卡验证@Email  验证是否是邮件地址，如果为null,不进行验证，算通过验证。@ScriptAssert(lang= ,script=, alias=)@URL(protocol=,host=, port=,regexp=, flags=)</code></pre><h2 id="javax-validation"><a href="#javax-validation" class="headerlink" title="javax validation"></a>javax validation</h2><p>@Valid</p><p>分组校验</p><pre><code>@NotEmpty(groups={Person.class}</code></pre><h2 id="hibernate-validation"><a href="#hibernate-validation" class="headerlink" title="hibernate validation"></a>hibernate validation</h2><p>Hibernate validation有两种验证模式：</p><ol><li>普通模式</li><li>快速失败模式</li></ol><pre><code>ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class ).configure().failFast( true ).buildValidatorFactory(); Validator validator = validatorFactory.getValidator();</code></pre><h2 id="spring-validation"><a href="#spring-validation" class="headerlink" title="spring validation"></a>spring validation</h2><p><strong>注意：</strong>注解需要和BindingResult相邻，校验结果放在BindingResult对象中，例如：</p><pre><code>(@Validated Foo foo, BindingResult fooBindingResult ，@Validated Bar bar, BindingResult barBindingResult)</code></pre><h3 id="注解类型"><a href="#注解类型" class="headerlink" title="注解类型"></a>注解类型</h3><p>@Validated</p><p>@Valid和@Validated的区别：</p><ol><li>@Valid不提供分组类型 @Validated({Person.class})</li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>可以进行：数据库校验、组合校验(前后密码一致)</p><h3 id="NotNull、-NotEmpty和-NotBlank的区别"><a href="#NotNull、-NotEmpty和-NotBlank的区别" class="headerlink" title="@NotNull、@NotEmpty和@NotBlank的区别"></a>@NotNull、@NotEmpty和@NotBlank的区别</h3><p><strong>注意：</strong></p><ol><li>可以在controller内参数上直接加注解，但是必须在controller上@Validated</li><li>对象级联校验(即对象内部嵌套对象)时，嵌套对象上必须加注解@Valid</li><li>验证有时候可能被filter、swagger拦截，需要注意</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域请求</title>
      <link href="/2018/12/13/http-cors/"/>
      <url>/2018/12/13/http-cors/</url>
      
        <content type="html"><![CDATA[<p><a href="https://spring.io/blog/2015/06/08/cors-support-in-spring-framework" target="_blank" rel="noopener">Spring跨域文档</a></p><h2 id="跨域原理"><a href="#跨域原理" class="headerlink" title="跨域原理"></a>跨域原理</h2><h2 id="前端方案"><a href="#前端方案" class="headerlink" title="前端方案"></a>前端方案</h2><h2 id="后端方案"><a href="#后端方案" class="headerlink" title="后端方案"></a>后端方案</h2><h3 id="1-局部跨域"><a href="#1-局部跨域" class="headerlink" title="1. 局部跨域"></a>1. 局部跨域</h3><ol><li>添加在Cotroller上</li><li>添加在Method上</li><li>同时添加在Controller + Method上</li></ol><p><strong>注意：</strong></p><p>如果使用到Spring Security框架，确保在Spring Security层次上配置，同时允许使用Spring MVC层面的配置</p><pre><code>@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {    @Override    protected void configure(HttpSecurity http) throws Exception {        http.cors().and()...    }}</code></pre><h3 id="2-全局跨域"><a href="#2-全局跨域" class="headerlink" title="2. 全局跨域"></a>2. 全局跨域</h3><h4 id="1-基于JavaConfig方式"><a href="#1-基于JavaConfig方式" class="headerlink" title="1. 基于JavaConfig方式"></a>1. 基于JavaConfig方式</h4><p>使用全局方式</p><pre><code>@Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter {    @Override    public void addCorsMappings(CorsRegistry registry) {        registry.addMapping(&quot;/**&quot;);    }}</code></pre><p>如果使用Spring Boot，推荐：</p><pre><code>@Configurationpublic class MyConfiguration {    @Bean    public WebMvcConfigurer corsConfigurer() {        return new WebMvcConfigurerAdapter() {            @Override            public void addCorsMappings(CorsRegistry registry) {                registry.addMapping(&quot;/**&quot;);            }        };    }}</code></pre><p>CORS跨域的规则可以自由定制：</p><pre><code>@Overridepublic void addCorsMappings(CorsRegistry registry) {    registry.addMapping(&quot;/api/**&quot;)        .allowedOrigins(&quot;http://domain2.com&quot;)        .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;)            .allowedHeaders(&quot;header1&quot;, &quot;header2&quot;, &quot;header3&quot;)        .exposedHeaders(&quot;header1&quot;, &quot;header2&quot;)        .allowCredentials(false).maxAge(3600);}</code></pre><p><strong>注意：如果使用Spring Security，配置方式和局部跨域中相同</strong></p><ol start="2"><li><p>基于XML方式</p><p> <a href="mvc:cors" target="_blank" rel="noopener">mvc:cors</a></p><pre><code>&lt;mvc:mapping path=&quot;/api/**&quot;    allowed-origins=&quot;http://domain1.com, http://domain2.com&quot;    allowed-methods=&quot;GET, PUT&quot;    allowed-headers=&quot;header1, header2, header3&quot;    exposed-headers=&quot;header1, header2&quot; allow-credentials=&quot;false&quot;    max-age=&quot;123&quot; /&gt;&lt;mvc:mapping path=&quot;/resources/**&quot;    allowed-origins=&quot;http://domain1.com&quot; /&gt;</code></pre><p> &lt;/mvc:cors&gt;</p></li></ol><p><strong>注意：使用Spring Security</strong></p><pre><code>&lt;http&gt;    &lt;!-- Default to Spring MVC&apos;s CORS configuration --&gt;    &lt;cors /&gt;    ...&lt;/http&gt;</code></pre><ol start="3"><li><p>基于Filter方式</p><p> @Configuration<br> public class MyConfiguration {</p><pre><code>@Beanpublic FilterRegistrationBean corsFilter() {    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();    CorsConfiguration config = new CorsConfiguration();    config.setAllowCredentials(true);    config.addAllowedOrigin(&quot;http://domain1.com&quot;);    config.addAllowedHeader(&quot;*&quot;);    config.addAllowedMethod(&quot;*&quot;);    source.registerCorsConfiguration(&quot;/**&quot;, config);    FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source));    bean.setOrder(0);    return bean;}</code></pre><p> }</p></li></ol><p><a href="https://www.jianshu.com/p/87e1ef68794c" target="_blank" rel="noopener">参考1</a></p><p><a href="https://blog.csdn.net/pinebud55/article/details/60874725" target="_blank" rel="noopener">参考2</a></p><p><strong>注意：使用Spring Security</strong></p><pre><code>@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {    @Override    protected void configure(HttpSecurity http) throws Exception {        http            // by default uses a Bean by the name of corsConfigurationSource            .cors().and()            ...    }    @Bean    CorsConfigurationSource corsConfigurationSource() {        CorsConfiguration configuration = new CorsConfiguration();        configuration.setAllowedOrigins(Arrays.asList(&quot;https://example.com&quot;));        configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;,&quot;POST&quot;));        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();        source.registerCorsConfiguration(&quot;/**&quot;, configuration);        return source;    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web中身份验证和授权</title>
      <link href="/2018/12/06/java-web-auth/"/>
      <url>/2018/12/06/java-web-auth/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenAPI2-0"><a href="#OpenAPI2-0" class="headerlink" title="OpenAPI2.0"></a>OpenAPI2.0</h2><h2 id="OpenAPI3-0"><a href="#OpenAPI3-0" class="headerlink" title="OpenAPI3.0"></a>OpenAPI3.0</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">components</span>:</span><br><span class="line"><span class="attribute">securitySchemes</span>:</span><br><span class="line"></span><br><span class="line"><span class="attribute">BasicAuth</span>:</span><br><span class="line"><span class="attribute">type</span>: http</span><br><span class="line"><span class="attribute">scheme</span>: basic</span><br><span class="line"><span class="attribute">BearerAuth</span>:</span><br><span class="line"><span class="attribute">type</span>: http</span><br><span class="line"><span class="attribute">scheme</span>: bearer</span><br><span class="line"></span><br><span class="line"><span class="attribute">ApiKeyAuth</span>:</span><br><span class="line"><span class="attribute">type</span>: apikey</span><br><span class="line"><span class="attribute">in</span>: header</span><br><span class="line"><span class="attribute">name</span>: X-API-Key</span><br><span class="line"></span><br><span class="line"><span class="attribute">OAuth2</span>:</span><br><span class="line"><span class="attribute">type</span>: oauth2</span><br><span class="line"><span class="attribute">flows</span>:</span><br><span class="line"><span class="attribute">authorizationCode</span>:</span><br><span class="line"><span class="attribute">authorizationUrl</span>: <span class="attribute">https</span>:<span class="comment">//</span></span><br><span class="line"><span class="attribute">tokenUrl</span>: <span class="attribute">https</span>:<span class="comment">//</span></span><br><span class="line"><span class="attribute">scopes</span>:</span><br><span class="line"><span class="attribute">read</span>: Grants read access</span><br><span class="line"><span class="attribute">write</span>: Grants write access</span><br><span class="line"><span class="attribute">admin</span>: Grants access to admin operations</span><br><span class="line"></span><br><span class="line"><span class="attribute">OpenID</span>:</span><br><span class="line"><span class="attribute">type</span>: openIdConnect</span><br><span class="line"><span class="attribute">openIdConnectUrl</span>: <span class="attribute">http</span>:<span class="comment">//xxx</span></span><br></pre></td></tr></table></figure><h3 id="HTTP认证方案"><a href="#HTTP认证方案" class="headerlink" title="HTTP认证方案"></a>HTTP认证方案</h3><h3 id="标头中的API密钥"><a href="#标头中的API密钥" class="headerlink" title="标头中的API密钥"></a>标头中的API密钥</h3><p>用于API密钥和cookie认证，</p><h3 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h3><ol><li>授权码模式</li><li>简化模式</li><li>密码模式</li><li>客户端模式</li></ol><h3 id="OpenID-Connect实现"><a href="#OpenID-Connect实现" class="headerlink" title="OpenID Connect实现"></a>OpenID Connect实现</h3><h2 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h2><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><ol><li>用户首次访问提供用户名 + 密码到认证服务器</li><li>服务器验证用户提交信息的合法性，如果验证成功，生成一个token到客户端</li><li>客户端每次访问携带token</li></ol><p>token包含信息：</p><ol><li><p>header：</p><p> typ声明类型</p><p> alg生成签名的算法</p><pre><code>{ &quot;alg&quot; :&quot;AES256&quot;, &quot;typ&quot; :&quot;JWT&quot;}</code></pre></li><li><p>claims</p><p> sub</p><p> name</p><p> admin</p><pre><code>{ &quot;sub&quot;:&quot;1234567890&quot;, &quot;name&quot;:&quot;John Doe&quot;, &quot;admin&quot;:true}</code></pre></li><li><p>signature</p></li></ol><h3 id="JWT和OAuth2-0、Shiro"><a href="#JWT和OAuth2-0、Shiro" class="headerlink" title="JWT和OAuth2.0、Shiro"></a>JWT和OAuth2.0、Shiro</h3><p>Shiro: </p>]]></content>
      
      
      
        <tags>
            
            <tag> Auth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka和Zookeeper的对比</title>
      <link href="/2018/12/04/distribute-eureka-zk/"/>
      <url>/2018/12/04/distribute-eureka-zk/</url>
      
        <content type="html"><![CDATA[<p>服务注册中心的组件主要有：Eureka、Zookeeper、Consule、Etcd。都是围绕CAP理论，P是必须保证的，而C和A不能同时满足。zk保证的是CP，Eureka保证的是AP。它们的原理都是维护一张注册列表，客户端在服务列表中查询服务端信息，进行通信</p><a id="more"></a><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h3 id="zk保证CP的原理"><a href="#zk保证CP的原理" class="headerlink" title="zk保证CP的原理"></a>zk保证CP的原理</h3><p>zk集群需要维护一个leader，当master选举过程中，整个集群不可用，无法注册服务，无法保证A可用性</p><h3 id="Eureka保证AP的原理"><a href="#Eureka保证AP的原理" class="headerlink" title="Eureka保证AP的原理"></a>Eureka保证AP的原理</h3><p>Eureka<br>集群没有leader的概念，所有节点都是平等的，当某一个节点不可用时，会自动切换到其它可用的节点上。这样无法保证C一致性</p><p>Eureka还有一种自我保护机制，当在15min之内超过85%的节点没有正常的心跳，eureka会认为出现网络故障：</p><blockquote><p>长时间没有心跳时，eureka不会从注册列表移除服务</p><p>eureka节点仍然能接受新服务的注册、查询，不会被同步到其它节点</p><p>网络恢复时，同步注册信息到其它节点</p></blockquote><p><strong>当所有Eureka节点/ZK节点挂掉后，RPC是否可以进行正常通信？</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-jvm-cms-g1</title>
      <link href="/2018/12/04/java-jvm-cms-g1/"/>
      <url>/2018/12/04/java-jvm-cms-g1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac中配置ZSH</title>
      <link href="/2018/11/28/mac-zsh/"/>
      <url>/2018/11/28/mac-zsh/</url>
      
        <content type="html"><![CDATA[<p>明明在’～/.bash_profile’中配置了maven，执行mvn -v报错：zsh: command not found: mvn</p><p>需要在’~/.zshrc’中重新配置一下maven环境，重启shell即可</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins</title>
      <link href="/2018/11/27/jenkins-base/"/>
      <url>/2018/11/27/jenkins-base/</url>
      
        <content type="html"><![CDATA[<h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span>/jenkins<span class="selector-class">.repo</span> https:<span class="comment">//pkg.jenkins.io/redhat-stable/jenkins.repo</span></span><br><span class="line">sudo rpm --import https:<span class="comment">//pkg.jenkins.io/redhat-stable/jenkins.io.key</span></span><br><span class="line"></span><br><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/jenkins</span><br><span class="line"></span><br><span class="line">修改端口</span><br><span class="line">JENKINS_PORT=<span class="string">"8082"</span></span><br><span class="line"></span><br><span class="line">修改启动用户</span><br><span class="line">JENKINS_USER=<span class="string">"jenkins"</span></span><br></pre></td></tr></table></figure><p>上面rpm、yum安装后已经自动创建了jenkins用户，可以根据具体情况调整启动用户</p><h3 id="启动-开机启动"><a href="#启动-开机启动" class="headerlink" title="启动/开机启动"></a>启动/开机启动</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service jenkins <span class="literal">start</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7系统安装</title>
      <link href="/2018/11/27/linux-centos7-base/"/>
      <url>/2018/11/27/linux-centos7-base/</url>
      
        <content type="html"><![CDATA[<p>自从几年前折腾过win7+ubuntu14双系统后(大致还记得什么EasyBCD修改引导什么的)，一般都是在VMware搭建虚拟机，这次主机从win10切换到Centos7，中间踩到的坑记录一下。</p><a id="more"></a><h2 id="重启引导问题"><a href="#重启引导问题" class="headerlink" title="重启引导问题"></a>重启引导问题</h2><p>因为原来安装了win10，导致U盘重装无法进入引导界面，总是很快进入win10，后来看到说明使用’F12’进入Menu启动配置页面，有个BOOT、UFEI，在BOOT中选择USB那个，进入安装界面</p><h2 id="分区问题"><a href="#分区问题" class="headerlink" title="分区问题"></a>分区问题</h2><p>win10分盘都是按照NTFS格式分的，导致手动分区时’点这里自动创建分区’报错，’磁盘占满’，可以选择右侧的’更新设置’对NTFS格式的分区改为ext4格式。</p><p>不同分区配置方案：</p><p>一般新手建议使用默认分区，</p><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><ol><li>‘/‘：<strong>BISO BOOT格式</strong>建议大小在5GB以上。</li><li>‘swap’：即交换分区，建议大小是物理内存的1~2倍。</li></ol><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><ol><li>‘/boot’：<strong>BISO BOOT格式</strong>用来存放与Linux系统启动有关的程序，比如启动引导装载程序等，建议大小为100MB。</li><li>‘/‘：<strong>ext4</strong>Linux系统的根目录，所有的目录都挂在这个目录下面，建议大小为5GB以上。</li><li>‘swap’：<strong>swap</strong>实现虚拟内存，建议大小是物理内存的1~2倍。</li><li>‘/home’：<strong>ext4</strong>存放普通用户的数据，是普通用户的宿主目录，建议大小为剩下的空间。</li></ol><h3 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h3><ol><li>/boot：<strong>BISO BOOT格式</strong>用来存放与Linux系统启动有关的程序，比如启动引导装载程序等，建议大小为100MB。</li><li>/usr ：用来存放Linux系统中的应用程序，其相关数据较多，建议大于3GB以上。</li><li>/var ：用来存放Linux系统中经常变化的数据以及日志文件，建议大于1GB以上。</li><li>swap：实现虚拟内存，建议大小是物理内存的1~2倍。</li><li>/ ：Linux系统的根目录，所有的目录都挂在这个目录下面，建议大小为5GB以上。</li><li>/tmp：将临时盘在独立的分区，可避免在文件系统被塞满时影响到系统的稳定性。建议大小为500MB以上。</li><li>/home：存放普通用户的数据，是普通用户的宿主目录，建议大小为剩下的空间。</li></ol><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>IP、网关</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac使用U盘制作启动盘</title>
      <link href="/2018/11/27/mac-u-boot/"/>
      <url>/2018/11/27/mac-u-boot/</url>
      
        <content type="html"><![CDATA[<p>以前都是使用Windows系统制作启动盘UltraISO、老毛桃、大白菜，今天第一次使用Mac制作Centos7系统盘，一时有点懵逼，记录一下。</p><a id="more"></a><h2 id="制作步骤"><a href="#制作步骤" class="headerlink" title="制作步骤"></a>制作步骤</h2><h3 id="查看挂载点"><a href="#查看挂载点" class="headerlink" title="查看挂载点"></a>查看挂载点</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ diskutil list</span><br><span class="line">/dev/disk0 (internal):</span><br><span class="line">   #:                      <span class="built_in"> TYPE </span>NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      GUID_partition_scheme                         500.3 GB   disk0</span><br><span class="line">   1:                        EFI EFI                     314.6 MB   disk0s1</span><br><span class="line">   2:                 Apple_APFS Container disk1         500.0 GB   disk0s2</span><br><span class="line"></span><br><span class="line">/dev/disk1 (synthesized):</span><br><span class="line">   #:                      <span class="built_in"> TYPE </span>NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      APFS Container Scheme -                      +500.0 GB   disk1</span><br><span class="line">                                 Physical Store disk0s2</span><br><span class="line">   1:                APFS Volume Macintosh HD            82.9 GB    disk1s1</span><br><span class="line">   2:                APFS Volume Preboot                 22.3 MB    disk1s2</span><br><span class="line">   3:                APFS Volume Recovery                515.0 MB   disk1s3</span><br><span class="line">   4:                APFS Volume VM                      5.4 GB     disk1s4</span><br><span class="line"></span><br><span class="line">/dev/disk2 (disk image):</span><br><span class="line">   #:                      <span class="built_in"> TYPE </span>NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      GUID_partition_scheme                        +91.9 MB    disk2</span><br><span class="line">   1:                  Apple_HFS MailMaster              91.8 MB    disk2s1</span><br><span class="line"></span><br><span class="line">/dev/disk3 (disk image):</span><br><span class="line">   #:                      <span class="built_in"> TYPE </span>NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:                            MySQL Workbench com<span class="built_in">..</span>. +314.6 MB   disk3</span><br><span class="line"></span><br><span class="line">/dev/disk4 (external, physical):</span><br><span class="line">   #:                      <span class="built_in"> TYPE </span>NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:     FDisk_partition_scheme                        <span class="number">*15</span>.6 GB    disk4</span><br><span class="line">   1:             Windows_FAT_32 18810998015             15.6 GB    disk4s4</span><br></pre></td></tr></table></figure><p>看到internal、external即可知道这是内置磁盘、U盘</p><h3 id="卸载挂载点"><a href="#卸载挂载点" class="headerlink" title="卸载挂载点"></a>卸载挂载点</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ diskutil unmountDisk /dev/disk4                                                       </span><br><span class="line">Unmount <span class="keyword">of</span> all volumes <span class="keyword">on</span> disk4 was successful</span><br></pre></td></tr></table></figure><h3 id="使用dd命令写入"><a href="#使用dd命令写入" class="headerlink" title="使用dd命令写入"></a>使用dd命令写入</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo dd if=/Users/wanchaowang/Downloads/CentOS<span class="number">-7</span>-x86_64-Minimal<span class="number">-1804.</span>iso of=/dev/disk4 bs=<span class="number">1</span>m</span><br><span class="line"><span class="number">906</span>+<span class="number">0</span> records in</span><br><span class="line"><span class="number">906</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="number">950009856</span> bytes transferred in <span class="number">666.618035</span> secs (<span class="number">1425119</span> bytes/sec)</span><br></pre></td></tr></table></figure><p>显示in、out即为dd完成</p><p><strong>注意：中间耗时较长，而且过程中没有任何提示信息，第一次我以为没有拷贝，中断，导致U盘不可读</strong></p><p>bs=1M和bs=1m会有坑，如果出错‘dd: invalid number: ‘1m’’可以尝试不同的</p><p>U盘不可读时MacOS会有明确的提示，抹除重新dd即可</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-cloud-base</title>
      <link href="/2018/11/26/spring-cloud-base/"/>
      <url>/2018/11/26/spring-cloud-base/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring-security-shiro</title>
      <link href="/2018/11/26/spring-security-shiro/"/>
      <url>/2018/11/26/spring-security-shiro/</url>
      
        <content type="html"><![CDATA[<h3 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h3><p>在客户端和服务端中间，设置了一个授权层，客户端不能登陆服务端，只能登录中间授权层。</p><p>第一阶段使用account + secret登录中间层，获得token</p><p>第二阶段开始使用token进行权限验证</p><h3 id="OpenID"><a href="#OpenID" class="headerlink" title="OpenID"></a>OpenID</h3><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><h2 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h2><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OSI网络协议</title>
      <link href="/2018/11/25/net-base/"/>
      <url>/2018/11/25/net-base/</url>
      
        <content type="html"><![CDATA[<p>计算机网络模型</p><a id="more"></a><h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>HTTP、FTP、SMTP</p><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>处理两个系统间交换信息的语法与语义。<strong>实际中不存在</strong></p><h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p>数据表示转化</p><p>加密/解密</p><p>压缩/解压缩</p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p><strong>实际中不存在</strong></p><h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><p>对话控制</p><p>同步</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>数据段，负责源-目的(端到端)(进程间)完整报文传输</p><h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h3><p>分段与重组</p><p>SAP寻址</p><p>连接控制：逻辑连接</p><p>流量控制：</p><p>差错控制：</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>数据报，复制源主机到目的主机数据分组交付</p><h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h3><p>逻辑寻址</p><p>路由</p><p>分组转发</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据帧，负责节点-节点之间的数据传输</p><h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h3><p>物理寻址</p><p>流量控制</p><p>差错控制</p><p>访问(接入)控制</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>解决单一比特传输的问题</p><h1 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h1><p>应用层</p><p>运输层</p><p>网际层(网络层)</p><p>网络接口层(链路层)</p><h1 id="综合OSI和TCP-IP的五层"><a href="#综合OSI和TCP-IP的五层" class="headerlink" title="综合OSI和TCP/IP的五层"></a>综合OSI和TCP/IP的五层</h1><p>应用层：</p><p>传输层： TCP、UDP</p><p>网络层： IP</p><p>数据链路层： 以太网(Ethernet)、802.11(WiFi)、PPP</p><p>物理层：</p><p>主机：五层</p><p>交换机：链路层、物理层</p><p>路由器：网络层、链路层、物理层</p>]]></content>
      
      
      
        <tags>
            
            <tag> NetWork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown Pad实现数学公式的编写</title>
      <link href="/2018/11/24/markdown-latex/"/>
      <url>/2018/11/24/markdown-latex/</url>
      
        <content type="html"><![CDATA[<p>最近写博客需要用到LaTex描述数学公式，以前配置过，但是具体忘了，结果这次又浪费了一段时间，特别记录一下</p><ol><li>Markdown Pad2右侧栏不能预览数学公式(也许是我没找到合适的解决方法)</li><li>可以通过“F6”实现浏览器页面预览，最好不要使用IE，IE浏览器需要打开激活ActiveX，否则不能正常显示公式</li><li>LaTex有一套自己的语法，使用时要注意</li></ol><a id="more"></a><h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><p>1、 在Tools–&gt;Options–&gt;Advanced–&gt;HTML Head Editor插入脚本</p><h3 id="使用CDN脚本"><a href="#使用CDN脚本" class="headerlink" title="使用CDN脚本"></a>使用CDN脚本</h3><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt; &lt;/script&gt;</code></pre><h3 id="使用本地脚本"><a href="#使用本地脚本" class="headerlink" title="使用本地脚本"></a>使用本地脚本</h3><p><img src="http://impwang.oss-cn-beijing.aliyuncs.com/latex.PNG" alt="test"></p><p>2、根据LaTex的语法编写</p><p><a href="https://www.zybuluo.com/codeep/note/163962#2%E5%A6%82%E4%BD%95%E8%BE%93%E5%85%A5%E4%B8%8A%E4%B8%8B%E6%A0%87" target="_blank" rel="noopener">在线手册</a></p><p>简单编写测试：</p><p>When \( a \ne 0 \), there are two solutions to \(ax^2 + bx + c = 0\) and they are:<br>$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a} $$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="/2018/11/21/net-http/"/>
      <url>/2018/11/21/net-http/</url>
      
        <content type="html"><![CDATA[<p>HTTP协议一直在演进，最近出了HTTP3，基于UDP协议的QUIC协议</p><a id="more"></a><h2 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h2><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><h3 id="http1-0和http1-1的比较"><a href="#http1-0和http1-1的比较" class="headerlink" title="http1.0和http1.1的比较"></a>http1.0和http1.1的比较</h3><ol><li>http1.0需要keep-alive参数告知服务器建立一个长连接，http1.1默认支持keep-alive</li><li>http1.0没有host域的，http1.1才支持这个参数</li><li>http1.1支持只发送header信息</li></ol><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><pre><code>http2.0基于SPDY协议http2.0采用二进制格式，而非文本格式http2.0是完全多路复用的，而非有序阻塞的(只需一个连接即可实现并行); http1.x线端阻塞问题，http1.1流水线技术http2.0使用报头压缩，降低了开销http2.0可以将响应主动推送到客户端缓存</code></pre><p>SPDY协议：Google开发的下一代网络协议，并不是用来替代HTTP协议，而是对HTTP协议的增强。目前支持的有Netty和Nginx</p><ol><li>多路复用请求：在单个SPDY连接能并发的发起请求，并不限制请求数；</li><li>请求优先级：客户端能请求某个资源被优先传输。这避免了高优先级请求被非关键资源堵塞网络通道的问题；</li><li>头部压缩：客户端现在发送了大量冗余的HTTP头部信息。因为一个页面可能有50到100个子请求，这些数据是巨大的；</li><li>服务端推送流：服务端能向客户端推送数据不需要客户端发起一个请求</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>需要客户端和服务器同时支持SPDY</p><p>协议解析复杂</p><h3 id="SPDY与http1-1的比较"><a href="#SPDY与http1-1的比较" class="headerlink" title="SPDY与http1.1的比较"></a>SPDY与http1.1的比较</h3><ol><li>一个SPDY连接允许建立多条stram，并发多个HTTP请求；http1.1一个连接只能处理一个请求</li><li>spdy请求可以具有优先级，客户端可以要求服务器优先发送重要资源；http1.1一个非关键请求可以阻塞服务器对后面请求的处理</li><li>spdy允许压缩头部，减少HTTP头部大小，减少带宽占用；http1.1头部冗余，User-Agent、Host重复发送</li><li>spdy服务器可以主动给客户端推送数据；http1.1只要客户端可以发送请求</li></ol><h2 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h2>]]></content>
      
      
      <categories>
          
          <category> NetWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NetWork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark单机环境搭建</title>
      <link href="/2018/10/25/spark-base/"/>
      <url>/2018/10/25/spark-base/</url>
      
        <content type="html"><![CDATA[<p>启动Spark</p><pre><code>cd  $SPARK_HOMEbin/spark-shell val textFile = spark.read.textFile(&quot;README.md&quot;)textFile.count()textFile.first()</code></pre><p>报错：</p><pre><code>Caused by: org.apache.derby.iapi.error.StandardException: Failed to create database &apos;metastore_db&apos;, see the next exception for details.  at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)  at org.apache.derby.impl.jdbc.SQLExceptionFactory.wrapArgsForTransportAcrossDRDA(Unknown Source)  ... 154 moreCaused by: org.apache.derby.iapi.error.StandardException: Directory /usr/local/spark/metastore_db cannot be created.  at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)  at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)  at org.apache.derby.impl.services.monitor.StorageFactoryService$10.run(Unknown Source)  at java.security.AccessController.doPrivileged(Native Method)  at org.apache.derby.impl.services.monitor.StorageFactoryService.createServiceRoot(Unknown Source)  at org.apache.derby.impl.services.monitor.BaseMonitor.bootService(Unknown Source)  at org.apache.derby.impl.services.monitor.BaseMonitor.createPersistentService(Unknown Source)  at org.apache.derby.impl.services.monitor.FileMonitor.createPersistentService(Unknown Source)  at org.apache.derby.iapi.services.monitor.Monitor.createPersistentService(Unknown Source)  at org.apache.derby.impl.jdbc.EmbedConnection$5.run(Unknown Source)  at java.security.AccessController.doPrivileged(Native Method)  at org.apache.derby.impl.jdbc.EmbedConnection.createPersistentService(Unknown Source)  ... 151 more</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink框架基础</title>
      <link href="/2018/10/25/flink-base/"/>
      <url>/2018/10/25/flink-base/</url>
      
        <content type="html"><![CDATA[<p>根据官网示例，跑一下</p><h3 id="Centos7安装flink"><a href="#Centos7安装flink" class="headerlink" title="Centos7安装flink"></a>Centos7安装flink</h3><ol><li><p>启动flink</p><pre><code>cd $FLINK_HOME/libexecbin/start-cluster.sh</code></pre><p> flink自带WebUI，可以通过浏览器访问：localhost:8081</p></li></ol><a id="more"></a><ol start="2"><li>IDEA根据flink-quickstart-scala框架创建demo项目</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.wang</span><br><span class="line"></span><br><span class="line">import org.apache.flink.api.java.utils.ParameterTool</span><br><span class="line">import org.apache.flink.streaming.api.scala._</span><br><span class="line">import org.apache.flink.streaming.api.windowing.time.Time</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Skeleton <span class="keyword">for</span> a Flink Streaming Job.</span><br><span class="line"> *</span><br><span class="line"> * For a tutorial how to write a Flink streaming application, check the</span><br><span class="line"> * tutorials and examples on the &lt;a href=<span class="string">"http://flink.apache.org/docs/stable/"</span>&gt;Flink Website&lt;/a&gt;.</span><br><span class="line"> *</span><br><span class="line"> * To package your application into a JAR file <span class="keyword">for</span> execution, run</span><br><span class="line"> * <span class="string">'mvn clean package'</span> on the <span class="built_in">command</span> line.</span><br><span class="line"> *</span><br><span class="line"> * If you change the name of the main class (with the public static void main(String[] args))</span><br><span class="line"> * method, change the respective entry <span class="keyword">in</span> the POM.xml file (simply search <span class="keyword">for</span> <span class="string">'mainClass'</span>).</span><br><span class="line"> */</span><br><span class="line">object StreamingJob &#123;</span><br><span class="line"></span><br><span class="line">  // raw原生</span><br><span class="line">//  def main(args: Array[String]) &#123;</span><br><span class="line">//    // <span class="built_in">set</span> up the streaming execution environment</span><br><span class="line">//    val env = StreamExecutionEnvironment.getExecutionEnvironment</span><br><span class="line">//</span><br><span class="line">//    /*</span><br><span class="line">//     * Here, you can start creating your execution plan <span class="keyword">for</span> Flink.</span><br><span class="line">//     *</span><br><span class="line">//     * Start with getting some data from the environment, like</span><br><span class="line">//     *  env.readTextFile(textPath);</span><br><span class="line">//     *</span><br><span class="line">//     * <span class="keyword">then</span>, transform the resulting DataStream[String] using operations</span><br><span class="line">//     * like</span><br><span class="line">//     *   .filter()</span><br><span class="line">//     *   .flatMap()</span><br><span class="line">//     *   .join()</span><br><span class="line">//     *   .group()</span><br><span class="line">//     *</span><br><span class="line">//     * and many more.</span><br><span class="line">//     * Have a look at the programming guide:</span><br><span class="line">//     *</span><br><span class="line">//     * http://flink.apache.org/docs/latest/apis/streaming/index.html</span><br><span class="line">//     *</span><br><span class="line">//     */</span><br><span class="line">//</span><br><span class="line">//    // execute program</span><br><span class="line">//    env.execute(<span class="string">"Flink Streaming Scala API Skeleton"</span>)</span><br><span class="line">//  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]) : Unit = &#123;</span><br><span class="line"></span><br><span class="line">    // the port to connect to</span><br><span class="line">    val port: Int = try &#123;</span><br><span class="line">      ParameterTool.fromArgs(args).getInt(<span class="string">"port"</span>)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      <span class="keyword">case</span> e: Exception =&gt; &#123;</span><br><span class="line">        System.err.println(<span class="string">"No port specified. Please run 'SocketWindowWordCount --port &lt;port&gt;'"</span>)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // get the execution environment</span><br><span class="line">    val env: StreamExecutionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    // get input data by connecting to the socket</span><br><span class="line">    val text = env.socketTextStream(<span class="string">"localhost"</span>, port, <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    // parse the data, group it, window it, and aggregate the counts</span><br><span class="line">    val windowCounts = text</span><br><span class="line">      .flatMap &#123; w =&gt; w.split(<span class="string">"\\s"</span>) &#125;</span><br><span class="line">      .map &#123; w =&gt; WordWithCount(w, 1) &#125;</span><br><span class="line">      .keyBy(<span class="string">"word"</span>)</span><br><span class="line">      .timeWindow(Time.seconds(5), Time.seconds(1))</span><br><span class="line">      .sum(<span class="string">"count"</span>)</span><br><span class="line"></span><br><span class="line">    // <span class="built_in">print</span> the results with a single thread, rather than <span class="keyword">in</span> parallel</span><br><span class="line">    windowCounts.print().setParallelism(1)</span><br><span class="line"></span><br><span class="line">    env.execute(<span class="string">"Socket Window WordCount"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Data <span class="built_in">type</span> <span class="keyword">for</span> words with count</span><br><span class="line">  <span class="keyword">case</span> class WordWithCount(word: String, count: Long)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>mvn编译项目</p><p> mvn package/install编译过程报错</p><pre><code>error: could not find implicit value for evidence parameter of type org.apache.flink.api.common.typeinfo.TypeInformation[String][ERROR]       .flatMap { w =&gt; w.split(&quot;\\s&quot;) }</code></pre><p> 说这是因为程序需要一个隐形参数导致的，引用包改为’    import org.apache.flink.streaming.api.scala._<br>‘重新编译，解决问题</p></li><li><p>终端启动一个窗口</p><pre><code>nc -l 9000</code></pre></li><li><p>执行程序</p><pre><code>flink run SocketWindowWordCount.jar --port 9000</code></pre><p> 运行报错：</p><pre><code><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">org.apache.flink.client.<span class="built_in">program</span>.ProgramInvocationException: The <span class="built_in">program</span>'s entry point class 'com.wang.StreamingJob' was <span class="keyword">not</span> found <span class="keyword">in</span> the jar file.</span><br><span class="line"><span class="built_in">at</span> org.apache.flink.client.<span class="built_in">program</span>.PackagedProgram.loadMainClass(PackagedProgram.java:<span class="number">617</span>)</span><br><span class="line"><span class="built_in">at</span> org.apache.flink.client.<span class="built_in">program</span>.PackagedProgram.&lt;init&gt;(PackagedProgram.java:<span class="number">199</span>)</span><br><span class="line"><span class="built_in">at</span> org.apache.flink.client.<span class="built_in">program</span>.PackagedProgram.&lt;init&gt;(PackagedProgram.java:<span class="number">128</span>)</span><br><span class="line"><span class="built_in">at</span> org.apache.flink.client.cli.CliFrontend.buildProgram(CliFrontend.java:<span class="number">856</span>)</span><br><span class="line"><span class="built_in">at</span> org.apache.flink.client.cli.CliFrontend.run(CliFrontend.java:<span class="number">206</span>)</span><br><span class="line"><span class="built_in">at</span> org.apache.flink.client.cli.CliFrontend.parseParameters(CliFrontend.java:<span class="number">1044</span>)</span><br><span class="line"><span class="built_in">at</span> org.apache.flink.client.cli.CliFrontend.<span class="built_in">lambda</span>$main$<span class="number">11</span>(CliFrontend.java:<span class="number">1120</span>)</span><br><span class="line"><span class="built_in">at</span> java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line"><span class="built_in">at</span> javax.security.auth.Subject.doAs(Subject.java:<span class="number">422</span>)</span><br><span class="line"><span class="built_in">at</span> org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:<span class="number">1754</span>)</span><br><span class="line"><span class="built_in">at</span> org.apache.flink.runtime.security.HadoopSecurityContext.runSecured(HadoopSecurityContext.java:<span class="number">41</span>)</span><br><span class="line"><span class="built_in">at</span> org.apache.flink.client.cli.CliFrontend.main(CliFrontend.java:<span class="number">1120</span>)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.wang.StreamingJob</span><br><span class="line"><span class="built_in">at</span> java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">381</span>)</span><br><span class="line"><span class="built_in">at</span> java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line"><span class="built_in">at</span> java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line"><span class="built_in">at</span> java.lang.Class.forName0(Native Method)</span><br><span class="line"><span class="built_in">at</span> java.lang.Class.forName(Class.java:<span class="number">348</span>)</span><br><span class="line"><span class="built_in">at</span> org.apache.flink.client.<span class="built_in">program</span>.PackagedProgram.loadMainClass(PackagedProgram.java:<span class="number">614</span>)</span><br><span class="line">... <span class="number">11</span> more</span><br></pre></td></tr></table></figure></code></pre><p> 在执行中默认StreamingJob类为主类，如果自定义类，需要指定主类名称。</p></li><li><p>查看日志</p><pre><code>cd $FLINK_HOME/libexec/logtail -f flink-*-taskexecutor-*.out</code></pre></li><li><p>停止flink</p><pre><code>cd $FLINK_HOME/libexecbin/stop-cluster.sh</code></pre></li></ol><h3 id="Mac安装"><a href="#Mac安装" class="headerlink" title="Mac安装"></a>Mac安装</h3><p>mac安装flink</p><pre><code>brew install apache-flinkbrew info apache-flinkcd $FLINK_HOME./libexec/bin/start-cluster.sh</code></pre><p>WebUI访问：</p><pre><code>./libexec/bin/stop-cluster.sh</code></pre>]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac系统搭建多版本的jdk</title>
      <link href="/2018/10/23/mac-multi-jdk/"/>
      <url>/2018/10/23/mac-multi-jdk/</url>
      
        <content type="html"><![CDATA[<p>dmg按照步骤安装jdk，我目前感兴趣的主要是jdk8、jdk11，所以这里只有两个版本</p><a id="more"></a><p>查看jdk版本、安装目录</p><pre><code>java -versionwhich javall /usr/bin/javacd /System/Library/Frameworks/JavaVM.framework/Versions</code></pre><p>查看可用的jdk版本</p><pre><code>lsll</code></pre><p>查看已经安装的jdk</p><pre><code>/usr/libexec/java_home -V</code></pre><p>配置环境变量</p><pre><code>vi ~/.bash_profile</code></pre><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置自带的 jdk1.6</span></span><br><span class="line"><span class="comment">#export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6`</span></span><br><span class="line"><span class="comment"># 设置 jdk1.7</span></span><br><span class="line"><span class="comment">#export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7`</span></span><br><span class="line"><span class="comment"># 设置 jdk1.8</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_8_HOME</span>=`/usr/libexec/java_home -v 1.8`</span><br><span class="line"><span class="comment"># 设置 jdk11</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_11_HOME</span>=`/usr/libexec/java_home -v 11`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认 jdk 使用1.6版本</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=<span class="variable">$JAVA_8_HOME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alias 命令动态切换 jdk 版本</span></span><br><span class="line"><span class="comment"># alias jdk6="export JAVA_HOME=$JAVA_6_HOME"</span></span><br><span class="line"><span class="comment"># alias jdk7="export JAVA_HOME=$JAVA_7_HOME"</span></span><br><span class="line">alias <span class="attribute">jdk8</span>=<span class="string">"export JAVA_HOME=<span class="variable">$JAVA_8_HOME</span>"</span></span><br><span class="line">alias <span class="attribute">jdk11</span>=<span class="string">"export JAVA_HOME=<span class="variable">$JAVA_11_HOME</span>"</span></span><br></pre></td></tr></table></figure><p>命令切换jdk版本</p><pre><code>jdk8java -version</code></pre><p>遇到的问题：</p><ol><li>在Versions目录查看jdk版本时没有列出所有的可用版本</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cat实现监控埋点</title>
      <link href="/2018/10/19/cat-base/"/>
      <url>/2018/10/19/cat-base/</url>
      
        <content type="html"><![CDATA[<p>项目中打算使用Cat做一些监控，在搭建的过程中，踩了一些坑。浪费了很多时间，现在回顾一下为什么浪费了那么多时间。</p><p>首先我不知道为什么官方文档要那么写，写的乱七八糟，初学者很不利于理解。而且把单机和集群模式放在一起讲，里面很多的东西也不是很懂，就导致浪费很多时间。</p><a id="more"></a><p><a href="https://github.com/dianping/cat/" target="_blank" rel="noopener">Cat源码</a></p><p><a href="https://github.com/dianping/cat/blob/master/cat-doc/posts/ch4-server/README.md" target="_blank" rel="noopener">文档</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>其实所有的监控无非就是分为服务端、客户端。服务端作为监控数据的消费者，暴露一些端口给客户端，客户端发送日志数据到服务端。</p><h2 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h2><h3 id="服务端Cat部署"><a href="#服务端Cat部署" class="headerlink" title="服务端Cat部署"></a>服务端Cat部署</h3><ol><li>创建数据库，存储监控数据就需要数据库cat，script/CatApplication.sql创建数据表</li><li><p>配置数据源，cat的数据源统一从’/data/appdatas/cat/‘中读取，所以要创建文件’datasources.xml’，授权</p><pre><code>vi datasources.xmlchown -R 777 /data/</code></pre> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">data-sources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data-source</span> <span class="attr">id</span>=<span class="string">"cat"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maximum-pool-size</span>&gt;</span>3<span class="tag">&lt;/<span class="name">maximum-pool-size</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">connection-timeout</span>&gt;</span>1s<span class="tag">&lt;/<span class="name">connection-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">idle-timeout</span>&gt;</span>10m<span class="tag">&lt;/<span class="name">idle-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">statement-cache-size</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">statement-cache-size</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">driver</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">driver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>&lt;![CDATA[jdbc:mysql://127.0.0.1:3306/cat]]&gt;<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  <span class="comment">&lt;!-- 请替换为真实数据库URL及Port  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span>root<span class="tag">&lt;/<span class="name">user</span>&gt;</span>  <span class="comment">&lt;!-- 请替换为真实数据库用户名  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>root<span class="tag">&lt;/<span class="name">password</span>&gt;</span>  <span class="comment">&lt;!-- 请替换为真实数据库密码  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">connectionProperties</span>&gt;</span>&lt;![CDATA[useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;socketTimeout=120000]]&gt;<span class="tag">&lt;/<span class="name">connectionProperties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data-source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data-sources</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>注意：cat不支持mysql8.0，我在这里踩了大坑</strong></p></li><li><p>配置服务器信息，创建’server.xml’，授权</p><pre><code>vi server.xmlchown -R 777 /data/</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>配置tomcat，启动cat.war</p><p><a href="http://cat.meituan.com/nexus/service/local/repositories/releases/content/com/dianping/cat/cat-home/3.0.0/cat-home-3.0.0.war" target="_blank" rel="noopener">cat.war</a></p><p>cat需要在tomcat/webapps下启动。</p></li><li><p>查看日志，检查是否启动成功，可以用来排查异常</p><pre><code>cat /data/applogs/cat/cat_20181129.log</code></pre></li><li><p>浏览器WebUI，</p></li></ol><p>默认是 <a href="http://localhost:8080/cat" target="_blank" rel="noopener">http://localhost:8080/cat</a></p><p>账号密码 admin/admin    </p><h3 id="客户端cat-client整合SpringBoot"><a href="#客户端cat-client整合SpringBoot" class="headerlink" title="客户端cat-client整合SpringBoot"></a>客户端cat-client整合SpringBoot</h3><p>客户端一般用在web项目中，处理一些埋点信息。</p><ol><li><p>引用cat-client依赖包，这些包网上不好找，但是在服务端部署中，war包里包含最新的各种依赖包，可以从解压后的目录下复制</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dianping.cat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cat-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dianping.cat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cat-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置过滤器，</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">catFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        CatFilter filter = <span class="keyword">new</span> CatFilter();</span><br><span class="line">        registration.setFilter(filter);</span><br><span class="line">        registration.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        <span class="comment">//   registration.addInitParameter("exclusions","*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*");</span></span><br><span class="line">        registration.setName(<span class="string">"cat-filter"</span>);</span><br><span class="line">        registration.setOrder(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>配置项目名称，一定是在src/main/resources/META-INF中配置app.properties</p><pre><code>app.name=cat-test</code></pre></li></ol><p><strong>注意：这一步配置错误，会导致日志报错，或者即使cat可以监控到，request请求也无法正常监控</strong></p><ol start="4"><li><p>配置’client.xml’，授权，同样是在’/data/appdatas/cat/‘目录下。</p><pre><code>vi client.xmlchmod -R 777 /data/</code></pre> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">mode</span>=<span class="string">"client"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"config.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ip:cat指服务器的地址，如果在不同的主机，可以配置远程IP --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span> <span class="attr">ip</span>=<span class="string">"127.0.0.1"</span> <span class="attr">port</span>=<span class="string">"2280"</span> <span class="attr">http-port</span>=<span class="string">"8080"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- If under production environment, put actual server address as list. --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">            &lt;server ip="192.168.7.71" port="2280" /&gt; </span></span><br><span class="line"><span class="comment">            &lt;server ip="192.168.7.72" port="2280" /&gt; </span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>查看日志，检查是否成功</p><p> 客户端的日志同样生成在’/data/applogs/cat/‘下，</p><pre><code>cat cat_client_20181129.log</code></pre></li><li><p>postman模拟请求，即可在cat服务器上看到</p></li></ol><p>开始显示’全部’’常用’，点击’常用’即可看到app.name命名的监控</p><p><img src="http://impwang.oss-cn-beijing.aliyuncs.com/cat0.png" alt></p><p><img src="http://impwang.oss-cn-beijing.aliyuncs.com/cat.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Cat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk版本特性概览</title>
      <link href="/2018/10/17/jdk-overview/"/>
      <url>/2018/10/17/jdk-overview/</url>
      
        <content type="html"><![CDATA[<p>目前jdk已经升级到jdk12，大多还停留在jdk6/7/8上，jdk的快速迭代，让人非常兴奋，下面大致罗列一下jdk的新特性：</p><a id="more"></a><h2 id="jdk8"><a href="#jdk8" class="headerlink" title="jdk8"></a>jdk8</h2><p><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A" target="_blank" rel="noopener">OracleJDk8文档</a></p><h3 id="1-Lambda表达式和Functional接口"><a href="#1-Lambda表达式和Functional接口" class="headerlink" title="1. Lambda表达式和Functional接口"></a>1. Lambda表达式和Functional接口</h3><ol><li><p>接口的默认与静态方法</p></li><li><p>方法引用：</p><p> 方法引用</p><pre><code>对象::实例方法名类::静态方法名类::实例方法名</code></pre><p> 构造器引用</p><pre><code>类::new</code></pre><p> 数组引用</p><pre><code>Type[]::new</code></pre></li><li><p>重复注解</p></li><li><p>更好的类型推测机制</p></li><li><p>扩展注解： ElementType.TYPE_USE、 ElementType.TYPE_PARAMETER；可以为任何代码添加注解(接口、异常)</p></li></ol><h3 id="2-编译器新特性"><a href="#2-编译器新特性" class="headerlink" title="2. 编译器新特性"></a>2. 编译器新特性</h3><pre><code>通过&apos;-parameters&apos;参数可以将方法参数名添加到字节码</code></pre><h3 id="3-类库的新特性"><a href="#3-类库的新特性" class="headerlink" title="3. 类库的新特性"></a>3. 类库的新特性</h3><ol><li>Optional：解决空指针异常</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Consumer<span class="tag">&lt;<span class="name">T</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Supplier<span class="tag">&lt;<span class="name">T</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Function<span class="tag">&lt;<span class="name">T,</span> <span class="attr">R</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Predicate<span class="tag">&lt;<span class="name">T</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Comparator<span class="tag">&lt;<span class="name">T</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>Stream：</p><p> filter过滤</p><p> sort排序</p><p> map映射</p><p> match匹配</p><p> reduce规约</p></li></ol><ol start="3"><li><p>Date/Time API</p><p> Instant</p><p> Clock时钟</p><p> Timezones时区</p><p> LocalTime/LocalDate/LocalDateTime本地时间</p><p> <strong>注意：</strong>和java.text.SimpleDateFormat不同的是，DateTimeFormatter是不可变的，所以它是线程安全的。</p></li><li><p>Base64：Base64编码成为类库标准</p></li><li><p>并行：parallelSort()、</p></li><li><p>并发：java.util.concurrent包</p><blockquote><p>ConcurrentHashMap增加新方法支持聚集<br>ForkJoinPool增加新方法支持共有资源池<br>locks.StampedLock，用来替换locks.ReadWriteLock<br>atomic包下增加DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder</p></blockquote></li><li><p>集合</p><p> HashMap</p><p> 链表 + 红黑树</p><p> ConcurrentHashMap</p><p> 采用了CAS算法</p></li></ol><h3 id="4-Java工具"><a href="#4-Java工具" class="headerlink" title="4. Java工具"></a>4. Java工具</h3><ol><li><p>Norshorn引擎 jjs</p></li><li><p>类依赖分析器 jdeps：可以用来分析’.class’、目录、jar</p></li></ol><h3 id="5-JVM新特性"><a href="#5-JVM新特性" class="headerlink" title="5. JVM新特性"></a>5. JVM新特性</h3><ol><li><p>PermGen空间被Metaspace取代，</p><pre><code>-XX:PermSize      -XX:MetaSpaceSize-XX:MaxPermSize   -XX:MaxMetaspaceSize</code></pre></li></ol><h3 id="6-安全性"><a href="#6-安全性" class="headerlink" title="6. 安全性"></a>6. 安全性</h3><h3 id="7-IO-NIO改进"><a href="#7-IO-NIO改进" class="headerlink" title="7. IO/NIO改进"></a>7. IO/NIO改进</h3><ol><li>改进java.nio.charset.Charset的实现，精简了 jre/lib/charsets.jar 包；优化了 String(byte[],*) 构造方法和 String.getBytes() 方法的性能</li><li><p>新增API</p><pre><code>BufferedReader.line(): 返回文本行的流 Stream&lt;String&gt;File.lines(Path, Charset):返回文本行的流 Stream&lt;String&gt;File.list(Path): 遍历当前目录下的文件和目录File.walk(Path, int, FileVisitOption): 遍历某一个目录下的所有文件和指定深度的子目录File.find(Path, int, BiPredicate, FileVisitOption... ): 查找相应的文件</code></pre></li></ol><h2 id="jdk9"><a href="#jdk9" class="headerlink" title="jdk9"></a>jdk9</h2><p><a href="https://openjdk.java.net/projects/jdk9/" target="_blank" rel="noopener">OpenJDK9</a></p><p>“Java SE 9 has reached end of support. Users of Java SE 9 should switch to Java SE 10.”</p><p>官网明确表明，jdk9已经不被支持，用户可以切到jdk10</p><ol><li>模块化</li><li>Linking</li><li>JShell</li><li>JSON API</li><li>金钱和货币API</li><li>锁争用机制</li><li>代码分段缓存</li><li>编译工具 sjavac</li><li>接口私有方法</li><li>HTTP/2 用于替换’HttpURLConnection’</li><li>多版本兼容jar</li><li>Stream API 增加4个新的方法: dropWhile、takeWhile、ofNullable、iterate</li></ol><h2 id="jdk10"><a href="#jdk10" class="headerlink" title="jdk10"></a>jdk10</h2><p><a href="https://openjdk.java.net/projects/jdk/10/" target="_blank" rel="noopener">OpenJDK10</a></p><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk10-downloads-4416644.html" target="_blank" rel="noopener">OracleJDK下载</a></p><h3 id="主要新特性"><a href="#主要新特性" class="headerlink" title="主要新特性"></a>主要新特性</h3><blockquote><p>286: Local-Variable Type Inference</p><p>296: Consolidate the JDK Forest into a Single Repository</p><p>304: Garbage-Collector Interface</p><p>307: Parallel Full GC for G1</p><p>310: Application Class-Data Sharing</p><p>312: Thread-Local Handshakes</p><p>313: Remove the Native-Header Generation Tool (javah)</p><p>314: Additional Unicode Language-Tag Extensions</p><p>316: Heap Allocation on Alternative Memory Devices</p><p>317: Experimental Java-Based JIT Compiler</p><p>319: Root Certificates</p><p>322: Time-Based Release Versioning</p></blockquote><h3 id="1-类库API-73项"><a href="#1-类库API-73项" class="headerlink" title="1. 类库API 73项"></a>1. 类库API 73项</h3><h3 id="2-JVM规范改动"><a href="#2-JVM规范改动" class="headerlink" title="2. JVM规范改动"></a>2. JVM规范改动</h3><h3 id="3-Java语言规范"><a href="#3-Java语言规范" class="headerlink" title="3. Java语言规范"></a>3. Java语言规范</h3><h3 id="4-乱七八糟"><a href="#4-乱七八糟" class="headerlink" title="4. 乱七八糟"></a>4. 乱七八糟</h3><h2 id="jdk11"><a href="#jdk11" class="headerlink" title="jdk11"></a>jdk11</h2><p>继jdk8后的大版本LTS</p><p><a href="https://jdk.java.net/java-se-ri/11" target="_blank" rel="noopener">OpenJDK11下载</a></p><p><a href="https://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">OpenJDK11文档</a></p><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html" target="_blank" rel="noopener">OracleJDK下载</a></p><p><a href="https://docs.oracle.com/en/java/javase/11/" target="_blank" rel="noopener">Oracle文档</a></p><p>既然都到了JDK11，那就跟着英文文档来一波吧！</p><h3 id="主要新特性-1"><a href="#主要新特性-1" class="headerlink" title="主要新特性"></a>主要新特性</h3><blockquote><p>181: Nest-Based Access Control</p><p>309: Dynamic Class-File Constants</p><p>315: Improve Aarch64 Intrinsics</p><p>318: Epsilon: A No-Op Garbage Collector</p><p>320: Remove the Java EE and CORBA Modules</p><p>321: HTTP Client (Standard)</p><p>323: Local-Variable Syntax for Lambda Parameters</p><p>324: Key Agreement with Curve25519 and Curve448</p><p>327: Unicode 10</p><p>328: Flight Recorder</p><p>329: ChaCha20 and Poly1305 Cryptographic Algorithms</p><p>330: Launch Single-File Source-Code Programs</p><p>331: Low-Overhead Heap Profiling</p><p>332: Transport Layer Security (TLS) 1.3</p><p>333: ZGC: A Scalable Low-Latency Garbage Collector<br>(Experimental)</p><p>335: Deprecate the Nashorn JavaScript Engine</p><p>336: Deprecate the Pack200 Tools and API</p></blockquote><h2 id="jdk12"><a href="#jdk12" class="headerlink" title="jdk12"></a>jdk12</h2><p>jdk12发布了，jdk20还会远吗</p><p><a href="https://jdk.java.net/12/" target="_blank" rel="noopener">OpenJDK下载</a></p><p><a href="https://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">OpenJDk12文档</a></p><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html" target="_blank" rel="noopener">OracleJDK下载</a></p><p><a href="https://docs.oracle.com/en/java/javase/12/" target="_blank" rel="noopener">Oracle文档</a></p><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><blockquote><p>189:    Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</p><p>230:    Microbenchmark Suite</p><p>325:    Switch Expressions (Preview)</p><p>334:    JVM Constants API</p><p>340:    One AArch64 Port, Not Two</p><p>341:    Default CDS Archives</p><p>344:    Abortable Mixed Collections for G1</p><p>346:    Promptly Return Unused Committed Memory from G1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-manifest</title>
      <link href="/2018/10/14/java-manifest/"/>
      <url>/2018/10/14/java-manifest/</url>
      
        <content type="html"><![CDATA[<p>最近在javaassist项目中，要使用到MANIFEST.MF文件。MANIFEST.MF默认生成，如果需要自定义，在打包的时候需要明确指定：</p><p>看官方文档是最爽的，<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html" target="_blank" rel="noopener">jdk</a><br><a id="more"></a></p><pre><code>&lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;    &lt;configuration&gt;        &lt;archive&gt;            &lt;manifestFile&gt;src/main/resources/META-INF/MANIFEST.MF&lt;/manifestFile&gt;        &lt;/archive&gt;    &lt;/configuration&gt;&lt;/plugin&gt;</code></pre><p>MANIFEST.MF放在META-INF目录下，从META-INF目录详细分析一下，META-INF支持4种类型，会被自动加载、解析，通常用于配置应用、扩展、类加载器、服务：</p><ol><li>MENIFEST.MF</li><li>INDEX.LIST</li><li>xxx.SF</li><li>xxx.DSA</li><li>services/</li><li>maven/</li></ol><h2 id="MANIFEST-MF"><a href="#MANIFEST-MF" class="headerlink" title="MANIFEST.MF"></a>MANIFEST.MF</h2><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><ol><li>基本格式  属性名称：(空格)属性值;</li><li>每行最多72个字符，换行继续必须以空格开头 ;<br>文件最后一定是空行 ;</li><li><p>Class-Path 当前路径是jar包所在目录，如果要引用当前目录下一个子目录中的jar包，使用以下格式  </p><pre><code>子目录/jar包名称 子目录/jar名称,注意多个jar包之间用空格分隔, 在任何平台上路径分割符都是 /;</code></pre></li></ol><h3 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h3><h4 id="1、一般属性"><a href="#1、一般属性" class="headerlink" title="1、一般属性"></a>1、一般属性</h4><ol><li>Manifest-Version   用来定义manifest文件的版本，例如：Manifest-Version: 1.0</li><li>Archiver-Version: Plexus Archiver</li><li>Built-By: GGGGe</li><li>Created-By   声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Maven 3.5.0</li><li>Build-Jdk: 1.8.0_161</li><li>Signature-Version   定义jar文件的签名版本</li><li>Class-Path  应用程序或者类装载器使用该值来构建内部的类搜索路径</li></ol><h4 id="2、应用程序相关属性"><a href="#2、应用程序相关属性" class="headerlink" title="2、应用程序相关属性"></a>2、应用程序相关属性</h4><p>Main-Class   定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar xxx.jar来运行该jar文件。</p><h4 id="3、包扩展属性"><a href="#3、包扩展属性" class="headerlink" title="3、包扩展属性"></a>3、包扩展属性</h4><h4 id="4、小程序-Applet-属性"><a href="#4、小程序-Applet-属性" class="headerlink" title="4、小程序(Applet)属性"></a>4、小程序(Applet)属性</h4><h4 id="5、扩展标识属性"><a href="#5、扩展标识属性" class="headerlink" title="5、扩展标识属性"></a>5、扩展标识属性</h4><h4 id="6、签名属性"><a href="#6、签名属性" class="headerlink" title="6、签名属性"></a>6、签名属性</h4><h4 id="7、自定义属性"><a href="#7、自定义属性" class="headerlink" title="7、自定义属性"></a>7、自定义属性</h4>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java热部署技术</title>
      <link href="/2018/10/14/java-hotswap/"/>
      <url>/2018/10/14/java-hotswap/</url>
      
        <content type="html"><![CDATA[<h2 id="热部署的应用"><a href="#热部署的应用" class="headerlink" title="热部署的应用"></a>热部署的应用</h2><h3 id="SpringLoaded"><a href="#SpringLoaded" class="headerlink" title="SpringLoaded"></a>SpringLoaded</h3><ol><li><p>Maven添加依赖的方式启动</p> <plugin><br>     <groupid>org.springframework.boot</groupid><br>     <artifactid>spring-boot-maven-plugin</artifactid><br>     <dependencies><br>         <dependency><br>         <groupid>org.springframework</groupid><br>         <artifactid>springloaded</artifactid><br>         <version>1.2.6.RELEASE</version><br>         </dependency><br>     </dependencies><br> </plugin></li></ol><p>运行:</p><pre><code>mvn spring-boot:run 或者点击IDEA右侧栏相应命令</code></pre><ol start="2"><li><p>下载springloaded jar包，通过指定VM options参数运行</p><pre><code>-javaagent:C:\Users\tengj\.m2\repository\org\springframework\springloaded\1.2.6.RELEASE\springloaded-1.2.6.RELEASE.jar -noverify</code></pre></li></ol><p>注意：</p><p>在Spring Boot中，模板引擎页面默认开启缓存，修改页可能无法热加载，需要通过设置模板引擎的缓存。</p><pre><code>spring.freemarker.cache=falsespring.thymeleaf.cache=falsespring.velocity.cache=false</code></pre><p>热部署失效的情景：</p><blockquote><p>对一些注解的修改<br>application.properties的修改<br>log4j的配置文件的修改。</p></blockquote><p><em>为什么会失效，留下一个疑问？</em></p><h3 id="spring-boot-devtools"><a href="#spring-boot-devtools" class="headerlink" title="spring-boot-devtools"></a>spring-boot-devtools</h3><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>devtools的特性：</p><ol><li>默认关闭模板引擎缓存</li><li><p>灵活的自动重启机制</p><blockquote><p>排除静态资源文件<br>关闭自动重启<br>指定修改固定文件后触发重启<br>自定义自启动类加载器</p></blockquote></li></ol><p>详细可以查看<a href="https://howtodoinjava.com/spring-boot2/developer-tools-module-tutorial/" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql踩坑经历</title>
      <link href="/2018/10/12/mysql-bugs/"/>
      <url>/2018/10/12/mysql-bugs/</url>
      
        <content type="html"><![CDATA[<p>mysql使用中还是会有各种各样的坑，在实际使用中就遇到几个小问题，</p><a id="more"></a><ol><li><p>tinyint(1)的问题</p><p> tinyint(1)字段中数值大于1时，都返回true</p><p> 原因：</p><p> MySQL没有bool的概念，tinyint(1)隐式作为bool类型，0为false，非0为true。</p><p> 解决方案：</p><blockquote><p>在URL连接路径中添加 ‘Treat Tiny As Boolean=false’<br>在sql语句中 tinyint字段*1<br>使用tinyint(4)或者int类型</p></blockquote></li><li><p>时间大于2037年的问题</p><p> mysql时间不支持大于2037年的后时间，查询返回0.</p></li></ol><ol start="3"><li><p>北京时间’1970-01-01 08:00:00’的问题</p><p> 当字段为’1970-01-01 08:00:00’的时候报错<br> com.mysql.jdbc.MysqlDataTruncation: Data truncation: Incorrect datetime value: ‘1970-01-01 08:00:00’ for column</p><p> 原因：</p><p> mysql时间的支持范围是’1970-01-01 08:00:01’，    而传入的字段时区是GMT+8，转为’1970-01-01 08:00:00’，不在支持范围内，所以抛异常</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logback配置文件</title>
      <link href="/2018/10/12/logback-base/"/>
      <url>/2018/10/12/logback-base/</url>
      
        <content type="html"><![CDATA[<p>以前写过关于logging4j的配置，后来用logback，也没仔细分析过，在工作中遇到不同的用法，就来分析一下。</p><p>1、刚开始常用的是：其实这是最正规的写法</p><pre><code>logger.debug(&quot;massage:{}, code:{}&quot;, msg, code)</code></pre><p>遇到过：这种写法会先拼接字符串，再判断debug级别</p><pre><code>logger.debug(&quot;massage:{}&quot; + msg + &quot;code:{}&quot; + code)</code></pre><p>还遇到过，包括一些开源项目源码中也存在：这种写法多了一层判断</p><pre><code>if(logger.isDebugEnabled()) {     logger.debug(&quot;massage:{}&quot; + msg + &quot;code:{}&quot; + code)}</code></pre><p>2、开始使用</p><pre><code>private final Logger logger = LoggerFactory.getLogger(xxx.class);</code></pre><p>使用Lombok和注解@Slf4j可以省略原始代码</p><a id="more"></a><h2 id="Logback的体系结构"><a href="#Logback的体系结构" class="headerlink" title="Logback的体系结构"></a>Logback的体系结构</h2><h3 id="logback标签"><a href="#logback标签" class="headerlink" title="logback标签"></a>logback标签</h3><ol><li>root 所有logger的祖先</li><li>logger 所有logger之间根据name命名构成父子关系</li><li>appender 日志可以打印到console、file、mysql、logstash，additivity标签用于控制日志打印</li><li>ContextName </li><li>ContextListener</li><li><p>变量 可以指定默认值 ${fileName:-logback.log}</p><p> 在配置文件中可以使用多种变量：</p><blockquote><p>property </p><pre><code><figure class="highlight plain"><figcaption><span>scope</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; 运行时定义变量 ```&lt;define clas=&quot;&quot;&gt; &lt;/define&gt;</span><br></pre></td></tr></table></figure></code></pre></blockquote><blockquote><p>从JNDI获取变量 <figure class="highlight plain"><figcaption><span>env-entry-name</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7. include 一个配置文件中可以包含另一个配置文件 ```&lt;include file=&quot;&quot;/&gt; &lt;include resource=&quot;&quot;/&gt; &lt;include url=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure></p></blockquote></li><li><p>配置全局信息 <figure class="highlight plain"><figcaption><span>debug</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; debug指定打印正常启动日志信息</span><br><span class="line">&gt; </span><br><span class="line">&gt; scan、scanPeriod指定配置文件自动热加载</span><br><span class="line">&gt; </span><br><span class="line">&gt; packagingData指定打印异常堆栈时打印jar包信息</span><br><span class="line">单位milliseconds、seconds、minutes、</span><br><span class="line"></span><br><span class="line">### logback配置文件生命周期</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Logback的应用</span><br><span class="line"></span><br><span class="line">Logback整合Spring boot，有两种配置方式：</span><br><span class="line"></span><br><span class="line">### xml配置</span><br></pre></td></tr></table></figure></p></li></ol><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p><configuration><br><br>    <!-- 属性 --><br>    <property name="PROJECT_NAME" value="lb-client"><br>    <property name="LOG_HOME" value="${PROJECT_NAME}"><br>    <property name="CONSOLE_LOG_PATTERN" value="%highlight(%d{HH:mm:ss.SSS} %-5level %X{traceId} -%X{requestStr} %msg%n)"><br><br>    <!-- appender组件：指定日志打印级别、格式、编码、目录、策略 --><br>    <appender name="consoleLog" class="ch.qos.logback.core.ConsoleAppender"><br>        <layout class="ch.qos.logback.classic.PatternLayout"><br>            <pattern><br>                ${CONSOLE_LOG_PATTERN}<br>            </pattern><br>        </layout><br>    </appender><br><br>    <!-- 指定所有输出级别 --><br>    <root level="info"><br>        <appender-ref ref="consoleLog"><br>        <appender-ref ref="fileInfoLog"><br>        <appender-ref ref="fileErrorLog"><br>    </appender-ref></appender-ref></appender-ref></root><br><br>    <!-- 单独指定包日志打印级别 --><br>    <logger name="com.liyan" level="DEBUG"><br>        <appender-ref ref="demolog"><br>    </appender-ref></logger><br><br></property></property></property></configuration><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">### yml配置</span></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"><span class="symbol">logging:</span></span><br><span class="line"><span class="symbol">    file:</span>   <span class="meta"># 日志文件,绝对路径或相对路径</span></span><br><span class="line">    <span class="meta">#path:   # 保存日志文件目录路径 file和path两者二选一</span></span><br><span class="line"><span class="symbol">    config:</span> <span class="meta"># 日志配置文件,Spring Boot默认使用classpath路径下的日志配置文件,如:logback.xml、logback-spring.xml</span></span><br><span class="line"><span class="symbol">    level:</span>  <span class="meta"># 日志级别</span></span><br><span class="line"><span class="symbol">        root:</span> info</span><br><span class="line">        org.springframework.web: DEBUG <span class="meta"># 配置spring web日志级别，类似于logger标签</span></span><br><span class="line">        com.xxx.mapper: DEBUG</span><br><span class="line"><span class="symbol">    pattern:</span></span><br><span class="line"><span class="symbol">        console:</span> %d&#123;yyyy/MM/dd-HH:mm:ss&#125; [%thread] %<span class="number">-5</span>level %logger- %msg%n</span><br><span class="line"><span class="symbol">        file:</span> %d&#123;yyyy/MM/dd-HH:mm&#125; [%thread] %<span class="number">-5</span>level %logger- %msg%n</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> logback </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-jndi</title>
      <link href="/2018/10/11/java-jndi/"/>
      <url>/2018/10/11/java-jndi/</url>
      
        <content type="html"><![CDATA[<p>业务代码写多了，偶尔看看源码还是蛮有意思的，尤其是源码背后的设计思想，真的是让人佩服啊。</p><a id="more"></a><h2 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h2><p>JNDI API是用于访问不同命名和目录服务的接口。</p><h3 id="JNDI编程模型"><a href="#JNDI编程模型" class="headerlink" title="JNDI编程模型"></a>JNDI编程模型</h3><p>可以在rt.jar中javax.naming目录下查看所有源码</p><ol><li>上下文 Context/DirContext</li></ol><h4 id="架构："><a href="#架构：" class="headerlink" title="架构："></a>架构：</h4><p>第一层： 访问JNDI的代码</p><p>第二层： JNDI API，统一的命名和目录服务接口</p><p>第三层： JNDI管理器 NamingManager</p><p>第四层： JNDI SPI，用于构建JNDI实现的框架，动态插入命名和目录服务提供商的产品</p><p>第五层： 命名和目录服务商提供的产品。例如： DNS、LDAP、NIS、NDS</p><p>LDAP(Lightweight Directory Access Protocol): 轻量目录访问协议，也可以说是一种特殊的数据库(hierarchal数据库)</p><p>NIS(Network Information Service): 网络信息服务</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><h2 id="JNDI的应用"><a href="#JNDI的应用" class="headerlink" title="JNDI的应用"></a>JNDI的应用</h2><ol><li>EJB项目中，用于查找其它程序组件</li><li>数据库连接池中，用于连接数据库</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java消息服务JMS</title>
      <link href="/2018/10/10/java-jms/"/>
      <url>/2018/10/10/java-jms/</url>
      
        <content type="html"><![CDATA[<p>开发中多多少少接触过一些消息队列，但是对原生的JMS(Java Message Service: Java消息服务)了解较少。</p><a id="more"></a><h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>JMS API是一个消息服务的标准/规范。</p><h3 id="P2P模式"><a href="#P2P模式" class="headerlink" title="P2P模式"></a>P2P模式</h3><p>特点:</p><blockquote><p>每条消息只有一个消费者(即消息一旦被消费，消息就不在消息队列中)</p><p>生产者和消费者在时间上没有依赖性()</p><p>消费者在接收消息后需要向队列应答消费成功</p></blockquote><h3 id="Pub-Sub模式"><a href="#Pub-Sub模式" class="headerlink" title="Pub/Sub模式"></a>Pub/Sub模式</h3><p>特点:</p><blockquote><p>每条消息可以有多个消费者</p><p>生产者和消费者之间有时间上的依赖(即针对某个主题，必须创建一个消费者之后，才能消费消息)</p><p>为了消费消息，订阅者必须保持运行</p></blockquote><h3 id="JMS编程模型"><a href="#JMS编程模型" class="headerlink" title="JMS编程模型"></a>JMS编程模型</h3><p>加入依赖包jms-api，类似于servlet-api</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;javax.jms&lt;/groupId&gt;    &lt;artifactId&gt;javax.jms-api&lt;/artifactId&gt;    &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol><li>管理对象</li><li>连接对象 Connection</li><li>会话 Session</li><li>消息生产者 MessageProducer</li><li>消息消费者 MessageConsumer</li><li>消息监听者 MessageLister</li></ol><p>JMS用到JNDI机制，用于查找、访问发送目标/消息来源</p><h3 id="JMS协议结构"><a href="#JMS协议结构" class="headerlink" title="JMS协议结构"></a>JMS协议结构</h3><h2 id="JMS的应用场景"><a href="#JMS的应用场景" class="headerlink" title="JMS的应用场景"></a>JMS的应用场景</h2><ol><li><p>ActiveMQ完全支持JMS1.1和J2EE1.4规范。</p><p> ActiveMQ特性：</p><blockquote><p>应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP</p></blockquote></li><li><p>JBoss HornetQ</p></li><li>Joram</li><li>MantaRay</li><li>OpenJMS</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术框架选型</title>
      <link href="/2018/10/09/architecture-framework/"/>
      <url>/2018/10/09/architecture-framework/</url>
      
        <content type="html"><![CDATA[<h3 id="流程框架"><a href="#流程框架" class="headerlink" title="流程框架"></a>流程框架</h3><p>workflow：</p><p>camel：基于规则、路由、处理的流程引擎。无缝集成Spring</p>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis配置文件解析(二)</title>
      <link href="/2018/09/30/mybatis-config/"/>
      <url>/2018/09/30/mybatis-config/</url>
      
        <content type="html"><![CDATA[<p>MyBatis实例化过程实质上还是Spring加载bean的过程，配置方式有不同的方案：1)xml配置 2)注解配置</p><a id="more"></a><h2 id="mybatis-–-spring-boot-starter"><a href="#mybatis-–-spring-boot-starter" class="headerlink" title="mybatis – spring-boot-starter"></a>mybatis – spring-boot-starter</h2><p>1、通过properties/yml配置</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mybatis.config：mybatis-config.xml配置文件的路径</span><br><span class="line">mybatis.typeHandlersPackage：扫描typeHandlers的包</span><br><span class="line">mybatis.checkConfigLocation：检查配置文件是否存在</span><br><span class="line">mybatis.executorType：设置执行模式（SIMPLE, REUSE, BATCH），默认为SIMPLE</span><br><span class="line">mybatis.mapper-locations=<span class="keyword">classpath</span>:<span class="regexp">/mybatis/</span>*Mapper.xml <span class="comment">//2</span></span><br><span class="line">mybatis.type-aliases-<span class="keyword">package</span>=tk.mapper.model</span><br></pre></td></tr></table></figure><h2 id="mybatis-–-spring"><a href="#mybatis-–-spring" class="headerlink" title="mybatis – spring"></a>mybatis – spring</h2><p>创建@Configuration MyBatisConfig配置类，</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li>configLocation<br> 指定mybatis-config核心配置文件的路径</li><li>objectFactory  DefaultObjectFactory</li><li>objectWrapperFactory DefaultObjectWrapperFactory</li><li>vfs<br> 用来读取服务器相关资源，并加载相关的类</li><li>typeAliasesPackage<br> 给整个包起一个别名，</li><li>typeAliases<br> 设置别名，</li><li>Plugins<br> 插件，用于sql执行过程中对方法对拦截调用。常见的几种插件：<br> · Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)<br> · ParameterHandler (getParameterObject, setParameters)<br> · ResultSetHandler (handleResultSets, handleOutputParameters)<br> · StatementHandler (prepare, parameterize, batch, update, query)</li><li>typeHandlersPackage、typeHandlers<br> 类型转换器，用于Javabean和数据库类型之间的转换</li><li>databaseIdProvider<br> 用于多数据源切换</li><li>Cache<br>扩展MyBatis Cache接口，自定义缓存</li><li><p>xmlConfigBuilder</p></li><li><p>transactionFactory<br>没有自定义事务时，默认使用Spring的事务</p></li><li>mapperLocations<br>Mapper.xml文件的扫描路径</li></ol><h2 id="Mapper配置过程源码分析"><a href="#Mapper配置过程源码分析" class="headerlink" title="Mapper配置过程源码分析"></a>Mapper配置过程源码分析</h2><p>mapper.xml的初始化过程：<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/mybatis/mybatis-config1.png" alt="图1"></p><p>mapper实例化过程：<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/mybatis/mybatis-config2.png" alt="图2"></p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2018/09/28/java-multithread/"/>
      <url>/2018/09/28/java-multithread/</url>
      
        <content type="html"><![CDATA[<h2 id="物理内存模型"><a href="#物理内存模型" class="headerlink" title="物理内存模型"></a>物理内存模型</h2><p>缓存一致性：</p><p>处理器访问缓存(cache)时遵守的一些协议：MSI、MESI、MOSI、Synapse、Firefly、Dragon Protocol</p><p>指令重排序：</p><h2 id="JVM的内存模型："><a href="#JVM的内存模型：" class="headerlink" title="JVM的内存模型："></a>JVM的内存模型：</h2><p>主内存：所有的变量都存储在主内存，类似于物理机的主内存。对应于Java堆中对象实例数据部分。</p><p>工作内存：每条线程都有自己的工作内存，该区域保存了该线程使用到的变量的副本拷贝，类似于物理机的高速缓存。对应于虚拟机栈中的部分区域。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile的2种特性：</p><p>1、保证此变量对所有线程的可见性</p><p>2、禁止指令重排序优化。</p><p>volatile在单例模式中的应用：</p><h3 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h3><ol><li><p>原子性：</p></li><li><p>可见性：</p><p> volatile：</p><p> synchronized：对一个变量执行unlock操作之前，必须先把此变量同步回主内存。</p><p> final：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this的引用传递出去，那在其他线程中就能看见final字段的值。</p></li><li><p>有序性</p></li></ol><a id="more"></a> <h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>用于判断数据是否存在竞争、线程是否安全</p><p>原则：</p><blockquote><p>程序次序原则</p><p>管程锁定原则</p><p>volatile变量原则</p><p>线程启动原则</p><p>线程终止原则</p><p>线程中断原则</p><p>对象终结原则</p><p>传递性</p></blockquote><p>如果两个操作之间的关系不存在此列，并且无法由此规则推导出来，它们之间就没有顺序性保障，虚拟机可以对它们进行重排序。</p><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发不一定要依赖多线程，PHP中很常见的多进程并发。</p><p>实现线程有3种方式：</p><ol><li>使用内核线程实现</li><li>使用用户线程实现</li><li>使用用户线程 + 轻量级进程混合实现</li></ol><p>Java线程的实现：</p><p>jdk1.2之前，基于用户线程实现</p><p>jdk1.2中，基于操作系统原生线程模型实现</p><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>线程调度的2种方式：</p><ol><li>协同式调度：线程的执行时间是由线程本身控制的</li><li>抢占式调度：每个线程由系统来分配执行时间。Java使用的就是抢占式调度</li></ol><h3 id="Java线程的状态"><a href="#Java线程的状态" class="headerlink" title="Java线程的状态"></a>Java线程的状态</h3><ol><li>新建</li><li>运行：处于此状态的线程可能正在执行，也可能正在等待CPU为它分配执行时间</li><li>无限期等待：此状态的线程不会被分配CPU执行时间，需要等待其它线程显式唤醒</li><li>限期等待：此状态的线程也不会被分配CPU执行时间，不过无需等待被其它线程显式唤醒，在一定时间后由系统自动唤醒。</li><li>阻塞：线程被阻塞，等待其它排他锁</li><li>结束：</li></ol><h2 id="Java线程安全的实现："><a href="#Java线程安全的实现：" class="headerlink" title="Java线程安全的实现："></a>Java线程安全的实现：</h2><ol><li>互斥同步(阻塞同步)：synchronized、ReentrantLock</li><li><p>非阻塞同步：基于冲突检测的乐观并发策略，</p><p> CAS：比较并交换。CAS存在ABA问题</p></li></ol><ol start="3"><li><p>无同步方案</p><p> 可重入代码(纯代码)：</p><p> 线程本地存储：</p></li></ol><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><ol><li>自旋锁、自适应自旋锁</li><li>锁消除：</li><li>锁粗化：</li><li>轻量级锁：在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量带来的性能消耗</li><li>偏向锁：消除数据在无竞争的情况下的同步原语，进一步提高程序的运行性能。偏向锁可以提高带有同步但无竞争的程序性能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/2018/09/28/java-jvm/"/>
      <url>/2018/09/28/java-jvm/</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>可以看作当前线程所执行的字节码的行号执行器。通过改变这个计数器的值来选取下一条要执行的字节码指令。</p><p>每个线程有自己独立的程序计数器，各线程之间计数器互不影响，独立存储。</p><a id="more"></a> <h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>线程私有，生命周期和线程相同。</p><p>描述的Java方法执行的内存模型，每个方法在执行时都会创建一个栈帧：</p><blockquote><p>存储局部变量表、</p><p>操作数栈、</p><p>动态链接、</p><p>方法出口。</p></blockquote><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和Java虚拟机栈类似，</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>被所有线程共享的一块区域，在虚拟机启动时创建。该内存区的唯一目的就是存放对象实例。</p><p>逃逸分析技术：</p><p>栈上分配</p><p>标量替换</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>所有线程共享的内存区。用于存储：</p><blockquote><p>被虚拟机加载的类信息：</p><p>常量</p><p>静态变量</p><p>即时编译器编译后的代码</p></blockquote><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>属于方法区的一部分。Class文件中的常量池在类加载后也会进入方法区的运行时常量池。还有常量池：编译期生成的各种字面量、符号引用、直接引用()。</p><p>例如String.intern()方法。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h2 id="虚拟机对象"><a href="#虚拟机对象" class="headerlink" title="虚拟机对象"></a>虚拟机对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><strong>注意:</strong> 仅限于普通Java对象，不包括数组、Class对象。</p><ol><li><p>当虚拟机遇到new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化过。如果没有，则执行相应的类加载过程。</p></li><li><p>为新生对象分配内存</p><blockquote><p>指针碰撞分配</p><p>空闲列表分配</p><p>内存分配的并发问题：</p><p>CAS + 失败重试</p><p>本地线程分配缓冲(TLAB)</p></blockquote></li><li><p>对象进行必要的设置</p></li><li>执行<init>方法</init></li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中存储包括3块区域:</p><blockquote><p>对象头：<br>     1、存储对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳<br>        2、类型指针：该对象指向它的类元数据的指针</p><p>实例数据：真正存储的有效信息，也就是在程序代码中定义的各种类型的字段内容。</p><p>对齐填充：非必须，起占位符的作用</p></blockquote><h3 id="对象的定位访问"><a href="#对象的定位访问" class="headerlink" title="对象的定位访问"></a>对象的定位访问</h3><p>1、句柄访问</p><p>优点：</p><p>在对象被移动时，只会改变句柄中的实例数据指针</p><p>2、直接指针访问</p><p>优点：</p><p>访问速度快，节省了一次指针定位的时间开销</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/2018/09/28/mysql-index/"/>
      <url>/2018/09/28/mysql-index/</url>
      
        <content type="html"><![CDATA[<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ol><li><p>B-Tree索引 InnoDB引擎使用的是B+Tree</p><p> B-Tree的限制：</p><blockquote><p>如果不是按照索引的最左列开始查找，则无法使用索引</p><p>不能跳过索引中的列</p><p>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</p></blockquote></li><li><p>哈希索引</p></li><li>空间数据索引(R-Tree)</li><li>全文索引</li></ol><a id="more"></a><h3 id="MyISAM和InnoDB的不同："><a href="#MyISAM和InnoDB的不同：" class="headerlink" title="MyISAM和InnoDB的不同："></a>MyISAM和InnoDB的不同：</h3><p>MyISAM使用前缀压缩使索引更小，而InnoDB按照原数据格式进行存储。</p><p>MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键饮用被索引的行。</p><h2 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h2><p>聚簇索引</p><p>非聚簇索引</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>基于语句的复制</p><p>基于行的复制</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快排</title>
      <link href="/2018/09/28/algorithms-quicksort/"/>
      <url>/2018/09/28/algorithms-quicksort/</url>
      
        <content type="html"><![CDATA[<h2 id="java语言实现"><a href="#java语言实现" class="headerlink" title="java语言实现"></a>java语言实现</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">       <span class="comment">// main live template</span></span><br><span class="line">       <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">       quickSort(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">       Arrays.stream(arr).forEach( <span class="keyword">value</span> -&gt; &#123;</span><br><span class="line">           System.<span class="keyword">out</span>.println(<span class="keyword">value</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span>(<span class="params"><span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high</span>)</span> &#123;</span><br><span class="line">       <span class="keyword">int</span> i = low;</span><br><span class="line">       <span class="keyword">int</span> j = high;</span><br><span class="line">       <span class="keyword">int</span> <span class="keyword">base</span> = a[low];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span>(a[j] &gt; <span class="keyword">base</span> &amp;&amp; i &lt; j)&#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> ( i &lt; j ) &#123;</span><br><span class="line">               <span class="keyword">int</span> temp = a[j];</span><br><span class="line">               a[j] = a[i];</span><br><span class="line">               a[i] = temp;</span><br><span class="line">               i++;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">while</span>(a[i] &lt; <span class="keyword">base</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>( i &lt; j ) &#123;</span><br><span class="line">                   <span class="keyword">int</span> temp2 = a[i];</span><br><span class="line">                   a[i] = a[j];</span><br><span class="line">                   a[j] = temp2;</span><br><span class="line">                   j--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       a[i] = <span class="keyword">base</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (low &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">           quickSort(a, low, i<span class="number">-1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (j+<span class="number">1</span> &lt; high) &#123;</span><br><span class="line">           quickSort(a, j+<span class="number">1</span>, high);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="go语言实现"><a href="#go语言实现" class="headerlink" title="go语言实现"></a>go语言实现</h2><figure class="highlight plain"><figcaption><span>main</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// fmt.Println(&quot;Hello Mac go&quot;)</span><br><span class="line"></span><br><span class="line">arr := []int&#123;3, 7, 5, 1, 8, 6&#125;</span><br><span class="line"></span><br><span class="line">quick_sort(arr, 0, len(arr)-1)</span><br><span class="line"></span><br><span class="line">for v := range arr &#123;</span><br><span class="line">fmt.Println(arr[v])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func quick_sort(a []int, low int, high int) &#123;</span><br><span class="line">i := low</span><br><span class="line">j := high</span><br><span class="line">base := a[low]</span><br><span class="line"></span><br><span class="line">for ; i &lt; j; &#123;</span><br><span class="line"></span><br><span class="line">for ; a[j] &gt; base &amp;&amp; i &lt; j; &#123;</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if i &lt; j &#123;</span><br><span class="line">temp := a[j]</span><br><span class="line">a[j] = a[i]</span><br><span class="line">a[i] = temp</span><br><span class="line">i++</span><br><span class="line"></span><br><span class="line">for ; a[i] &lt; base &amp;&amp; i &lt; j; &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">if i &lt; j &#123;</span><br><span class="line">temp2 := a[i]</span><br><span class="line">a[i] = a[j]</span><br><span class="line">a[j] = temp2</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a[i] = base</span><br><span class="line"></span><br><span class="line">if low &lt; i-1 &#123;</span><br><span class="line">quick_sort(a, low, i-1)</span><br><span class="line">&#125;</span><br><span class="line">if j+1 &lt; high &#123;</span><br><span class="line">quick_sort(a, j+1, high)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java加载器</title>
      <link href="/2018/09/28/java-classloader/"/>
      <url>/2018/09/28/java-classloader/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构基础</title>
      <link href="/2018/09/28/architecture-base/"/>
      <url>/2018/09/28/architecture-base/</url>
      
        <content type="html"><![CDATA[<p>经历了一些小系统，”麻雀虽小五脏俱全”，结合自己的经历，谈一些自己的看法。在我看来，架构更多的就是结合不同的业务场景，选择不同的组件去构建一个高可用、高并发、可扩展的系统。</p><a id="more"></a><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><h2 id="1、网关"><a href="#1、网关" class="headerlink" title="1、网关"></a>1、网关</h2><p>Zuul: 不完全支持异步，需要很好的配合限流熔断，否则容易造成资源耗尽、雪崩效应。</p><p>Zuul2:</p><p>Spring Cloud Gateway:</p><p>Nginx:</p><p>Kong:</p><h2 id="2、服务发现"><a href="#2、服务发现" class="headerlink" title="2、服务发现"></a>2、服务发现</h2><p>Eureka: 支持跨数据中心高可用，AP最终一致性，不是强一致性。可以结合Ribbon/Feign</p><p>Zookeeper:</p><p>Etcd:</p><p>Consul:</p><h2 id="2、配置中心"><a href="#2、配置中心" class="headerlink" title="2、配置中心"></a>2、配置中心</h2><p>Spring Cloud Config-Server: 只能小规模使用，不建议中大规模使用</p><p>携程的Apollo: </p><p>百度的Disconf:</p><p>阿里的Diamond:</p><h2 id="4、认证授权"><a href="#4、认证授权" class="headerlink" title="4、认证授权"></a>4、认证授权</h2><p>Spring Security OAuth2:</p><h1 id="监控组件"><a href="#监控组件" class="headerlink" title="监控组件"></a>监控组件</h1><h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><p>Kafka</p><h2 id="5、日志监控"><a href="#5、日志监控" class="headerlink" title="5、日志监控"></a>5、日志监控</h2><p>其实日志监控有很多种组合，ELK是比较常用的组合</p><p>ELK</p><h2 id="6、链路监控"><a href="#6、链路监控" class="headerlink" title="6、链路监控"></a>6、链路监控</h2><p>大众点评CAT:</p><p>Zipkin: 不够成熟，不能算一款企业级产品</p><p>Naver Pinpoint:</p><p>Spring Cloud Seleuth:</p><p>Hydra:</p><p>eagleye:</p><p>Jaeger:</p><p>Skywalking:</p><p>OpenTracing:规范</p><h2 id="7、度量监控-Metrics"><a href="#7、度量监控-Metrics" class="headerlink" title="7、度量监控 Metrics"></a>7、度量监控 Metrics</h2><p>依赖于时序数据库</p><p>Prometheus:</p><p>InfluxDB:</p><p>KairosDB: 基于Cassandra，可以结合Grafana实现界面化展示</p><p>OpenTSDB:</p><h2 id="8、健康检查、告警"><a href="#8、健康检查、告警" class="headerlink" title="8、健康检查、告警"></a>8、健康检查、告警</h2><p>Zmon:</p><p>Zabbix:</p><h2 id="9、限流、熔断"><a href="#9、限流、熔断" class="headerlink" title="9、限流、熔断"></a>9、限流、熔断</h2><p>Hystrix: 可以结合Turbine实现监控数据流的聚合</p>]]></content>
      
      
      <categories>
          
          <category> Architect </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统--存储</title>
      <link href="/2018/09/28/csapp-cache/"/>
      <url>/2018/09/28/csapp-cache/</url>
      
        <content type="html"><![CDATA[<p>高级缓存</p><a id="more"></a><h2 id="随机访问存储"><a href="#随机访问存储" class="headerlink" title="随机访问存储"></a>随机访问存储</h2><h4 id="1-静态RAM"><a href="#1-静态RAM" class="headerlink" title="1. 静态RAM"></a>1. 静态RAM</h4><p>每个位存储在一个双稳态的存储单元，每个位都处于一个稳态。<br>每个单元是用一个六晶体管电路组成。</p><h4 id="2-动态RAM-DRAM"><a href="#2-动态RAM-DRAM" class="headerlink" title="2. 动态RAM DRAM"></a>2. 动态RAM DRAM</h4><p>每个位存储在一个电容内，<br>每个单元是用一个电容和一个访问晶体管组成，存储单元对干扰敏感，光线会导致电容电压改变。</p><p>区别：<br>只要有电，SRAM就会保持不变，与DRAM不同，SRAM不需要刷新<br>SRAM的存取比DRAM快<br>SRAM对光电等的干扰不敏感，但是比DRAM要贵</p><h4 id="3-传统的DRAM"><a href="#3-传统的DRAM" class="headerlink" title="3. 传统的DRAM"></a>3. 传统的DRAM</h4><p>传统DRAM芯片被分成d个超单元，每个超单元由w个DRAM单元组成<br>超单元集合被组成逻辑的r行c列，d=r*c，data引脚 + addr引脚<br>数据通过引脚连接超单元，传输信息</p><h4 id="4-内存模块"><a href="#4-内存模块" class="headerlink" title="4. 内存模块"></a>4. 内存模块</h4><p>DRAM芯片封装在内存模块中，插在主板扩展槽内</p><p>m个内存模块组成主存，每个内存模块由n个DRAM芯片组成。假如接收到地址A，先找到包含A的模块k，再将A转为(i, j)形式的地址，将模块内所有的芯片内 </p><h4 id="5-增强的DRAM"><a href="#5-增强的DRAM" class="headerlink" title="5. 增强的DRAM"></a>5. 增强的DRAM</h4><p>快页模式DRAM</p><p>扩展数据输出DRAM</p><p>同步DRAM</p><p>双倍数据速率同步DRAM</p><p>视频RAM</p><h4 id="6-非易失性存储器"><a href="#6-非易失性存储器" class="headerlink" title="6. 非易失性存储器"></a>6. 非易失性存储器</h4><p>DRAM和SRAM断电，会丢失信息，属于易失性存储器。非易失性存储器即使断电后，依然可以保存信息。</p><p>ROM：<br>PROM：只能被编程一次<br>可擦写可编程ROM：EPROM，<br>    电子可擦除PROM：EEPROM<br>闪存：基于EEPROM，<br>    固态硬盘：闪存芯片 + 闪存翻译层</p><p>固件：存储在ROM设备中的程序通常称为固件。例如：PC的BIOS例程</p><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>总线：用于CPU和主存之间的数据传输，能够携带地址、数据、控制信号。</p><p>系统总线：连接CPU和I/O桥接器<br>内存总线：连接I/O桥接器和主存</p><p>补充：不同的硬件厂商使用不同的总线设计<br>Intel： 北桥 南桥<br>AMD：超传输互联<br>Intel Core i7：快速通道互联</p><h2 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h2><p>逻辑磁盘块：</p><h4 id="连接I-O设备"><a href="#连接I-O设备" class="headerlink" title="连接I/O设备"></a>连接I/O设备</h4><p>I/O总线：连接CPU/主存到图形卡、监视器、鼠标、磁盘</p><p>主机总线适配器：将一个或多个磁盘连接到I/O总线，使用一个特别的主机总线接口定义的通信协议。<br>磁盘接口：<br>    SCSI：可以支持多个磁盘驱动器<br>    SATA：只能支持一个驱动器</p><p>补：I/O总线进展<br>PCI模型中，所有设备共享总线，一个时刻只能有一台设备访问这些线路。<br>现代系统：共享的PCI总线被PCIe总线取代，PCIe是一组高速串行、通过开关连接的点到点链路</p><h4 id="访问磁盘"><a href="#访问磁盘" class="headerlink" title="访问磁盘"></a>访问磁盘</h4><p>内存映射I/O：作为CPU向I/O设备发射命令的技术<br>I/O端口：为与I/O设备通信保留的地址空间</p><h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>时间局部性<br>空间局部性</p><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>L1高速缓存<br>L2高速缓存<br>L3高级缓存</p><p>系统：<br>每个存储器地址m位，形成$M=2^m$个不同的地址<br>高速缓存被组织成$S=2^s$个高速缓存组<br>每个高速缓存组包含E个高速缓存行<br>每个行由一个$B=2^b$字节的数据块组成<br>这样的高速缓存可以用结构$(S, E, B, m)$表示。</p><h3 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h3><h3 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h3><h3 id="读-写问题"><a href="#读-写问题" class="headerlink" title="读/写问题"></a>读/写问题</h3><p>读：</p><p>写：</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统--内存</title>
      <link href="/2018/09/28/csapp-vm/"/>
      <url>/2018/09/28/csapp-vm/</url>
      
        <content type="html"><![CDATA[<p>内存管理</p><a id="more"></a><p>虚拟内存：</p><p>物理地址</p><p>虚拟地址</p><p>地址翻译</p><p>内存管理单元</p><p>线性地址空间</p><p>物理地址空间</p><p>虚拟地址空间</p><p>虚拟页</p><p>物理页</p><p>SRAM</p><p>DRAM</p><p>页命中、缺页、</p><p>局部性</p><p>活动页面</p><p>工作集(常驻集合)</p><p>抖动</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven-version</title>
      <link href="/2018/09/27/maven-version/"/>
      <url>/2018/09/27/maven-version/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>maven配置文件</title>
      <link href="/2018/09/27/maven-base/"/>
      <url>/2018/09/27/maven-base/</url>
      
        <content type="html"><![CDATA[<p>一直在用maven，其实对maven并没有非常深入理解，任重道远啊。最近一个项目编译的时候，开始使用Plugins–install–install:install命令，</p><a id="more"></a><p>编译报错：</p><pre><code>[ERROR] Failed to execute goal org.apache.maven.plugins:maven-install-plugin:2.5.2:install (default-cli) on project StarTeamCollisionUtil: The packaging for this project did not assign a file to the build artifact -&gt; [Help 1]</code></pre><p>后来使用Lifecycle–install，编译成功；使用maven clean install也会成功。最后查看<a href="https://stackoverflow.com/questions/6308162/maven-the-packaging-for-this-project-did-not-assign-a-file-to-the-build-artifac" target="_blank" rel="noopener">StackOverflow</a></p><p>大致意思：install:install命令是插件maven-install-plugin中的命令，不同于Lifecycle中的install命令。</p><p>mvn clean install在每个周期中会运行所有的命令，包括：compile、package、test等等。</p><p>mvn clean install:install则只会install一个命令，甚至不包括compile、package</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><ol><li><p>本地仓库</p></li><li><p>远程仓库</p></li><li><p>中央仓库</p></li></ol><p>先从本地仓库查找，再从私服查找，最后再到远处、中央仓库查找。</p><h2 id="setting-xml"><a href="#setting-xml" class="headerlink" title="setting.xml"></a>setting.xml</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>用于配置速度更快的的仓库镜像，mirrorOf可以配置’central,*’不同仓库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-net-cn<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven China Mirror<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.net.cn/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><h3 id="packaging类型"><a href="#packaging类型" class="headerlink" title="packaging类型"></a>packaging类型</h3><pre><code>&lt;packaging&gt;&lt;/packaging&gt;</code></pre><h3 id="parent标签"><a href="#parent标签" class="headerlink" title="parent标签"></a>parent标签</h3><h3 id="dependencies标签"><a href="#dependencies标签" class="headerlink" title="dependencies标签"></a>dependencies标签</h3><ol><li>compile：默认编译依赖范围。对于编译，测试，运行三种classpath都有效。如log4j</li><li>test：测试依赖范围。只对于测试classpath有效。如junit</li><li>provided：已提供依赖范围。对于编译，测试的classpath都有效，但对运行无效。servlet-api</li><li>runtime：运行时提供。例如：jdbc驱动。<br>最主要要区分compile和provided。</li></ol><h4 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h4><p>原则：近路优先，声明优先</p><ol><li>当第二依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致。</li><li>当第二直接依赖的范围是test的时候，依赖不会得以传递。</li><li>当第二依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，且传递性依赖的范围同样为 provided；</li><li>当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile例外，此时传递的依赖范围为runtime；</li></ol><h4 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h4><p>在maven中存在两种冲突方式：一种是跨pom文件的冲突，一种是同一个pom文件的冲突</p><ol><li>如果直接与间接依赖中包含有同一个坐标不同版本的资源依赖，以直接依赖的版本为准（就近原则）</li><li>同一个pom文件中的冲突。pom文件从上到下加载，那么下面的jar包会覆盖上面的jar包。这也体现了就近原则。</li></ol><h4 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h4><pre><code>&lt;optional&gt;true/false&lt;/optional&gt;</code></pre><p>true，则表示该依赖不会传递下去<br>false，则会传递下去。</p><h4 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Lifecycle生命周期"><a href="#Lifecycle生命周期" class="headerlink" title="Lifecycle生命周期"></a>Lifecycle生命周期</h3><h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><ol><li>pre-clean 执行一些需要在clean之前完成的工作；</li><li>clean 移除所有上一次构建生成的文件 ；</li><li>post-clean 执行一些需要在clean之后立刻完成的工作 。</li></ol><p>mvn clean命令，等同于 mvn pre-clean clean。只要执行后面的命令，那么前面的命令都会执行，不需要再重新去输入命令。有Clean生命周期，在生命周期又有clean阶段。</p><h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><h4 id="site"><a href="#site" class="headerlink" title="site"></a>site</h4><ol><li>pre-site 执行一些需要在生成站点文档之前完成的工作 ；</li><li>site 生成项目的站点文档 ；</li><li>post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 ；</li><li>site-deploy 将生成的站点文档部署到特定的服务器上 。</li></ol><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><h3 id="pluginManagement标签"><a href="#pluginManagement标签" class="headerlink" title="pluginManagement标签"></a>pluginManagement标签</h3><h3 id="dependencyManagement标签"><a href="#dependencyManagement标签" class="headerlink" title="dependencyManagement标签"></a>dependencyManagement标签</h3><h3 id="distributionManagement标签"><a href="#distributionManagement标签" class="headerlink" title="distributionManagement标签"></a>distributionManagement标签</h3><p>分发构件至远程仓库</p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-merge</title>
      <link href="/2018/09/27/git-merge/"/>
      <url>/2018/09/27/git-merge/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git-base</title>
      <link href="/2018/09/27/git-base/"/>
      <url>/2018/09/27/git-base/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据</title>
      <link href="/2018/09/25/bigdata-base/"/>
      <url>/2018/09/25/bigdata-base/</url>
      
        <content type="html"><![CDATA[<p>大数据的应用场景越来越多，数据采集、数据计算、数据服务、数据应用</p><a id="more"></a><h2 id="大数据框架"><a href="#大数据框架" class="headerlink" title="大数据框架"></a>大数据框架</h2><p>流处理和批处理所提供的SLA(服务等级协议)完全不同</p><ol><li><p>实现批处理：批处理需要支持高吞吐、高效处理</p><blockquote><p>MapReduce </p><p>Spark</p></blockquote></li><li><p>实现流处理：流处理需要支持低延迟、Exactly-once保证</p><blockquote><p>Storm</p><p>Spark的Streaming其实是一种微批处理</p></blockquote></li></ol><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><h2 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h2><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2>]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bigdata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nexus私服</title>
      <link href="/2018/09/23/nexus-base/"/>
      <url>/2018/09/23/nexus-base/</url>
      
        <content type="html"><![CDATA[<p>私服的搭建一般是运维的工作，作为有追求的程序猿。。。</p><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>依赖于jdk</strong></p><h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><h3 id="tar-gz安装"><a href="#tar-gz安装" class="headerlink" title="tar.gz安装"></a>tar.gz安装</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd /usr/local</span><br><span class="line"></span><br><span class="line">tar -xzvf nexus-<span class="number">3.14</span>.<span class="number">0</span>-unix<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line"></span><br><span class="line">mv nexus-<span class="number">3.14</span>.<span class="number">0</span> nexus</span><br><span class="line"></span><br><span class="line">cd nexus/bin</span><br><span class="line"></span><br><span class="line">ln -s nexus nexus</span><br><span class="line"></span><br><span class="line">vi nexus.rc</span><br><span class="line"></span><br><span class="line">创建nexus用户</span><br><span class="line"></span><br><span class="line">useradd nexus</span><br><span class="line"></span><br><span class="line">修改启动用户</span><br><span class="line"></span><br><span class="line">run_as_user=<span class="string">"nexus"</span></span><br><span class="line"></span><br><span class="line">修改启动端口</span><br></pre></td></tr></table></figure><h3 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h3><p>vi /etc/systemd/system/nexus.service</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"><span class="attribute">Description</span>=nexus service</span><br><span class="line"><span class="attribute">After</span>=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="attribute">Type</span>=forking</span><br><span class="line"><span class="attribute">ExecStart</span>=/usr/local/nexus/bin/nexus start</span><br><span class="line"><span class="attribute">ExecStop</span>=/usr/local/nexus/bin/nexus stop</span><br><span class="line"><span class="attribute">User</span>=nexus</span><br><span class="line"><span class="attribute">Restart</span>=on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"><span class="attribute">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>systemctl daemon-reload</p><p>systemctl enable nexus</p><p>systemctl start nexus</p><h3 id="防火墙规则"><a href="#防火墙规则" class="headerlink" title="防火墙规则"></a>防火墙规则</h3><h3 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h3><p><a href="http://ip:8081/nexus" target="_blank" rel="noopener">http://ip:8081/nexus</a></p><p>默认用户 admin/admin123</p><h2 id="nexus模块"><a href="#nexus模块" class="headerlink" title="nexus模块"></a>nexus模块</h2><h3 id="仓库类型"><a href="#仓库类型" class="headerlink" title="仓库类型"></a>仓库类型</h3><p>maven</p><p>nuget</p><h3 id="jar版本"><a href="#jar版本" class="headerlink" title="jar版本"></a>jar版本</h3><p>snapshot</p><p>release</p><h3 id="Type类型："><a href="#Type类型：" class="headerlink" title="Type类型："></a>Type类型：</h3><p>proxy: 当私有nexus找不到依赖包时，就会通过代理查找</p><p>hosted: 私有的依赖包存储在这里</p><p>group: 包含proxy和hosted类型，是一个聚合体。</p><h3 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h3><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><p>Blob store</p><h3 id="Maven-2"><a href="#Maven-2" class="headerlink" title="Maven 2"></a>Maven 2</h3><p>version policy: Release、Snapshot、Mixed</p>]]></content>
      
      
      
        <tags>
            
            <tag> Nexus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-exception</title>
      <link href="/2018/09/21/spring-exception/"/>
      <url>/2018/09/21/spring-exception/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的错误与异常</title>
      <link href="/2018/09/21/java-exception-error/"/>
      <url>/2018/09/21/java-exception-error/</url>
      
        <content type="html"><![CDATA[<p>Web项目中的异常处理，什么时候该处理异常，什么抛出异常，总感觉没有形成一套理论的形式，不同的团队遇到不同的处理，但是大致流程一致。</p><h2 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h2><p>Error:理论上也属于非检查异常。例如：系统崩溃、虚拟机错误、内存溢出、方法调用栈溢出。这样的错误一般无法恢复和预防，只能通过重启应用解决</p><a id="more"></a><p><img src="http://pciqklc7l.bkt.clouddn.com/Error.png" alt></p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>java中分两类：</p><ol><li><p>检查异常：必须进行处理</p><blockquote><p>继续抛出</p><p>try-catch捕获</p></blockquote></li><li><p>非检查异常(RuntimeException 运行时异常)：可以不处理编译通过，一般是由于程序的错误导致的，例如：ArithmeticException、错误的类型转换、数组越界、空指针</p><blockquote><p>捕获</p><p>继续抛出</p><p>不处理</p></blockquote></li></ol><p>业务开发中的异常分类：</p><ol><li><p>系统异常</p><p> 自定义的、可预知的异常。例如：用户密码错误、参数错误</p><p> 一般只需要记录错误的描述信息，例如定义</p></li><li><p>业务异常</p><p> 系统运行时异常。例如：数据库连接异常、IO失败、空指针</p><p> 一般需要生成完整的调用栈追踪信息</p></li></ol><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>当不知道如何处理异常时，可以通过throws抛给调用者或者JVM。</p><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>使用throw抛出异常时，抛出的不是一个类，而是一个对象。</p><blockquote><p>如果抛出的异常是一个Checked异常，则使用try-catch捕获、或者放在一个throws方法内。<br>如果抛出的是RuntimeException，则可以使用try-catch捕获、或者不做任何处理</p></blockquote><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>异常类继承关系图：</p><p><img src="http://pciqklc7l.bkt.clouddn.com/Exception.png" alt></p><p>可以看到自定义异常一定是Throwable的子类，</p><ol><li>若是检查异常就要继承Exception类</li><li>若是运行时异常，就继承Runtime<br>Exception</li></ol><h3 id="异常链："><a href="#异常链：" class="headerlink" title="异常链："></a>异常链：</h3><p>捕获一个异常，然后接着抛出另一个异常，并把原始信息保存下来的链式处理。</p><p>应用场景：</p><h3 id="try-catch-finally-return"><a href="#try-catch-finally-return" class="headerlink" title="try-catch-finally-return"></a>try-catch-finally-return</h3><p>finally代码块一定会在try/catch代码块return之前执行，如果finally有return，则提前执行return，try/catch中的return不再执行。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ol><li>不用过度使用异常：可预测的错误应该通过代码逻辑处理，不确定的、运行时异常才抛出异常</li><li>不用使用try包含太多的代码逻辑，</li><li>避免使用Catch All语句：Catch All即catch(Throwable t)，扩大异常的范围不利于排查错误</li><li>不要忽略已捕获的异常：对于捕获的异常应该进行处理提高代码的健壮性，而不是只打印跟踪栈信息。</li><li>不要使用异常控制流程，异常越早抛出越好</li><li>尽量不要捕获/抛出类似Exception这样笼统的异常，应该具体化</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-cloud-disconf</title>
      <link href="/2018/09/21/spring-cloud-disconf/"/>
      <url>/2018/09/21/spring-cloud-disconf/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web项目中关于参数的问题</title>
      <link href="/2018/09/20/spring-mvc-arguments/"/>
      <url>/2018/09/20/spring-mvc-arguments/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql中数值的存储"><a href="#mysql中数值的存储" class="headerlink" title="mysql中数值的存储"></a>mysql中数值的存储</h2><p>五大类：</p><ol><li><p>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</p></li><li><p>浮点数类型：FLOAT、DOUBLE、DECIMAL、Numeric</p></li><li><p>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</p></li><li><p>日期类型：Date、DateTime、TimeStamp、Time、Year</p></li><li><p>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</p></li></ol><p>|类型|有符号数|无符号数|</p><p>|-|:-:|-|</p><h2 id="mysql数据类型和Java数据类型的对应关系"><a href="#mysql数据类型和Java数据类型的对应关系" class="headerlink" title="mysql数据类型和Java数据类型的对应关系"></a>mysql数据类型和Java数据类型的对应关系</h2><ol><li>BigDecimal在入库的时候，对应mysql中的decimal(decimal(a,b))，同时mysql在设置默认值时，一定要写成’0.00’，而不要使用默认值NULL，否则在加、减、排序容易出错</li></ol><h2 id="Java中常见的问题"><a href="#Java中常见的问题" class="headerlink" title="Java中常见的问题"></a>Java中常见的问题</h2><ol><li>js解析超大数值精度丢失问题</li><li>Float和Double不能精确计算价格，建议采用BigDecimal</li><li>BigDecimal比较0和‘0’的问题</li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="RequestParam、-RequestBody和-RequestPart"><a href="#RequestParam、-RequestBody和-RequestPart" class="headerlink" title="@RequestParam、@RequestBody和@RequestPart"></a>@RequestParam、@RequestBody和@RequestPart</h3><ol><li>x-www-form-urlencoded 参数存储在query中 用@RequestParam接收</li><li>form-data 参数存储在body中，用@RequestBody接收，文件类型用@RequestParam/@RequestPart接收</li><li>raw(josn,xml) 参数存储在body中 用@RequetBody接收</li></ol><h3 id="RequestMapping、-GetMapping-PostMapping和-PathVariable"><a href="#RequestMapping、-GetMapping-PostMapping和-PathVariable" class="headerlink" title="@RequestMapping、@GetMapping@PostMapping和@PathVariable"></a>@RequestMapping、@GetMapping@PostMapping和@PathVariable</h3><ol><li>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html; </li><li>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li><li>params： 指定request中必须包含某些参数值时，才让该方法处理。 </li><li>指定request中必须包含某些指定的header值，才能让该方法处理请求。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OLTP和OLAP技术</title>
      <link href="/2018/09/18/oltp-olap/"/>
      <url>/2018/09/18/oltp-olap/</url>
      
        <content type="html"><![CDATA[<h2 id="OLTP"><a href="#OLTP" class="headerlink" title="OLTP"></a>OLTP</h2><h2 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h2><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>分区技术</p><p>并行技术</p><p>MV技术</p><p>位图索引</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol><li>ROLAP 基于关系型数据库</li><li>MOLAP 基于多维数据 立方块Cube(旋转Pivot、切块Dice、切片Slice、钻取Drill-down/Roll-up)</li><li>HOLAP 基于混合数据：如底层是关系型，高层是多维矩阵</li></ol><h2 id="唯一ID主键"><a href="#唯一ID主键" class="headerlink" title="唯一ID主键"></a>唯一ID主键</h2><ol><li>自增主键</li><li>Twitter snowflake算法</li><li>Flickr</li><li>GUID/UUID</li></ol>]]></content>
      
      
      <categories>
          
          <category> Bigdata </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bigdata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC时间传值问题</title>
      <link href="/2018/09/18/spring-mvc-date/"/>
      <url>/2018/09/18/spring-mvc-date/</url>
      
        <content type="html"><![CDATA[<p>最近新入职公司，接手一个老项目，代码是多个人开发的，风格各异，中间就遇到时间传值问题，在VO层，有的传值Date，有的传值String</p><h2 id="前台–-gt-后台传值"><a href="#前台–-gt-后台传值" class="headerlink" title="前台–&gt;后台传值"></a>前台–&gt;后台传值</h2><ol><li>通过set转换不同格式</li><li>在VO上使用注解，@DateTimeFormat(pattern = “yyyy-MM-dd HH:mm:ss”);@JsonFormat(pattern=”yyyy-MM-dd HH:mm”);<br>@Temporal(TemporalType.TIMESTAMP)</li><li>创建BaseController类，所有的controller继承BaseController，BaseController中实现initBinder方法</li><li>重写DateConverter类实现Converter&lt;String, Date&gt;接口，重写convert方法</li></ol><h2 id="后台–-gt-前台传值"><a href="#后台–-gt-前台传值" class="headerlink" title="后台–&gt;前台传值"></a>后台–&gt;前台传值</h2><ol><li>在yml/xml中配置spring.jackson.date-format、spring.jackson.time-zone</li><li>在VO上使用注解，@DateTimeFormat(pattern = “yyyy-MM-dd HH:mm:ss”);@JsonFormat(pattern=”yyyy-MM-dd HH:mm”);<br>@Temporal(TemporalType.TIMESTAMP)</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql分库分表技术</title>
      <link href="/2018/09/17/mysql-sharding/"/>
      <url>/2018/09/17/mysql-sharding/</url>
      
        <content type="html"><![CDATA[<p>分库分表主要针对大流量用户网站，但是作为有追求的程序员，还是要熟悉理论，用的时候方便快速上手解决业务问题，毕竟生活主要还是Crud Boy</p><a id="more"></a> <p>分区：将存放数据的文件拆分成很多块儿，</p><p>分片：将数据分散存储在不同的服务器上</p><h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>在同一个数据库中，将表数据存储在表名不同、结构相同的表中</p><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><p>跨库join问题</p><p> 拆库后数据可能分布在不同的实例、物理主机，基于安全，一般禁止跨库join、group by、order等操作。</p><p> 解决方案：</p><p> 1)、全局表：即字典表，所有可能关联表。将这些表在每个数据库保存一份，</p><p> 2)、字段冗余：不同的表保存一些关联表的字段，可能导致‘数据一致性’问题，因为要在不同的表维护相同的字段</p><p> 3)、 数据同步：</p><p> 4)、系统层组装：即通过代码组装处理数据，for循环可能导致循环RPC问题，循环查询数据库，连接费时。建议一次查询返回所有结果。</p></li><li><p>跨库事务问题(分布式事务)</p></li></ol><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><h3 id="水平分表-横向分表"><a href="#水平分表-横向分表" class="headerlink" title="水平分表/横向分表"></a>水平分表/横向分表</h3><p>将表结构进行拆分，通过更细粒度的控制，将表分散在不同的服务器上，减少单表的压力</p><h3 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h3><ol><li>查询切分 将ID和库映射关系放在单独的主库中</li><li>范围切分 按照时间区间/ID区间切分</li><li>Hash切分 取模切分</li></ol><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>开源：</p><p>MyCAT: 基于Cobar</p><p>Sharding-JDBC(sharding-shpere): 当当基于JDBC</p><p>Cobar: 阿里巴巴，一年不维护</p><p>DBPRoxy: 美团，基于360的Atlas，两年不维护</p><p>Oceanus: 50同城团队</p><p>Atlas: 360团队，不推荐</p><p>TDDL: 依赖Dimond，已死</p><p>MaxScale: MariaDB作者官方，不支持分库分表</p><p>MySQL Route: MySQL官方</p><p>商业：</p><p>OneProxy：平民软件</p><p>DRDS: 阿里巴巴，基于Cobar、MySQL-Proxy</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-countdownlatch-semaphore</title>
      <link href="/2018/09/17/java-countdownlatch-semaphore/"/>
      <url>/2018/09/17/java-countdownlatch-semaphore/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql优化</title>
      <link href="/2018/09/14/mysql-optimize/"/>
      <url>/2018/09/14/mysql-optimize/</url>
      
        <content type="html"><![CDATA[<p>MySQL优化，把项目中常用的总结出来，形成方法论的东西。</p><a id="more"></a><h2 id="库表结构设计优化"><a href="#库表结构设计优化" class="headerlink" title="库表结构设计优化"></a>库表结构设计优化</h2><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="1、LIKE"><a href="#1、LIKE" class="headerlink" title="1、LIKE"></a>1、LIKE</h3><pre><code>SELECT column FROM table WHERE field LIKE &apos;%keyword%&apos;;</code></pre><p>两边都有‘%’不走索引</p><pre><code>SELECT column FROM table WHERE field LIKE &apos;keyword%&apos;;</code></pre><p>左边没有‘%’，才会走索引</p><p>可以通过explain执行计划查看，</p><p>优化替代方案：</p><ol><li>LOCATE(‘substr’, field, pos)</li><li>POSITION(‘substr’ IN field)</li><li>INSTR(field, ‘substr’)</li><li>FIND_IN_SET(‘substr’, field)</li></ol><h3 id="2、IN、NOT-IN"><a href="#2、IN、NOT-IN" class="headerlink" title="2、IN、NOT IN"></a>2、IN、NOT IN</h3><h3 id="3、int-datetime-timstamp时间存储"><a href="#3、int-datetime-timstamp时间存储" class="headerlink" title="3、int/datetime/timstamp时间存储"></a>3、int/datetime/timstamp时间存储</h3><p>对于MyISAM引擎，不建立索引的情况下（推荐），效率从高到低：</p><pre><code>int &gt; UNIX_TIMESTAMP(timestamp) &gt; datetime（直接和时间比较）&gt;timestamp（直接和时间比较）&gt;UNIX_TIMESTAMP(datetime) 。</code></pre><p>对于MyISAM引擎，建立索引的情况下，效率从高到低： </p><pre><code>UNIX_TIMESTAMP(timestamp) &gt; int &gt; datetime（直接和时间比较）&gt;timestamp（直接和时间比较）&gt;UNIX_TIMESTAMP(datetime) 。</code></pre><p>对于InnoDB引擎，没有索引的情况下(不建议)，效率从高到低：</p><pre><code>int &gt; UNIX_TIMESTAMP(timestamp) &gt; datetime（直接和时间比较） &gt; timestamp（直接和时间比较）&gt; UNIX_TIMESTAMP(datetime)。</code></pre><p>对于InnoDB引擎，建立索引的情况下，效率从高到低：</p><pre><code>int &gt; datetime（直接和时间比较） &gt; timestamp（直接和时间比较）&gt; UNIX_TIMESTAMP(timestamp) &gt; UNIX_TIMESTAMP(datetime)。</code></pre><h3 id="4、固定长度的表更快"><a href="#4、固定长度的表更快" class="headerlink" title="4、固定长度的表更快"></a>4、固定长度的表更快</h3><p>避免VARCHAR、TEXT、BLOB字段</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo序列化Kryo、FST、Hessian</title>
      <link href="/2018/09/13/dubbo-serialize/"/>
      <url>/2018/09/13/dubbo-serialize/</url>
      
        <content type="html"><![CDATA[<p>dubbo是一个非常优秀的框架，可以说研究dubbo可以学到很多东西。写博客，很多时候是首为己用，后及后人。</p><p>目前所接触到的序列化框架：</p><p>java：Java原生序列化、Kryo、FST</p><p>跨语言： Protostuff、ProtoBuf、Thrift、Avro、MsgPack、Hessian</p><a id="more"></a><h2 id="Kryo序列化"><a href="#Kryo序列化" class="headerlink" title="Kryo序列化"></a>Kryo序列化</h2><h2 id="FST序列化"><a href="#FST序列化" class="headerlink" title="FST序列化"></a>FST序列化</h2><h2 id="Hessian序列化"><a href="#Hessian序列化" class="headerlink" title="Hessian序列化"></a>Hessian序列化</h2>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java打包war</title>
      <link href="/2018/09/12/java-war/"/>
      <url>/2018/09/12/java-war/</url>
      
        <content type="html"><![CDATA[<p>java的打包，一般都是通过IDE完成，就好比git和git的界面化。界面化让人变傻。</p><p>场景： 有一个spring boot项目打好的war包，需要修改里面的xml配置文件。</p><a id="more"></a><h2 id="jar命令打包"><a href="#jar命令打包" class="headerlink" title="jar命令打包"></a>jar命令打包</h2><h3 id="直接替换war包中的文件"><a href="#直接替换war包中的文件" class="headerlink" title="直接替换war包中的文件"></a>直接替换war包中的文件</h3><pre><code>1)、创建和要修改的文件相同的路径    WEB-INF/classes/application-dev.yml2)、执行jar命令    jar -uvf lb-workflow.war  WEB-INF/classes/application-dev.yml</code></pre><h3 id="解压war包，修改xml文件，重新打包"><a href="#解压war包，修改xml文件，重新打包" class="headerlink" title="解压war包，修改xml文件，重新打包"></a>解压war包，修改xml文件，重新打包</h3><pre><code>jar cvf lb-workflow.war lb-workflow/*</code></pre><p>java -jar lb-test.war</p><ol><li><p>报错</p><pre><code>lb-workflow.war中没有主清单属性no main manifest attribute, in lb-workflow.war</code></pre><p> 指定清单文件</p><pre><code>ar -cfm lb-workflow.war lb-workflow-bak/META-INF/MANIFEST.MF lb-workflow-bak/*</code></pre></li><li><p>报错</p><pre><code>找不到或无法加载主类 org.springframework.boot.loader.WarLauncherjar -cvfm lb-test.war lb-workflow-bak/META-INF/MANIFEST.MF -C lb-workflow-bak/ .</code></pre></li><li><p>报错</p></li></ol><pre><code>    Exception in thread &quot;main&quot; java.lang.IllegalStateException: Failed to get nested archive for entry WEB-INF/lib-provided/tomcat-embed-el-8.5.31.jar    at org.springframework.boot.loader.archive.JarFileArchive.getNestedArchive(JarFileArchive.java:108)    at org.springframework.boot.loader.archive.JarFileArchive.getNestedArchives(JarFileArchive.java:86)    at org.springframework.boot.loader.ExecutableArchiveLauncher.getClassPathArchives(ExecutableArchiveLauncher.java:70)    at org.springframework.boot.loader.Launcher.launch(Launcher.java:49)    at org.springframework.boot.loader.WarLauncher.main(WarLauncher.java:58)    Caused by: java.io.IOException: Unable to open nested jar file &apos;WEB-INF/lib-provided/tomcat-embed-el-8.5.31.jar&apos;    at org.springframework.boot.loader.jar.JarFile.getNestedJarFile(JarFile.java:254)    at org.springframework.boot.loader.jar.JarFile.getNestedJarFile(JarFile.java:239)    at org.springframework.boot.loader.archive.JarFileArchive.getNestedArchive(JarFileArchive.java:103)    ... 4 more    Caused by: java.lang.IllegalStateException: Unable to open nested entry &apos;WEB-INF/lib-provided/tomcat-embed-el-8.5.31.jar&apos;. It has been compressed and nested jar files must be stored without compression. Please check the mechanism used to create your executable jar file    at org.springframework.boot.loader.jar.JarFile.createJarFileFromFileEntry(JarFile.java:282)    at org.springframework.boot.loader.jar.JarFile.createJarFileFromEntry(JarFile.java:262)    at org.springframework.boot.loader.jar.JarFile.getNestedJarFile(JarFile.java:250)    ... 6 more不压缩打包    jar -cvfm0 lb-test.war lb-workflow-bak/META-INF/MANIFEST.MF -C lb-workflow-bak/ .</code></pre><ol start="4"><li><p>报错</p><pre><code>Exception in thread &quot;main&quot; java.lang.IllegalStateException: Failed to get nested archive for entry WEB-INF/lib/.DS_Storeat org.springframework.boot.loader.archive.JarFileArchive.getNestedArchive(JarFileArchive.java:108)at org.springframework.boot.loader.archive.JarFileArchive.getNestedArchives(JarFileArchive.java:86)at org.springframework.boot.loader.ExecutableArchiveLauncher.getClassPathArchives(ExecutableArchiveLauncher.java:70)at org.springframework.boot.loader.Launcher.launch(Launcher.java:49)at org.springframework.boot.loader.WarLauncher.main(WarLauncher.java:58)Caused by: java.io.IOException: Unable to open nested jar file &apos;WEB-INF/lib/.DS_Store&apos;at org.springframework.boot.loader.jar.JarFile.getNestedJarFile(JarFile.java:254)at org.springframework.boot.loader.jar.JarFile.getNestedJarFile(JarFile.java:239)at org.springframework.boot.loader.archive.JarFileArchive.getNestedArchive(JarFileArchive.java:103)... 4 moreCaused by: java.io.IOException: Unable to find ZIP central directory records after reading 6149 bytesat org.springframework.boot.loader.jar.CentralDirectoryEndRecord.&lt;init&gt;(CentralDirectoryEndRecord.java:65)at org.springframework.boot.loader.jar.CentralDirectoryParser.parse(CentralDirectoryParser.java:52)at org.springframework.boot.loader.jar.JarFile.&lt;init&gt;(JarFile.java:121)at org.springframework.boot.loader.jar.JarFile.&lt;init&gt;(JarFile.java:109)at org.springframework.boot.loader.jar.JarFile.createJarFileFromFileEntry(JarFile.java:287)at org.springframework.boot.loader.jar.JarFile.createJarFileFromEntry(JarFile.java:262)at org.springframework.boot.loader.jar.JarFile.getNestedJarFile(JarFile.java:250)... 6 more</code></pre><p> 删除目录下mac系统生成的DS_Store文件，重新打包</p></li></ol><ol start="5"><li><p>报错</p><pre><code>SLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/Applications/tomcat-8.5.34/webapps/lb-test.war!/WEB-INF/lib/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/Applications/tomcat-8.5.34/webapps/lb-test.war!/WEB-INF/lib/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetExceptionat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)at java.lang.reflect.Method.invoke(Method.java:498)at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48)at org.springframework.boot.loader.Launcher.launch(Launcher.java:87)at org.springframework.boot.loader.Launcher.launch(Launcher.java:50)at org.springframework.boot.loader.WarLauncher.main(WarLauncher.java:58)slf4j.impl.Log4jLoggerFactoryat org.springframework.util.Assert.instanceCheckFailed(Assert.java:637)at org.springframework.util.Assert.isInstanceOf(Assert.java:537)at org.springframework.boot.logging.logback.LogbackLoggingSystem.getLoggerContext(LogbackLoggingSystem.java:274)at org.springframework.boot.logging.logback.LogbackLoggingSystem.beforeInitialize(LogbackLoggingSystem.java:99)at org.springframework.boot.context.logging.LoggingApplicationListener.onApplicationStartingEvent(LoggingApplicationListener.java:191)at org.springframework.boot.context.logging.LoggingApplicationListener.onApplicationEvent(LoggingApplicationListener.java:170)at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127)at org.springframework.boot.context.event.EventPublishingRunListener.starting(EventPublishingRunListener.java:68)at org.springframework.boot.SpringApplicationRunListeners.starting(SpringApplicationRunListeners.java:48)at org.springframework.boot.SpringApplication.run(SpringApplication.java:313)at org.springframework.boot.SpringApplication.run(SpringApplication.java:1255)at org.springframework.boot.SpringApplication.run(SpringApplication.java:1243)at com.lbonline.workflow.LBWorkFlowApplication.main(LBWorkFlowApplication.java:25)... 8 more</code></pre><p> 方法一： 删除slfg4j jar包，再打包，但是会导致无法打印日志</p><p> 方法二： 通过pom控制，但是没有成功，回头补充。</p></li></ol><h2 id="mvn命令打包"><a href="#mvn命令打包" class="headerlink" title="mvn命令打包"></a>mvn命令打包</h2><pre><code>mvn install</code></pre><ol><li><p>报错</p><pre><code>[FATAL] Non-parseable POM /Users/wanchaowang/.m2/repository/org/apache/apache/18/apache-18.pom: in epilog non whitespace content is not allowed but got r</code></pre><p> 找到repository删除org/apache/apache下18这个文件夹，重新执行mvn install</p></li><li><p>报错</p><pre><code> [ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.0.3.RELEASE:repackage (default) on project lb-workflow: Execution default of goal org.springframework.boot:spring-boot-maven-plugin:2.0.3.RELEASE:repackage failed: Unable to find main class -&gt; [Help 1]org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.0.3.RELEASE:repackage (default) on project lb-workflow: Execution default of goal org.springframework.boot:spring-boot-maven-plugin:2.0.3.RELEASE:repackage failed: Unable to find main class</code></pre><p> 这个错误没有找到好的方法，回头再补充。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合Comparator和Comparable</title>
      <link href="/2018/09/10/java-comparator/"/>
      <url>/2018/09/10/java-comparator/</url>
      
        <content type="html"><![CDATA[<p>看了一些博客，自己也想了一下，但总是想不出有明显区别的地方，还是理解的不深刻。</p><h2 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h2><p>Comparable是一个排序接口。如果一个类实现了Comparable接口，则说明该类可以实现排序。String、Integer、Double都默认实现了Comparable接口。</p><pre><code>public interface Comparable&lt;T&gt; {    public int compareTo(T o);}</code></pre><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><p>Comparator是比较器接口</p><pre><code>public interface Comparator&lt;T&gt; {    int compare(T o1, T o2);    boolean equals(Object obj);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合类Collection和Collections的区别</title>
      <link href="/2018/09/10/java-collection/"/>
      <url>/2018/09/10/java-collection/</url>
      
        <content type="html"><![CDATA[<p>java.util.COllection是一个集合接口，而java.util.Collections作为集合的工具类。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>List、Queue、Set接口都继承了Collection接口，Map接口没有实现Collection接口。</p><a id="more"></a><pre><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {// Query Operationsint size();boolean isEmpty();/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this collection contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this collection * contains at least one element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this collection is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this collection contains the specified *         element * @throws ClassCastException if the type of the specified element *         is incompatible with this collection *         (&lt;a href=&quot;#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified element is null and this *         collection does not permit null elements *         (&lt;a href=&quot;#optional-restrictions&quot;&gt;optional&lt;/a&gt;) */boolean contains(Object o);/** * Returns an iterator over the elements in this collection.  There are no * guarantees concerning the order in which the elements are returned * (unless this collection is an instance of some class that provides a * guarantee). * * @return an &lt;tt&gt;Iterator&lt;/tt&gt; over the elements in this collection */Iterator&lt;E&gt; iterator();/** * Returns an array containing all of the elements in this collection. * If this collection makes any guarantees as to what order its elements * are returned by its iterator, this method must return the elements in * the same order. * * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are * maintained by this collection.  (In other words, this method must * allocate a new array even if this collection is backed by an array). * The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this collection */Object[] toArray();/** * Returns an array containing all of the elements in this collection; * the runtime type of the returned array is that of the specified array. * If the collection fits in the specified array, it is returned therein. * Otherwise, a new array is allocated with the runtime type of the * specified array and the size of this collection. * * &lt;p&gt;If this collection fits in the specified array with room to spare * (i.e., the array has more elements than this collection), the element * in the array immediately following the end of the collection is set to * &lt;tt&gt;null&lt;/tt&gt;.  (This is useful in determining the length of this * collection &lt;i&gt;only&lt;/i&gt; if the caller knows that this collection does * not contain any &lt;tt&gt;null&lt;/tt&gt; elements.) * * &lt;p&gt;If this collection makes any guarantees as to what order its elements * are returned by its iterator, this method must return the elements in * the same order. * * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between * array-based and collection-based APIs.  Further, this method allows * precise control over the runtime type of the output array, and may, * under certain circumstances, be used to save allocation costs. * * &lt;p&gt;Suppose &lt;tt&gt;x&lt;/tt&gt; is a collection known to contain only strings. * The following code can be used to dump the collection into a newly * allocated array of &lt;tt&gt;String&lt;/tt&gt;: * * &lt;pre&gt; *     String[] y = x.toArray(new String[0]);&lt;/pre&gt; * * Note that &lt;tt&gt;toArray(new Object[0])&lt;/tt&gt; is identical in function to * &lt;tt&gt;toArray()&lt;/tt&gt;. * * @param a the array into which the elements of this collection are to be *        stored, if it is big enough; otherwise, a new array of the same *        runtime type is allocated for this purpose. * @return an array containing all of the elements in this collection * @throws ArrayStoreException if the runtime type of the specified array *         is not a supertype of the runtime type of every element in *         this collection * @throws NullPointerException if the specified array is null */&lt;T&gt; T[] toArray(T[] a);// Modification Operations/** * Ensures that this collection contains the specified element (optional * operation).  Returns &lt;tt&gt;true&lt;/tt&gt; if this collection changed as a * result of the call.  (Returns &lt;tt&gt;false&lt;/tt&gt; if this collection does * not permit duplicates and already contains the specified element.)&lt;p&gt; * * Collections that support this operation may place limitations on what * elements may be added to this collection.  In particular, some * collections will refuse to add &lt;tt&gt;null&lt;/tt&gt; elements, and others will * impose restrictions on the type of elements that may be added. * Collection classes should clearly specify in their documentation any * restrictions on what elements may be added.&lt;p&gt; * * If a collection refuses to add a particular element for any reason * other than that it already contains the element, it &lt;i&gt;must&lt;/i&gt; throw * an exception (rather than returning &lt;tt&gt;false&lt;/tt&gt;).  This preserves * the invariant that a collection always contains the specified element * after this call returns. * * @param e element whose presence in this collection is to be ensured * @return &lt;tt&gt;true&lt;/tt&gt; if this collection changed as a result of the *         call * @throws UnsupportedOperationException if the &lt;tt&gt;add&lt;/tt&gt; operation *         is not supported by this collection * @throws ClassCastException if the class of the specified element *         prevents it from being added to this collection * @throws NullPointerException if the specified element is null and this *         collection does not permit null elements * @throws IllegalArgumentException if some property of the element *         prevents it from being added to this collection * @throws IllegalStateException if the element cannot be added at this *         time due to insertion restrictions */boolean add(E e);/** * Removes a single instance of the specified element from this * collection, if it is present (optional operation).  More formally, * removes an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;, if * this collection contains one or more such elements.  Returns * &lt;tt&gt;true&lt;/tt&gt; if this collection contained the specified element (or * equivalently, if this collection changed as a result of the call). * * @param o element to be removed from this collection, if present * @return &lt;tt&gt;true&lt;/tt&gt; if an element was removed as a result of this call * @throws ClassCastException if the type of the specified element *         is incompatible with this collection *         (&lt;a href=&quot;#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified element is null and this *         collection does not permit null elements *         (&lt;a href=&quot;#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws UnsupportedOperationException if the &lt;tt&gt;remove&lt;/tt&gt; operation *         is not supported by this collection */boolean remove(Object o);// Bulk Operations/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this collection contains all of the elements * in the specified collection. * * @param  c collection to be checked for containment in this collection * @return &lt;tt&gt;true&lt;/tt&gt; if this collection contains all of the elements *         in the specified collection * @throws ClassCastException if the types of one or more elements *         in the specified collection are incompatible with this *         collection *         (&lt;a href=&quot;#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified collection contains one *         or more null elements and this collection does not permit null *         elements *         (&lt;a href=&quot;#optional-restrictions&quot;&gt;optional&lt;/a&gt;), *         or if the specified collection is null. * @see    #contains(Object) */boolean containsAll(Collection&lt;?&gt; c);/** * Adds all of the elements in the specified collection to this collection * (optional operation).  The behavior of this operation is undefined if * the specified collection is modified while the operation is in progress. * (This implies that the behavior of this call is undefined if the * specified collection is this collection, and this collection is * nonempty.) * * @param c collection containing elements to be added to this collection * @return &lt;tt&gt;true&lt;/tt&gt; if this collection changed as a result of the call * @throws UnsupportedOperationException if the &lt;tt&gt;addAll&lt;/tt&gt; operation *         is not supported by this collection * @throws ClassCastException if the class of an element of the specified *         collection prevents it from being added to this collection * @throws NullPointerException if the specified collection contains a *         null element and this collection does not permit null elements, *         or if the specified collection is null * @throws IllegalArgumentException if some property of an element of the *         specified collection prevents it from being added to this *         collection * @throws IllegalStateException if not all the elements can be added at *         this time due to insertion restrictions * @see #add(Object) */boolean addAll(Collection&lt;? extends E&gt; c);/** * Removes all of this collection&apos;s elements that are also contained in the * specified collection (optional operation).  After this call returns, * this collection will contain no elements in common with the specified * collection. * * @param c collection containing elements to be removed from this collection * @return &lt;tt&gt;true&lt;/tt&gt; if this collection changed as a result of the *         call * @throws UnsupportedOperationException if the &lt;tt&gt;removeAll&lt;/tt&gt; method *         is not supported by this collection * @throws ClassCastException if the types of one or more elements *         in this collection are incompatible with the specified *         collection *         (&lt;a href=&quot;#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this collection contains one or more *         null elements and the specified collection does not support *         null elements *         (&lt;a href=&quot;#optional-restrictions&quot;&gt;optional&lt;/a&gt;), *         or if the specified collection is null * @see #remove(Object) * @see #contains(Object) */boolean removeAll(Collection&lt;?&gt; c);/** * Retains only the elements in this collection that are contained in the * specified collection (optional operation).  In other words, removes from * this collection all of its elements that are not contained in the * specified collection. * * @param c collection containing elements to be retained in this collection * @return &lt;tt&gt;true&lt;/tt&gt; if this collection changed as a result of the call * @throws UnsupportedOperationException if the &lt;tt&gt;retainAll&lt;/tt&gt; operation *         is not supported by this collection * @throws ClassCastException if the types of one or more elements *         in this collection are incompatible with the specified *         collection *         (&lt;a href=&quot;#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this collection contains one or more *         null elements and the specified collection does not permit null *         elements *         (&lt;a href=&quot;#optional-restrictions&quot;&gt;optional&lt;/a&gt;), *         or if the specified collection is null * @see #remove(Object) * @see #contains(Object) */boolean retainAll(Collection&lt;?&gt; c);/** * Removes all of the elements from this collection (optional operation). * The collection will be empty after this method returns. * * @throws UnsupportedOperationException if the &lt;tt&gt;clear&lt;/tt&gt; operation *         is not supported by this collection */void clear();// Comparison and hashing/** * Compares the specified object with this collection for equality. &lt;p&gt; * * While the &lt;tt&gt;Collection&lt;/tt&gt; interface adds no stipulations to the * general contract for the &lt;tt&gt;Object.equals&lt;/tt&gt;, programmers who * implement the &lt;tt&gt;Collection&lt;/tt&gt; interface &quot;directly&quot; (in other words, * create a class that is a &lt;tt&gt;Collection&lt;/tt&gt; but is not a &lt;tt&gt;Set&lt;/tt&gt; * or a &lt;tt&gt;List&lt;/tt&gt;) must exercise care if they choose to override the * &lt;tt&gt;Object.equals&lt;/tt&gt;.  It is not necessary to do so, and the simplest * course of action is to rely on &lt;tt&gt;Object&lt;/tt&gt;&apos;s implementation, but * the implementor may wish to implement a &quot;value comparison&quot; in place of * the default &quot;reference comparison.&quot;  (The &lt;tt&gt;List&lt;/tt&gt; and * &lt;tt&gt;Set&lt;/tt&gt; interfaces mandate such value comparisons.)&lt;p&gt; * * The general contract for the &lt;tt&gt;Object.equals&lt;/tt&gt; method states that * equals must be symmetric (in other words, &lt;tt&gt;a.equals(b)&lt;/tt&gt; if and * only if &lt;tt&gt;b.equals(a)&lt;/tt&gt;).  The contracts for &lt;tt&gt;List.equals&lt;/tt&gt; * and &lt;tt&gt;Set.equals&lt;/tt&gt; state that lists are only equal to other lists, * and sets to other sets.  Thus, a custom &lt;tt&gt;equals&lt;/tt&gt; method for a * collection class that implements neither the &lt;tt&gt;List&lt;/tt&gt; nor * &lt;tt&gt;Set&lt;/tt&gt; interface must return &lt;tt&gt;false&lt;/tt&gt; when this collection * is compared to any list or set.  (By the same logic, it is not possible * to write a class that correctly implements both the &lt;tt&gt;Set&lt;/tt&gt; and * &lt;tt&gt;List&lt;/tt&gt; interfaces.) * * @param o object to be compared for equality with this collection * @return &lt;tt&gt;true&lt;/tt&gt; if the specified object is equal to this * collection * * @see Object#equals(Object) * @see Set#equals(Object) * @see List#equals(Object) */boolean equals(Object o);/** * Returns the hash code value for this collection.  While the * &lt;tt&gt;Collection&lt;/tt&gt; interface adds no stipulations to the general * contract for the &lt;tt&gt;Object.hashCode&lt;/tt&gt; method, programmers should * take note that any class that overrides the &lt;tt&gt;Object.equals&lt;/tt&gt; * method must also override the &lt;tt&gt;Object.hashCode&lt;/tt&gt; method in order * to satisfy the general contract for the &lt;tt&gt;Object.hashCode&lt;/tt&gt; method. * In particular, &lt;tt&gt;c1.equals(c2)&lt;/tt&gt; implies that * &lt;tt&gt;c1.hashCode()==c2.hashCode()&lt;/tt&gt;. * * @return the hash code value for this collection * * @see Object#hashCode() * @see Object#equals(Object) */int hashCode();</code></pre><p>}</p><p>可以看到，Collection接口定义了一些基本操作的通用方法。</p><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections作为工具类，定义了很多静态方法，</p><pre><code>sort()                        // 排序binarySearch()                // 二分查找reverse()                    // 反转unmodifiableCollection()    // 不可修改synchronizedCollection()    // 同步singleton()                    // 单例</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java分布式事务</title>
      <link href="/2018/09/09/distribute-transaction/"/>
      <url>/2018/09/09/distribute-transaction/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.infoq.cn/article/solution-of-distributed-system-transaction-consistency" target="_blank" rel="noopener">数据一致性</a></p><ol><li><p>本地事务:</p></li><li><p>JDBC事务:</p></li><li><p>XA事务: 分布式事务规范，定义了(全局)事务管理器TM(Transaction Manager)和(局部)资源管理器RM(Resource Manager)之间的接口。</p></li><li><p>JTA(Java Transaction API)事务: 符合X/Open DTP模型。在JTA中，事务管理器抽象为javax.transaction.TransactionManager接口，通过底层事务服务(JTS Java Transaction Service)实现。一般由容器进行管理。WebLogic、Websphere提供了JTA的实现和支持，Tomcat需要借助第三方框架Jotm、Automikos实现</p></li><li><p>幂等性: 针对一个操作，无论执行多少次，产生的结果和返回的结果都是一致的。常用于表单的重复提交、支付接口的调用。</p><blockquote><p>状态机幂等：有限状态机，例如：订单等单据类业务，存在很长的状态流转。</p><p>对外提供的接口保证幂等：请求接口需要携带source+seq字段，存储在数据库作唯一索引，防止多次提交。当请求过来时，先到数据库查一下，再做处理</p></blockquote></li></ol><a id="more"></a><h2 id="一致性协议解决方案："><a href="#一致性协议解决方案：" class="headerlink" title="一致性协议解决方案："></a>一致性协议解决方案：</h2><h2 id="1-事务补偿机制-TCC"><a href="#1-事务补偿机制-TCC" class="headerlink" title="1. 事务补偿机制(TCC)"></a>1. 事务补偿机制(TCC)</h2><p>业务S，对外提供服务，服务消费者M决定服务cancel还是commit</p><p>TRYING阶段：主要对业务进行检测及资源预留。</p><p>CONFIRMING阶段：业务提交，默认如果TRYING阶段执行成功，CONFIRMING阶段就一定能成功。</p><p>CANCELING阶段：业务回滚</p><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>基于web service/rpc/jms等构建的高度自治的分布式系统接口</p><h3 id="传统事务和TCC事务的区别"><a href="#传统事务和TCC事务的区别" class="headerlink" title="传统事务和TCC事务的区别"></a>传统事务和TCC事务的区别</h3><p>传统事务机制 = TCC事务机制Try + TCC事务机制Confirm</p><p>传统事务： 业务逻辑部分访问资源实现数据存储，由业务系统负责；事务处理部分通过协调资源管理器以实现事务管理，由事务管理器负责</p><p>TCC事务：业务逻辑和事务管理关系复杂。</p><p><a href="https://github.com/liuyangming/ByteTCC/" target="_blank" rel="noopener">基于TCC的ByteTCC</a></p><p><a href="https://github.com/liuyangming/ByteJTA/" target="_blank" rel="noopener">基于XA两阶段的ByteJTA</a></p><h2 id="2-两阶段提交-2PC"><a href="#2-两阶段提交-2PC" class="headerlink" title="2. 两阶段提交(2PC)"></a>2. 两阶段提交(2PC)</h2><p>Two-Phase Commit</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>第一阶段：准备阶段</p><ol><li>事务询问</li><li>执行事务</li><li>各参与者向协调者反馈事务询问的响应</li></ol><p>第二阶段：提交阶段</p><p>情况一：事务提交</p><p>情况二：中断事务</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>原理简单</li><li>实现方便</li></ol><p>缺点：</p><ol><li>同步阻塞  导致性能问题</li><li>单点问题  节点出现问题会导致事务失败，甚至事务锁定</li><li>数据不一致  节点问题会导致部分事务提交，数据不一致</li><li>太过保守  任何单点故障都会导致问题</li></ol><h2 id="3-一阶段提交-1PC"><a href="#3-一阶段提交-1PC" class="headerlink" title="3. 一阶段提交(1PC)"></a>3. 一阶段提交(1PC)</h2><p>应用场景：基于数据库分片(sharding)</p><h2 id="4-三阶段提交-3PC"><a href="#4-三阶段提交-3PC" class="headerlink" title="4. 三阶段提交(3PC)"></a>4. 三阶段提交(3PC)</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p>第一阶段：CanCommit</p><p>第二阶段：PreCommit</p><p>第三阶段：doCommit</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>降低了阻塞范围</li><li>在单点故障后继续达成一致</li></ol><p>缺点：</p><ol><li></li></ol><h2 id="5-消息队列实现-异步确保型事务"><a href="#5-消息队列实现-异步确保型事务" class="headerlink" title="5. 消息队列实现(异步确保型事务)"></a>5. 消息队列实现(异步确保型事务)</h2><p>通过MQ消息队列实现，需要保证消息的成功发送和消费。</p><h2 id="6-eBay方案-BASE理论"><a href="#6-eBay方案-BASE理论" class="headerlink" title="6. eBay方案(BASE理论)"></a>6. eBay方案(BASE理论)</h2><p>Basically Available(基本可用)，Soft state(软状态)，Eventually consistent(最终一致性)</p><p>核心：保证服务接口的幂等性。</p><p>最终一致性存在5种实现：</p><blockquote><p>因果一致性</p><p>读己之所写</p><p>会话一致性</p><p>单调读一致性</p><p>单调写一致性</p></blockquote><h4 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h4><pre><code>一种ACID的替代方案，可用性通过支持局部故障而不是全局故障来实现。1)、将多表操作放在本地事务中来完成2)、通过增加update_applied表避免重复消费用户表消息3)、读取消息队列，但不删除消息，判断updates_applied表检测相关记录是否被执行，未执行的记录会修改user表 ，然后增加操作记录到updates_applied，事务执行完成后删除队列。</code></pre><h2 id="7-最大努力通知型"><a href="#7-最大努力通知型" class="headerlink" title="7. 最大努力通知型"></a>7. 最大努力通知型</h2><pre><code>应用场景：调用第三方系统通信，例如微信支付、支付宝支付</code></pre><p><strong>建议：</strong></p><ol><li>子系统较少、负载长期稳定、无伸缩要求、考虑开发复杂度和工作量的情况下，使用分布式事务(2PC)</li><li>开发时间充裕、性能要求高的情况下，尽量采用1PC、事务补偿机制</li><li>系统使用sharding模式的情况下，不要使用分布式事务</li><li>不要在JTA事务中嵌套JDBC事务</li><li>事务要尽可能在短时间内完成，事务的嵌套要求更良好的设计</li></ol><p>参考：</p><p><a href="https://blog.csdn.net/bluishglc/article/details/7612811" target="_blank" rel="noopener">详细</a></p><p><a href="http://javaeye-mao.iteye.com/blog/1501726" target="_blank" rel="noopener">详细2</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql读写分离机制</title>
      <link href="/2018/09/08/mysql-read-write/"/>
      <url>/2018/09/08/mysql-read-write/</url>
      
        <content type="html"><![CDATA[<p>MySQL读写分离</p><h2 id="MySQL读写分离"><a href="#MySQL读写分离" class="headerlink" title="MySQL读写分离"></a>MySQL读写分离</h2><p>从库配置参数：</p><pre><code>--skip-innodb--skip-bdb--low-priority-updates--delay-key-write=ALL</code></pre><a id="more"></a><h2 id="主从复制的延迟问题"><a href="#主从复制的延迟问题" class="headerlink" title="主从复制的延迟问题"></a>主从复制的延迟问题</h2><p>由于服务器负载、网络拥堵等问题，Master和Slave之间数据一致性没有保证。</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ol><li>在master insert/update操作后强制sleep几秒</li><li>把更新的数据保存在内存/或者保存在缓存中(例如redis)，当写操作完成后，读数据直接从缓存中读取。</li><li>使用MySQL Proxy代理实现。原理：在master、slave各维护一张count_table表，当master执行insert/delete/update操作时，触发器触发count_table表字段自增。当client请求proxy服务器时，proxy先查询master+slave的count_table表，如果一致，则查询slave，否则查询master</li></ol><p>补充：安装MySQL Proxy</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中spi机制</title>
      <link href="/2018/09/07/java-spi/"/>
      <url>/2018/09/07/java-spi/</url>
      
        <content type="html"><![CDATA[<p>今天阅读dubbo源码的时候，看到SPI机制，咦？Java还有这种机制…瞬间觉得自己太弱鸡了…现在补课中</p><h2 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h2><p>定义一个通用的接口，不同的场景可以针对该接口做出不同的实现。同时需要在classpath下的META-INF/services目录下创建接口全路径对应的文件，文件的内容就是接口的实现类。</p><a id="more"></a><h2 id="SPI的实现原理"><a href="#SPI的实现原理" class="headerlink" title="SPI的实现原理"></a>SPI的实现原理</h2><p>SPI机制的实现主要是通过java.util.ServiceLoader实现的，在遍历的时候</p><pre><code>public final class ServiceLoader&lt;S&gt;implements Iterable&lt;S&gt;{private static final String PREFIX = &quot;META-INF/services/&quot;;// The class or interface representing the service being loadedprivate Class&lt;S&gt; service;// The class loader used to locate, load, and instantiate providersprivate ClassLoader loader;// Cached providers, in instantiation orderprivate LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;();// The current lazy-lookup iteratorprivate LazyIterator lookupIterator;......private class LazyIterator    implements Iterator&lt;S&gt;{    Class&lt;S&gt; service;    ClassLoader loader;    Enumeration&lt;URL&gt; configs = null;    Iterator&lt;String&gt; pending = null;    String nextName = null;    private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) {        this.service = service;        this.loader = loader;    }    public boolean hasNext() {        if (nextName != null) {            return true;        }        if (configs == null) {            try {                String fullName = PREFIX + service.getName();                if (loader == null)                    configs = ClassLoader.getSystemResources(fullName);                else                    configs = loader.getResources(fullName);            } catch (IOException x) {                fail(service, &quot;Error locating configuration files&quot;, x);            }        }        while ((pending == null) || !pending.hasNext()) {            if (!configs.hasMoreElements()) {                return false;            }            pending = parse(service, configs.nextElement());        }        nextName = pending.next();        return true;    }    public S next() {        if (!hasNext()) {            throw new NoSuchElementException();        }        String cn = nextName;        nextName = null;        Class&lt;?&gt; c = null;        try {            c = Class.forName(cn, false, loader);        } catch (ClassNotFoundException x) {            fail(service,                 &quot;Provider &quot; + cn + &quot; not found&quot;);        }        if (!service.isAssignableFrom(c)) {            fail(service,                 &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);        }        try {            S p = service.cast(c.newInstance());            providers.put(cn, p);            return p;        } catch (Throwable x) {            fail(service,                 &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,                 x);        }        throw new Error();          // This cannot happen    }    public void remove() {        throw new UnsupportedOperationException();    }}</code></pre><h2 id="SPI机制的应用"><a href="#SPI机制的应用" class="headerlink" title="SPI机制的应用"></a>SPI机制的应用</h2><p>1、典型的JDBC应用</p><p>jdk定义了java.sql.Driver接口，java.sql.DriverManager通过调用ServiceLoader实例化所有的Driver接口的实现类。</p><p>2、Dubbo框架</p><p>dubbo框架META-INF/dubbo.internal文件夹下有很多的文件，例如：com.alibaba.dubbo.rpc.Protocol，打开文件</p><pre><code>filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapperlistener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrappermock=com.alibaba.dubbo.rpc.support.MockProtocoldubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocolinjvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocolrmi=com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocolhessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocolcom.alibaba.dubbo.rpc.protocol.http.HttpProtocolcom.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocolthrift=com.alibaba.dubbo.rpc.protocol.thrift.ThriftProtocolmemcached=com.alibaba.dubbo.rpc.protocol.memcached.MemcachedProtocolredis=com.alibaba.dubbo.rpc.protocol.redis.RedisProtocolrest=com.alibaba.dubbo.rpc.protocol.rest.RestProtocolregistry=com.alibaba.dubbo.registry.integration.RegistryProtocolqos=com.alibaba.dubbo.qos.protocol.QosProtocolWrapper</code></pre><p>可以看到是对协议的不同实现</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB基础环境搭建</title>
      <link href="/2018/09/04/mongodb-base/"/>
      <url>/2018/09/04/mongodb-base/</url>
      
        <content type="html"><![CDATA[<p>可以说2015年开始接触mongodb，记得那时候看node.js比较多，那时候node.js还是0.x版本…如今早已物是人非。</p><a id="more"></a><h2 id="tar-gz安装"><a href="#tar-gz安装" class="headerlink" title="tar.gz安装"></a>tar.gz安装</h2><p>安装</p><pre><code>tar -xzvf mongodb-linux-x86_64-rhel70-4.0.2.tgzmv mongodb-linux-x86_64-rhel70-4.0.2 mongodbmkdir -p /data/db</code></pre><p>后台启动服务</p><pre><code>cd mongodb/bin./mongod &amp;</code></pre><p>进入REPL(Read-Eval-Print Loop)， 即交互式命令行shell</p><pre><code>cd mongodb/bin./mongo</code></pre><blockquote><p>show dbs</p><p>use local</p><p>db</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL基础环境搭建</title>
      <link href="/2018/09/04/postgresql-base/"/>
      <url>/2018/09/04/postgresql-base/</url>
      
        <content type="html"><![CDATA[<p>写这一篇博客的意义就是让自己保持经常写作的习惯，否则超过三天不写，就会一直拖延、逃避，不想当架构师的码农不是好程序员。</p><p>环境: CentOS7</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>yum install postgresql-server</code></pre><p>开机自启动</p><pre><code>postgresql-setup initdbsystemctl enable postgresql.servicesystemctl start postgresql.service</code></pre><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><pre><code>CREATE USER postgres WITH PASSWORD &apos;&apos;;DROP DATABASE postgres;CREATE DATABASE postgres OWNER postgres;GRANT ALL PRIVILEGES ON DATABASE postgres to postgres;ALTER ROLE postgres CREATEDB;</code></pre><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>切换用户</p><pre><code>su - postgres</code></pre><p>登录</p><pre><code>psql -U [user] -d [database] -h [host] -p [password]</code></pre><ol><li><p>默认登陆</p><pre><code>psql</code></pre></li><li><p>用户名密码登录</p><p>  psql -U postgres -d postgres</p></li></ol><p>常用REPL命令</p><pre><code>退出 Ctrl + D;\password：设置当前登录用户的密码\h：查看SQL命令的解释，比如\h select。\?：查看psql命令列表。\l：列出所有数据库。\c [database_name]：连接其他数据库。\d：列出当前数据库的所有表格。\d [table_name]：列出某一张表格的结构。\du：列出所有用户。\e：打开文本编辑器。\conninfo：列出当前数据库和连接的信息。\password [user]: 修改用户密码\q：退出</code></pre><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>创建数据库、创建表、数据操作都符合SQL语法</p>]]></content>
      
      
      <categories>
          
          <category> PostgreSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java编译器</title>
      <link href="/2018/09/02/java-jvm-compile/"/>
      <url>/2018/09/02/java-jvm-compile/</url>
      
        <content type="html"><![CDATA[<p>编译器是一门很深入的模块，完全理解需要很深厚的功底，就是所谓的”内功”，例如《编译原理》，回头接着好好撸</p><p>编译器在JJava中根据不同大致分为3部分：</p><p>前端编译器：Javac、增量编译器ECJ</p><p>JIT编译器：HotSpot中的C1(Client Compiler)、C2(Server Compiler)编译器</p><p>AOT编译器：GNU Compiler for the Java(GCJ)、Excelsior JET</p><a id="more"></a><h2 id="静态提前编译-AOT"><a href="#静态提前编译-AOT" class="headerlink" title="静态提前编译 AOT"></a>静态提前编译 AOT</h2><p>直接把.java文件编译成机器码的过程。例如：GCJ, JET</p><p>编译过程：</p><ol><li><p>解析与填充符号表</p><blockquote><p>词法、语法分析</p><p>填充符号表</p></blockquote></li><li><p>注解处理</p></li><li><p>语义分析与字节码生成</p><blockquote><p>标注检查: 实现方法JavaCompiler.attribute()–sun.tools.javac.comp.Attr/Check类</p><p>数据及控制流分析: JavaCompiler.flow()<br>解语法糖: 泛型、变长参数、自动装箱/拆箱。实现类com.sun.tools.javac.comp.TransTypes/Lower类<br>字节码生成: 把以上生成的语法树、符号表转为字节码写到磁盘，同时添加少量代码。实现类com.sun.tools.javac.jvm.Gen/ClassWriter类</p></blockquote></li></ol><h2 id="后端运行时编译-JIT"><a href="#后端运行时编译-JIT" class="headerlink" title="后端运行时编译 JIT"></a>后端运行时编译 JIT</h2><p>把字节码编译成机器码的过程。例如：C1, C2</p><p>HotSpot内置了两个即时编译器： Client Compiler(C1编译器) + Server Compiler(C2编译器)，默认jvm会根据自身版本和系统硬件环境自动选择模式。<br>默认使用解释器 + 编译器混合模式。</p><p>-client: 强制Client模式</p><p>-server: 强制Server模式</p><p>-Xint: 强制使用解释模式</p><p>-Xcomp: 强制使用编译模式</p><p>分层编译：</p><ol><li>第0层</li><li>第1层</li><li>第2层</li></ol><p>JDK1.7 Server模式下默认开启分层编译。</p><p>热点代码：</p><p>栈上替换(OSR编译)</p><p>热点探测：判断一段代码是不是热点代码，是不是需要即时编译的行为。</p><blockquote><p>基于采样的热点探测：周期性的检查各个线程的栈顶</p><p>基于计数器的热点探测：建立计数器，统计方法的执行次数。</p></blockquote><p>HotSpot采用基于计数器探测，为每个方法准备了:方法调用计数器; 回边计数器</p><ol><li><p>方法调用计数器：统计方法被调用次数</p><p> -XX: CompileThreshold 设置方法被调用次数的阈值    </p><p> -XX: -UseCounterDecay  设置关闭热度衰减</p><p> -XX: CounterHalfLifeTime 设置版帅周期的时间</p></li><li><p>回边计数器：统计一个方法中循环体代码执行次数</p><p> -XX: BackEdgeThreshold 类似于CompileThreshold</p><p> -XX: OnStackReplacePercentage OSR比率，Client模式和Server下 默认值不同</p></li></ol><p>编译优化：</p><ol><li>公共子表达式消除</li><li>数组范围检查</li><li>方法内联</li><li>逃逸分析</li></ol><p>Java编译器和C/C++编译器的对比：</p><p>优点：</p><blockquote><p>调用频率预测</p><p>分支频率预测</p><p>裁剪未被选择的分支</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群模式</title>
      <link href="/2018/09/01/redis-cluster/"/>
      <url>/2018/09/01/redis-cluster/</url>
      
        <content type="html"><![CDATA[<h2 id="Codis集群"><a href="#Codis集群" class="headerlink" title="Codis集群"></a>Codis集群</h2><h2 id="ruby集群"><a href="#ruby集群" class="headerlink" title="ruby集群"></a>ruby集群</h2>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从模式</title>
      <link href="/2018/09/01/redis-master-slave/"/>
      <url>/2018/09/01/redis-master-slave/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis主从复制原理"><a href="#Redis主从复制原理" class="headerlink" title="Redis主从复制原理"></a>Redis主从复制原理</h2><pre><code>Redis使用异步复制复制在master和slave是非阻塞模式，即在执行同步时仍然可以提供查询</code></pre><h3 id="Redis复制工作原理："><a href="#Redis复制工作原理：" class="headerlink" title="Redis复制工作原理："></a>Redis复制工作原理：</h3><ol><li>如果设置了一个Slave，无论是第一次连接还是重连到Master，它都会发出一个SYNC命令；</li><li>当Master收到SYNC命令之后，会做两件事：<br> a) Master执行BGSAVE，即在后台保存数据到磁盘（rdb快照文件）；<br> b) Master同时将新收到的写入和修改数据集的命令存入缓冲区（非查询类）；</li><li>当Master在后台把数据保存到快照文件完成之后，Master会把这个快照文件传送给Slave，而Slave则把内存清空后，加载该文件到内存中；</li><li>而Master也会把此前收集到缓冲区中的命令，通过Reids命令协议形式转发给Slave，Slave执行这些命令，实现和Master的同步；</li><li>Master/Slave此后会不断通过异步方式进行命令的同步，达到最终数据的同步一致；</li><li>需要注意的是Master和Slave之间一旦发生重连都会引发全量同步操作。但在2.8之后版本，也可能是部分同步操作。</li></ol><h3 id="完全同步、部分同步"><a href="#完全同步、部分同步" class="headerlink" title="完全同步、部分同步"></a>完全同步、部分同步</h3><p>psync部分重新同步：是指redis因某种原因引起复制中断后，从库重新同步时，只同步主实例的差异数据(写入指令），不进行bgsave复制整个RDB文件</p><p>fullsync导致的问题：复制闪断导致的抖动现象</p><p>列举几个fullsync常见的影响：<br>    master需运行bgsave,出现fork()，可能造成master达到毫秒或秒级的卡顿(latest_fork_usec状态监控)；<br>    redis进程fork导致Copy-On-Write内存使用消耗(后文简称COW)，最大能导致master进程内存使用量的消耗。(eg 日志中输出 RDB: 5213 MB of memory used by copy-on-write)<br>    redis slave load RDB过程，会导致复制线程的client output buffer增长很大；增大Master进程内存消耗；<br>    redis保存RDB(不考虑disless replication),导致服务器磁盘IO和CPU(压缩)资源消耗<br>    发送数GB的RDB文件,会导致服务器网络出口爆增,如果千兆网卡服务器，期间会影响业务正常请求响应时间(以及其他连锁影响)</p><p>psync1的部分同步机制，<br>    有效解决了网络环境不稳定、redis执行高时间复杂度的命令引起的复制中断，从而导致全量同步。但在应对slave重启和Master故障切换的场景时，psync1还是需进行全量同步。</p><p>psync2主要让redis在从实例重启和主实例故障切换场景下，也能使用部分重新同步    </p><p>部分同步的原理：</p><ol><li>主从服务器的复制偏移量offset</li><li>主服务器的复制积压缓存区：固定长度的FIFO队列，默认大小1MB</li><li>PID</li></ol><p>从服务器和主服务器进行第一次复制时，主服务器会将自己的运行ID传递给从服务器，从服务器将这个ID保存起来。重连后从服务器将服务器运行ID发送给主服务器，主服务器验证是否是自己的运行ID。</p><p>场景1：从服务器断线，重连主服务器</p><p>场景2：主服务器宕机，重新启动</p><p>命令传播阶段</p><pre><code>心跳检测</code></pre><h3 id="主观下线、客观下线"><a href="#主观下线、客观下线" class="headerlink" title="主观下线、客观下线"></a>主观下线、客观下线</h3><h3 id="Sentinel选主"><a href="#Sentinel选主" class="headerlink" title="Sentinel选主"></a>Sentinel选主</h3><p>Raft算法实现</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><h2 id="主从从模式"><a href="#主从从模式" class="headerlink" title="主从从模式"></a>主从从模式</h2>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-bean-xml</title>
      <link href="/2018/08/31/spring-bean-xml/"/>
      <url>/2018/08/31/spring-bean-xml/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-web-xml</title>
      <link href="/2018/08/31/spring-web-xml/"/>
      <url>/2018/08/31/spring-web-xml/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java动态代理</title>
      <link href="/2018/08/30/java-dynamic-proxy/"/>
      <url>/2018/08/30/java-dynamic-proxy/</url>
      
        <content type="html"><![CDATA[<p>代理模式可以将具体的实现与调用方法解耦，将具体的实现隐藏在内部。升华就是由实践上升到理论的过程，要能把所有的东西讲明白。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在编译阶段将接口、实现类、代理类全部编译完成。</p><a id="more"></a><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在程序运行期间根据需要动态的创建代理类及其实例。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理;<br>只能对实现了接口的类生成代理，而不能针对类</p><p>JDK代理要求：</p><pre><code>实现InvocationHandler接口使用Proxy.newProxyInstance产生代理对象被代理的对象必须实现接口，如果该对象没有实现接口则不能生成代理对象</code></pre><p>案例：</p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><h3 id="ASM字节码"><a href="#ASM字节码" class="headerlink" title="ASM字节码"></a>ASM字节码</h3><h3 id="Javassist库"><a href="#Javassist库" class="headerlink" title="Javassist库"></a>Javassist库</h3><h4 id="为什么需要动态代理？"><a href="#为什么需要动态代理？" class="headerlink" title="为什么需要动态代理？"></a>为什么需要动态代理？</h4><ol><li>需要动态的增强具体业务的逻辑，比如AOP</li><li>业务增强逻辑相同，可以统一处理。例如log管理、权限认证</li><li>可以灵活地控制被代理类，很好的解耦</li></ol><h2 id="代理在Spring中的应用"><a href="#代理在Spring中的应用" class="headerlink" title="代理在Spring中的应用"></a>代理在Spring中的应用</h2><p>JDK代理和CGLIB代理在Spring中的应用：</p><blockquote><p>如果对象实现了接口，则默认采用JDK代理实现AOP</p><p>如果对象没有实现接口，则必须采用CGLIB代理实现AOP</p></blockquote><p>强制使用CGLIB实现AOP：</p><pre><code>添加CGLIB库，cglib/*.jar在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch搜索</title>
      <link href="/2018/08/29/elastic-base/"/>
      <url>/2018/08/29/elastic-base/</url>
      
        <content type="html"><![CDATA[<p>去年接触过一些ELK环境的搭建，用来处理日志信息，涉及到的东西很多，回头慢慢整理，今天先回顾一下ES</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>依赖于JDK，对jdk版本、内存有要求，否则会启动失败</p><h3 id="tar-gz安装"><a href="#tar-gz安装" class="headerlink" title="tar.gz安装"></a>tar.gz安装</h3><p>需要创建用户组、用户、非root用户启动</p><h3 id="rpm安装"><a href="#rpm安装" class="headerlink" title="rpm安装"></a>rpm安装</h3><ol><li><p>直接安装，默认创建用户组</p><pre><code>rpm -ivh elasticsearch-6.4.0.rpm</code></pre><p> 提示</p><pre><code>正在升级/安装...   1:elasticsearch-0:6.4.0-1          ################################# [100%]### NOT starting on installation, please execute the following statements to configure elasticsearch service to start automatically using systemd sudo systemctl daemon-reload sudo systemctl enable elasticsearch.service### You can start elasticsearch service by executing sudo systemctl start elasticsearch.serviceCreated elasticsearch keystore in /etc/elasticsearch</code></pre></li><li><p>修改配置文件</p><p> 配置文件一般存放在/etc/elasticsearch目录下</p><pre><code>vi elasticsearch.yml开启远程访问network.host 0.0.0.0修改端口</code></pre></li></ol><ol start="3"><li><p>启动服务</p><pre><code>sudo systemctl daemon-reloadsudo systemctl enable elasticsearch.servicesudo systemctl start elasticsearch.service</code></pre></li></ol><ol start="4"><li><p>测试启动状态</p><pre><code>netstat -lntp | grep -E &quot;9200|9300&quot;</code></pre></li></ol><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code>curl -X&lt;REST Verb&gt; &lt;Node&gt;:&lt;Port&gt;/&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt;</code></pre><p>参数：</p><p>　　<rest verb>：REST风格的语法谓词</rest></p><p>　　<node>:节点ip</node></p><p>　　<port>:节点端口号，默认9200</port></p><p>　　<index>:索引名</index></p><p>　　<type>:索引类型</type></p><p>　　<id>:操作对象的ID号</id></p><p>查看健康状态</p><pre><code>curl &apos;localhost:9200/_cat/health?v&apos;epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1535546872 20:47:52  elasticsearch yellow          1         1      5   5    0    0        5             0                  -                 50.0%</code></pre><p>查看节点列表</p><pre><code>curl &apos;localhost:9200/_cat/nodes?v&apos;ip              heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name192.168.117.133           22          32   2    0.00    0.02     0.05 mdi       *      M48aNzY</code></pre><p>查看索引列表</p><pre><code>curl &apos;localhost:9200/_cat/indices?v&apos;health status index    uuid                   pri rep docs.count docs.deleted store.size pri.store.sizeyellow open   customer FWs0PsZ0QAOJZ0W6l-HhLA   5   1          0            0      1.2kb          1.2kb</code></pre><p>创建索引</p><pre><code>curl -XPUT &apos;localhost:9200/customer?pretty&apos;  url -XPUT &apos;localhost:9200/customer/external/1?pretty&apos; -d &apos;{&quot;name&quot;: &quot;John Doe&quot;}&apos; curl -H &quot;Content-Type: application/json&quot; -XPOST http://localhost:9200/kiwi/ksay/ -d &apos;{ &quot;author&quot;: &quot;rococojie&quot;, &quot;message&quot;: &quot;I am beautiful&quot;}&apos;curl -H &quot;Content-Type: application/json&quot; -XPOST http://localhost:9200/kiwi/ksay/1 -d &apos;{&quot;author&quot;: &quot;jerry&quot;, &quot;message&quot;: &quot;I hate Tom&quot;}&apos;</code></pre><p>删除索引</p><pre><code>curl -XDELETE &apos;localhost:9200/customer?pretty&apos;</code></pre><p>修改索引</p><pre><code>curl -XPUT &apos;localhost:9200/customer/external/1?pretty&apos; -d &apos;{&quot;name&quot;: &quot;John Doe&quot;}&apos;curl -XPOST &apos;localhost:9200/customer/external/1/_update?pretty&apos; -d &apos;{&quot;doc&quot;: { &quot;name&quot;: &quot;Jane Doe&quot; }}&apos;</code></pre><p>获取指定索引</p><pre><code>curl -XGET &apos;localhost:9200/customer/external/1?pretty&apos;</code></pre><p>如果想通过远程浏览器访问，需要修改elasticsearch.yml文件。rpm安装的elasticsearch.yml存放在/etc/elasticsearch/文件夹下。如果找不到，可以通过rpm -ql elasticsearch查找。</p><pre><code>network.host 0.0.0.0</code></pre><p>web界面化管理可以使用GitHub上开源的elasticsearch-head。</p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSL、TLS、HTTPS协议</title>
      <link href="/2018/08/28/ssl-tls/"/>
      <url>/2018/08/28/ssl-tls/</url>
      
        <content type="html"><![CDATA[<h2 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h2><p>SSL1.0 已废除</p><p>SSL2.0 已废除</p><p>SSL3.0 基本废除</p><p>Secure Socket Layer，安全套接字：位于可靠的面向连接的网络层协议(TCP/IP)和应用层协议之间。</p><blockquote><p>SSL记录协议：建立在可靠的传输协议(TCP协议)之上，实现封装、压缩、加密</p><p>SSL握手协议：建立在SSL记录协议之上，实现身份认证、协商加密算法、交换加密密钥</p></blockquote><h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h3><h2 id="TLS协议"><a href="#TLS协议" class="headerlink" title="TLS协议"></a>TLS协议</h2><p>TLS1.0 </p><p>TLS1.1</p><p>TLS1.2 目前大多采用</p><p>TLS1.3</p><p>Transport Layer Security，传输层安全协议：用于两个应用程序之间提供保密性、数据完整性。</p><blockquote><p>TLS记录协议：是一种分层协议。</p><p>TLS握手协议：由3个子协议构成，</p></blockquote><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTP + SSL/TLS</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><a href="https://blog.csdn.net/ustccw/article/details/76691248" target="_blank" rel="noopener">https://blog.csdn.net/ustccw/article/details/76691248</a></p><p><a href="https://www.cnblogs.com/zhangshitong/p/6478721.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangshitong/p/6478721.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka环境搭建</title>
      <link href="/2018/08/28/kafka-base/"/>
      <url>/2018/08/28/kafka-base/</url>
      
        <content type="html"><![CDATA[<p>去年使用消息队列时接触到Apache Apollo，是IBM用Scala语言开发的，适用于物联网行业。kafka作为消息队列，大多使用在互联网行业，幸运的是也是用Scala语言开发的。</p><h2 id="单节点kafka"><a href="#单节点kafka" class="headerlink" title="单节点kafka"></a>单节点kafka</h2><ol><li><p>安装包</p><p> kafka_2.11-2.0.0.tgz<br> tar -xzvf kafka_2.11-2.0.0.tgz<br> mv kafka_2.11-2.0.0.tgz kafka</p></li></ol><a id="more"></a><ol start="2"><li><p>启动zk</p><p> 1)、可以使用独立的zk</p><p> 2)、也可以使用kafka内嵌的zk，启动命令</p><pre><code>bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</code></pre></li><li><p>启动Kafka，同时注册到zk上</p><pre><code>bin/kafka-server-start.sh config/server.properties</code></pre></li><li><p>创建topic(test)</p><pre><code>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</code></pre></li><li><p>查看topic</p><pre><code>bin/kafka-topics.sh --list --zookeeper localhost:2181</code></pre></li><li><p>生产消息(可以新起一个terminal)</p><pre><code>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test </code></pre></li><li><p>消费消息(新起一个terminal)</p><p> 旧版本</p><pre><code>bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning</code></pre><p> 新版本</p><pre><code>bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</code></pre><p> <strong>注意：</strong>这里可能会遇到问题，旧版本启动参数和新版本参数不一样，根据提示修改即可</p></li></ol><h2 id="Kafka和zk的关系"><a href="#Kafka和zk的关系" class="headerlink" title="Kafka和zk的关系"></a>Kafka和zk的关系</h2><p>Kafka是一个分布式消息系统，多broker就需要一个管理中心，zk作为注册中心，所有的broker、topics都会注册到zk上，进入zk可以看一下：</p><p>查看根节点：</p><pre><code>ls /cluster, controller, controller_epoch, brokers, zookeeper, admin, isr_change_notification, consumers, log_dir_event_notification, latest_producer_id_block, config]</code></pre><p>查看brokers节点：</p><pre><code>ls /brokers[ids, topics, seqid]</code></pre><p>查看broker0:</p><pre><code>get /brokers/ids/0{&quot;listener_security_protocol_map&quot;:{&quot;PLAINTEXT&quot;:&quot;PLAINTEXT&quot;},&quot;endpoints&quot;:[&quot;PLAINTEXT://localhost:9092&quot;],&quot;jmx_port&quot;:-1,&quot;host&quot;:&quot;localhost&quot;,&quot;timestamp&quot;:&quot;1535447121995&quot;,&quot;port&quot;:9092,&quot;version&quot;:4}cZxid = 0x2ectime = Tue Aug 28 17:05:22 CST 2018mZxid = 0x2emtime = Tue Aug 28 17:05:22 CST 2018pZxid = 0x2ecversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x1657f0bf1b60003dataLength = 188numChildren = 0</code></pre><p>查看topics:</p><pre><code>ls /brokers/topics[test, __consumer_offsets]</code></pre><p>查看主题test:</p><pre><code>get /brokers/topics/test             {&quot;version&quot;:1,&quot;partitions&quot;:{&quot;0&quot;:[0]}}cZxid = 0x38ctime = Tue Aug 28 17:06:39 CST 2018mZxid = 0x38mtime = Tue Aug 28 17:06:39 CST 2018pZxid = 0x3acversion = 1dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 36numChildren = 1</code></pre><h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper概览(一)</title>
      <link href="/2018/08/28/zk-base/"/>
      <url>/2018/08/28/zk-base/</url>
      
        <content type="html"><![CDATA[<p>ZooKeeper环境搭建，把以前的东西整理一下，</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="特性-语义"><a href="#特性-语义" class="headerlink" title="特性/语义"></a>特性/语义</h3><ol><li>顺序性：客户端发起的更新操作会按照发送顺序在zk上执行</li><li>原子性：zk操作要么成功，要么失败，不会有中间状态</li><li>可靠性：客户端请求的操作一旦被接受，不会意外丢失，除非被覆盖</li><li>最终一致性：写操作最终会对客户端可见(并非实时一致性)</li></ol><h3 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h3><ol><li>Leader：zk集群中只能同时有一个leader，<br> 它会发起并维护和各follower、observer之间的心跳<br> 所有的写操作必须由leader完成，leader写入本地日志后，再将写操作广播给follower、observer</li><li>Follower：一个zk集群可能有多个follower，它会响应leader的心跳<br> follower可以直接处理客户端的读请求，并将写请求转发给leader处理<br> 在leader处理写请求的时候对请求进行投票()</li><li>Observer： 角色与follower类似，但无投票权</li></ol><h3 id="watch机制"><a href="#watch机制" class="headerlink" title="watch机制"></a>watch机制</h3><p>客户端所有对zk的读操作，都会有一个Watch，数据改变时，该watch机制被触发<br>特点：</p><blockquote><p>主动推送：zk服务器<strong>主动</strong>将更新推送给客户端<br>一次性：数据变化时，只会被触发一次。如果客户端想要继续监听，必须重新注册一个新的watch<br>可见性：<br>顺序性：如果多个更新触发了watch机制，watch的顺序执行</p></blockquote><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>zk的节点类型是一个文件系统的树形结构。</p><ol><li><p>永久节点、临时节点</p><blockquote><p>永久节点：一旦创建，不会丢失，服务端重启后仍然存在。既可以包含数据，也可以包含子节点<br>临时节点：客户端和服务端session会话结束，节点被删除。服务端重启后，节点消失</p></blockquote></li><li><p>顺序节点、非顺序性节点</p><blockquote><p>顺序节点：节点名在名称后带有10位10进制序号，多个客户端可以创建名称一样的节点，后面序号递增<br>非顺序节点：客户端只能创建名称不同的节点。</p></blockquote></li></ol><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol><li>分布式锁</li></ol><h2 id="单节点环境"><a href="#单节点环境" class="headerlink" title="单节点环境"></a>单节点环境</h2><p>单节点的安装可以增加用户，而不是使用root用户启动。</p><ol><li><p>下载安装包、解压缩</p><p> zookeeper-3.4.10.tar.gz</p></li><li><p>修改配置文件zoo.cfg</p><p> zk提供了zoo_sample.cfg在conf目录下，可以增加data、log目录，也可以直接使用模板文件。</p><pre><code>cp zoo_sample.cfg zoo.cfg</code></pre></li></ol><ol start="3"><li><p>启动服务端server</p><p> 服务端启动可以默认启动</p><pre><code>bin/zkServer.sh start</code></pre></li><li><p>启动客户端client</p><p> 客户端可以默认启动，也可以指定服务器参数</p><pre><code>bin/zkCli.shbin/zkCli.sh -server 127.0.0.1:2181</code></pre><p> 1). 创建节点</p><p> 语法 </p><pre><code>create [-s] [-e] path data acl</code></pre><p> “-s”表示创建一个”有序”节点; “-e”表示创建一个临时节点.【默认为持久性节点】</p><pre><code>create /test null  create -s /test null </code></pre><p> ACL授权方式为”digest”,其中授权的用户名:密码为”test:Kk3Nr5X06NH+XdlGMyOrULgK/mo=”,ACL的权限列表为”r””w””c””d””a”.</p><pre><code>create -s /test null digest:test:Kk3Nr5X06NH+XdlGMyOrULgK/mo=:rwcdacreate /mykey1 myvalue1create /mykey2 myvalue2    </code></pre><p> 2). 删除节点</p><p> 删除所有节点</p><pre><code>rmr &lt;path&gt;    #删除&quot;/test&quot;以及其下的所有子节点.</code></pre><p> 删除指定节点 </p><pre><code>delete &lt;path&gt; [version]delete /test -1   #如果此path下还有子节点,将导致删除失败.这是和&quot;rmr&quot;指令的区别.</code></pre><p> 3). 修改节点</p><pre><code>set path data [version]set /test 1313131 -1  #如果版本号为&quot;-1&quot;表示更新时忽略版本校验.</code></pre><p> 节点设置ACL权限</p><pre><code>setAcl path aclsetAcl /test digest:test:Kk3Nr5X06NH+XdlGMyOrULgK/mo=:rwcda </code></pre></li></ol><pre><code>4). 查看节点数据    get /mykey15). 添加授权信息</code></pre><h2 id="集群环境"><a href="#集群环境" class="headerlink" title="集群环境"></a>集群环境</h2>]]></content>
      
      
      <categories>
          
          <category> ZooKeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式之分布式锁</title>
      <link href="/2018/08/28/distribute-lock/"/>
      <url>/2018/08/28/distribute-lock/</url>
      
        <content type="html"><![CDATA[<p>CAP理论：</p><p>C Consistency 一致性</p><p>A Availability 可用性</p><p>P Partition tolerance 容错性</p><a id="more"></a><h2 id="分布式锁要求："><a href="#分布式锁要求：" class="headerlink" title="分布式锁要求："></a>分布式锁要求：</h2><p>排他性：在同一时间只会有一个客户端能获取到锁，其它客户端无法同时获取</p><p>避免死锁：这把锁在一段有限的时间之后，一定会被释放（正常释放或异常释放）</p><p>高可用：获取或释放锁的机制必须高可用且性能佳</p><p>非阻塞：没有获取到锁直接返回获取锁失败</p><h2 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h2><p><a href="https://juejin.im/post/5c05f233e51d4524860fc51a" target="_blank" rel="noopener">参考1</a></p><p><a href>参考2</a></p><h3 id="1-基于数据库"><a href="#1-基于数据库" class="headerlink" title="1. 基于数据库"></a>1. 基于数据库</h3><h4 id="有多种实现方式："><a href="#有多种实现方式：" class="headerlink" title="有多种实现方式："></a>有多种实现方式：</h4><p>基于乐观锁：通过维护数据的版本号(version)实现</p><pre><code>update table_xxx set name=#name#,version=version+1 where version=#version#</code></pre><p>通过条件限制(适用于库存模型、扣除份额、回滚份额，性能更好)</p><pre><code>update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# &gt;= 0    </code></pre><p>都可以通过增加主键索引、唯一索引来优化：</p><pre><code>update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version#update table_xxx set avai_amount=avai_amount-#subAmount# where id=#id# and </code></pre><p>avai_amount-#subAmount# &gt;= 0</p><p>基于悲观锁：</p><pre><code>select * from tablename for update;</code></pre><p>缺点：</p><blockquote><p>数据库的可用性、性能对分布式锁影响很大</p><p>不具备可重入性。锁释放前，行数据一直存在。</p><p>没有锁失效机制。web服务宕机，导致锁未释放</p></blockquote><h3 id="2-基于Redis、Memcached、tair缓存"><a href="#2-基于Redis、Memcached、tair缓存" class="headerlink" title="2. 基于Redis、Memcached、tair缓存"></a>2. 基于Redis、Memcached、tair缓存</h3><p>主要依赖于redis自身的原子操作。</p><p><strong>注意：</strong>redis集群模式的分布式锁，可以采用Redlock机制。对应的Java框架Redisson。</p><p>优点：</p><p>缺点：</p><h3 id="3-基于ZooKeeper"><a href="#3-基于ZooKeeper" class="headerlink" title="3. 基于ZooKeeper"></a>3. 基于ZooKeeper</h3><p>使用zk的临时节点来实现分布式锁。</p><p>优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。</p><p>缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。</p><p><a href="http://curator.apache.org/" target="_blank" rel="noopener">Curator框架</a></p><p><a href="https://blog.csdn.net/xlgen157387/article/details/79036337" target="_blank" rel="noopener">https://blog.csdn.net/xlgen157387/article/details/79036337</a></p><p><a href="https://www.cnblogs.com/austinspark-jessylu/p/8043726.html" target="_blank" rel="noopener">https://www.cnblogs.com/austinspark-jessylu/p/8043726.html</a></p><p><a href="https://blog.csdn.net/T1DMzks/article/details/78463098" target="_blank" rel="noopener">https://blog.csdn.net/T1DMzks/article/details/78463098</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell常用命令之awk</title>
      <link href="/2018/08/27/shell-awk/"/>
      <url>/2018/08/27/shell-awk/</url>
      
        <content type="html"><![CDATA[<p>awk同样作为高级命令，需要不断地完善</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>用法：</p><pre><code>awk [POSIX or GNU style options] -f progfile [--] file ...awk [POSIX or GNU style options] [--] &apos;program&apos; file ...</code></pre><p>选项：</p><a id="more"></a><p>POSIX options:        GNU long options: (standard)</p><pre><code>-f progfile        --file=progfile-F fs            --field-separator=fs-v var=val        --assign=var=val</code></pre><p>Short options:        GNU long options: (extensions)</p><pre><code>-b            --characters-as-bytes-c            --traditional-C            --copyright-d[file]        --dump-variables[=file]-e &apos;program-text&apos;    --source=&apos;program-text&apos;-E file            --exec=file-g            --gen-pot-h            --help-L [fatal]        --lint[=fatal]-n            --non-decimal-data-N            --use-lc-numeric-O            --optimize-p[file]        --profile[=file]-P            --posix-r            --re-interval-S            --sandbox-t            --lint-old-V            --version</code></pre><p>案例：</p><pre><code>eg: 找出文件2到5行内容awk &apos;{if(NR&gt;=2 &amp;&amp; NR &lt;=4) print $5}&apos; nginx.log</code></pre><h4 id="BEGIN、END模块"><a href="#BEGIN、END模块" class="headerlink" title="BEGIN、END模块"></a>BEGIN、END模块</h4><pre><code>eg: 统计用户数量awk &apos;{count++;print $0;} END{print &quot;user count is: &quot;, count}&apos; /etc/passwd</code></pre><p>命名符：<br>FS: 定义字段，如：’FS=\n’表示每个字段占据一行<br>RS: 分隔符变量，如：’RS=””‘表示记录分隔符为空白行</p><pre><code>awk &apos;BEGIN{FS=&quot;\n&quot;; RS=&quot;&quot;}{print $1&quot;,&quot;$2&quot;,&quot;$3}&apos; awk-hello-3.txt </code></pre><p>NF: 字段数量 (即列数)<br>NR: 记录数量（即行数）<br>OFS: 输出字段分隔符(即$1和$2之间填充OFS)</p><pre><code>awk &apos;BEGIN{FS=&quot;:&quot;;OFS=&quot;#&quot;}{print $1,$2,$3}&apos; awk-hello.txt</code></pre><p>ORS: 输出记录分隔符(即每次print后打印’\n\n’)</p><pre><code>awk &apos;BEGIN{FS=&quot;\n&quot;; RS=&quot;&quot;; ORS=&quot;\n\n&quot;}{print $1&quot;,&quot;$2&quot;,&quot;$3}&apos; awk-hello-2.txt</code></pre><h2 id="gawk、nawk和awk"><a href="#gawk、nawk和awk" class="headerlink" title="gawk、nawk和awk"></a>gawk、nawk和awk</h2><p>gawk是awk的GPL版</p><p>nawk(new awk)是awk的增强版，增加了很多函数</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux, shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell常用命令之sed</title>
      <link href="/2018/08/27/shell-sed/"/>
      <url>/2018/08/27/shell-sed/</url>
      
        <content type="html"><![CDATA[<p>sed是一个比较高级的命令，回头再细细整理</p><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>用法: sed [选项]… {脚本(如果没有其他脚本)} [输入文件]…</p><p>选项：</p><a id="more"></a><pre><code>-n, --quiet, --silent             取消自动打印模式空间-e 脚本, --expression=脚本             添加“脚本”到程序的运行列表-f 脚本文件, --file=脚本文件             添加“脚本文件”到程序的运行列表--follow-symlinks             直接修改文件时跟随软链接-i[SUFFIX], --in-place[=SUFFIX]             edit files in place (makes backup if SUFFIX supplied)-c, --copy             use copy instead of rename when shuffling files in -i mode-b, --binary             does nothing; for compatibility with WIN32/CYGWIN/MSDOS/EMX (             open files in binary mode (CR+LFs are not treated specially))-l N, --line-length=N             指定“l”命令的换行期望长度--posix             关闭所有 GNU 扩展-r, --regexp-extended             在脚本中使用扩展正则表达式-s, --separate             将输入文件视为各个独立的文件而不是一个长的连续输入-u, --unbuffered             从输入文件读取最少的数据，更频繁的刷新输出-z, --null-data             separate lines by NUL characters--help             display this help and exit--version             output version information and exit</code></pre><p>命令：</p><pre><code>a    新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c    取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d    删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i    插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p    列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～s    取代，通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g n    读取下一个输入行, 用下一个命令处理新的行</code></pre><p>替换标记：</p><pre><code> g    表示行内全面替换p    表示打印行w    表示把行写入一个文件x    表示互换模快板中的文本和缓冲区中的文本y    表示把一个字符翻译为另外的字符(不用于正则表达式)</code></pre><p>常用案例：</p><h2 id="sed中n、N的区别"><a href="#sed中n、N的区别" class="headerlink" title="sed中n、N的区别"></a>sed中n、N的区别</h2><p><a href="https://www.cnblogs.com/fhefh/archive/2011/11/14/2248942.html" target="_blank" rel="noopener">sed模式空间</a></p><h2 id="sed中N-D-P的使用"><a href="#sed中N-D-P的使用" class="headerlink" title="sed中N,D,P的使用"></a>sed中N,D,P的使用</h2><p><a href="http://blog.chinaunix.net/uid-22556372-id-1773472.html" target="_blank" rel="noopener">sed中N,D,P组合</a></p><p>N: 将当前读入行的下一行读取到当前的模式空间</p><p>P: 打印当前模式空间中的第一行</p><p>D: 删除当前模式空间中的第一行，重新开始下一次循环</p><pre><code>sed &apos;N;$!D&apos; numsed &apos;N;P&apos; numsed &apos;N;p&apos; numsed &apos;N;D&apos; numsed &apos;N;d&apos; numsed &apos;N;p;D&apos; num</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux, shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell常用命令之grep</title>
      <link href="/2018/08/27/shell-grep/"/>
      <url>/2018/08/27/shell-grep/</url>
      
        <content type="html"><![CDATA[<p>一些常用的shell命令、参数还是需要整理一下，以防每次都要去查询</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="基本的正则表达式："><a href="#基本的正则表达式：" class="headerlink" title="基本的正则表达式："></a>基本的正则表达式：</h3><ol><li>元字符： </li></ol><a id="more"></a><pre><code>&apos;.&apos;:匹配任意单个字符     eg：查找包含student且student后面带一个字符的行     grep ‘student.’ /etc/passwd （模式可以用单引号和双引号，如果模式中要做变量替换时则必须用双引）      &apos;[]&apos;:匹配指定范围内的任意单个字符,[abc],[a-z],[0-9],[a-zA-Z]     eg：查找带有数字的行     grep ‘[0-9]’ /etc/passwd &apos;[^]&apos;:匹配指定范围外的任意单个字符     eg：查找没有小写字母的行。     grep ‘[^a-z]’ /etc/inittab [:space:]:表示空白字符 [:punct:]:表示所有标点符号的集合 [:lower:]:表示所有的小写字母 [:upper:]:表示所有的大写字母 [:alpha:]:表示大小写字母 [:digit:]:表示数子 [:alnum:]:表示数字和大小写字母-----使用格式[[:alnum:]]等 </code></pre><ol start="2"><li><p>次数匹配： </p><p> ‘*’:匹配其前面的字符任意次 </p><pre><code>eg：查找root出现0次或0次以上的行 grep ‘root*’ /etc/passwd </code></pre><p> ‘.*’:任意字符  </p><pre><code>eg：查找包含root的行 grep &apos;root.*&apos; /etc/passwd </code></pre><p> ‘\?’：匹配其前面的字符1次或0次 </p><p> ‘{m,n}‘:匹配其前字符最少m，最多n次） </p></li><li><p>字符锚定： </p><p> ‘^’:锚定行首，此字符后面的任意内容必须出现在行首 </p><pre><code>eg：查找行首以#开头的行 grep &apos;^#&apos; /etc/inittab </code></pre><p> ‘$’:锚定行尾，此字符前面的任意内容必须出现在行尾 </p><pre><code>eg：查找行首以root结尾的行 grep &apos;root$&apos; /etc/inittab   </code></pre><p> ‘^$’:锚定空白行，可以统计空白行 </p><p> ‘\&lt;或者\b’:锚定词首，其后面的任意字符必须做为单词首部出现 </p><pre><code>eg:查找root且root前面不包含任何字符的行 grep &apos;\&lt;root&apos; /etc/man.config </code></pre><p> ‘>或者\b’:锚定词尾，其前面的任意字符必须做为单词尾部出现                         </p><pre><code>eg：\&lt;root\&gt; 查找root单词  grep &quot;\&lt;root\&gt;&quot; =grep &quot;\broot\b&quot; </code></pre></li></ol><h3 id="扩展的正则表达式"><a href="#扩展的正则表达式" class="headerlink" title="扩展的正则表达式:"></a>扩展的正则表达式:</h3><p>扩展的正则表达只是在基本的正则表达上作出了小小的一点修改，其修改如下： </p><p>在扩展的正则表达中把’ ‘写成’()’; ‘{ }‘写成’{ }’，</p><p>另外加入了:</p><p>+：次数匹配，匹配其前面的字符至少出现一次，无上限、</p><p>|: 或者(二取一）</p><p>其余的都一样， 基本正则表达式，使用’(‘、 ‘)’ ‘{‘ ‘}’ ‘.’ ‘?’ ‘|’都需要转义,在扩展正则表达中不需要加. </p><ol><li><p>字符匹配的命令和用法与基本正则表达式的用法相同，这里不再重复阐述。 </p></li><li><p>次数匹配： </p><p> ‘*’:匹配其前面字符的任意次 </p><p> ‘?’:匹配其前面字符的0此或着1此 </p><p> ‘+’:匹配其前面字符至少1此 </p><p> fg：至少一个空白符： ‘[[:space:]]+’ </p><p> {m,n} :匹配其前面字符m到n次 </p></li><li><p>字符锚定的用法和基本正则表达式的用法相同，在此不再阐述。 </p></li><li><p>特殊字符： </p><p>‘|’: 代表或者的意思。 </p><p>‘fg’：grep -E ‘c|cat’ file：表示在文件file内查找包含c或者cat </p><p>‘.‘:\表示转义字符，此表示符号.</p></li></ol><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>只能使用基本的正则表达式来搜索文本。</p><p>grep [option] ‘字符串’ filename</p><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><p>正则表达式选择与解释:</p><pre><code>-E, --extended-regexp     PATTERN 是一个可扩展的正则表达式(缩写为 ERE)-F, --fixed-strings       PATTERN 是一组由断行符分隔的定长字符串。-G, --basic-regexp        PATTERN 是一个基本正则表达式(缩写为 BRE)-P, --perl-regexp         PATTERN 是一个 Perl 正则表达式-e, --regexp=PATTERN      用 PATTERN 来进行匹配操作-f, --file=FILE           从 FILE 中取得 PATTERN-i, --ignore-case         忽略大小写-w, --word-regexp         强制 PATTERN 仅完全匹配字词-x, --line-regexp         强制 PATTERN 仅完全匹配一行-z, --null-data           一个 0 字节的数据行，但不是空行</code></pre><p>Miscellaneous:</p><pre><code>-s, --no-messages         suppress error messages-v, --invert-match        select non-matching lines-V, --version             display version information and exit    --help                display this help text and exit</code></pre><p>输出控制:</p><pre><code>-m, --max-count=NUM       NUM 次匹配后停止-b, --byte-offset         输出的同时打印字节偏移-n, --line-number         输出的同时打印行号  --line-buffered       每行输出清空-H, --with-filename       为每一匹配项打印文件名-h, --no-filename         输出时不显示文件名前缀  --label=LABEL         将LABEL 作为标准输入文件名前缀-o, --only-matching       show only the part of a line matching PATTERN-q, --quiet, --silent     suppress all normal output  --binary-files=TYPE   assume that binary files are TYPE;                        TYPE is &apos;binary&apos;, &apos;text&apos;, or &apos;without-match&apos;-a, --text                equivalent to --binary-files=text-I                        equivalent to --binary-files=without-match-d, --directories=ACTION  how to handle directories;                        ACTION is &apos;read&apos;, &apos;recurse&apos;, or &apos;skip&apos;-D, --devices=ACTION      how to handle devices, FIFOs and sockets;                        ACTION is &apos;read&apos; or &apos;skip&apos;-r, --recursive           like --directories=recurse-R, --dereference-recursive                        likewise, but follow all symlinks  --include=FILE_PATTERN                        search only files that match FILE_PATTERN  --exclude=FILE_PATTERN                        skip files and directories matching FILE_PATTERN  --exclude-from=FILE   skip files matching any file pattern from FILE  --exclude-dir=PATTERN directories that match PATTERN will be skipped.-L, --files-without-match print only names of FILEs containing no match-l, --files-with-matches  print only names of FILEs containing matches-c, --count               print only a count of matching lines per FILE-T, --initial-tab         make tabs line up (if needed)-Z, --null                print 0 byte after FILE name</code></pre><p>文件控制:</p><pre><code>-B, --before-context=NUM  打印以文本起始的NUM 行-A, --after-context=NUM   打印以文本结尾的NUM 行-C, --context=NUM         打印输出文本前后各NUM行-NUM                      same as --context=NUM  --group-separator=SEP use SEP as a group separator  --no-group-separator  use empty string as a group separator  --color[=WHEN],  --colour[=WHEN]       use markers to highlight the matching strings;                        WHEN is &apos;always&apos;, &apos;never&apos;, or &apos;auto&apos;-U, --binary              do not strip CR characters at EOL (MSDOS/Windows)-u, --unix-byte-offsets   report offsets as if CRs were not there                        (MSDOS/Windows)</code></pre><h3 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h3><pre><code>显示匹配行和它后面的10行grep -A 10 pattern file.txt</code></pre><h2 id="egrep"><a href="#egrep" class="headerlink" title="egrep"></a>egrep</h2><p>可以使用扩展的正则表达式来搜索文本，grep不能使用扩展正则表达式的语法</p><p>egrep = grep -E</p><pre><code>eg: 查找至少包含一个大写字母的行grep &apos;[A-Z]+&apos; nginx.log   #没有任何返回值，也不报错egrep &apos;[A-Z]+&apos; nginx.log  #返回匹配行</code></pre><h2 id="fgrep"><a href="#fgrep" class="headerlink" title="fgrep"></a>fgrep</h2><p>利用固定的字符串来搜索文本，不支持正则表达式的引用。类似于精确匹配</p><p>fgrep = grep -F</p><pre><code>eg:查找包含&apos;Apr&apos;字符串的行fgrep &apos;Apr*&apos; nginx.log    #没有返回值，不报错fgrep &apos;Apr&apos; nginx.log    #返回包含Apr字符串的行</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux, shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-treemap</title>
      <link href="/2018/08/15/java-treemap/"/>
      <url>/2018/08/15/java-treemap/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java集合之ArrayList和LinkedList</title>
      <link href="/2018/08/15/java-list/"/>
      <url>/2018/08/15/java-list/</url>
      
        <content type="html"><![CDATA[<p>集合的东西是很常用的类，今天抽时间看看源码，加深印象</p><a id="more"></a><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>可以看到ArrayList的默认初始化大小为10，</p><pre><code>private static final int DEFAULT_CAPACITY = 10;</code></pre><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><pre><code>public boolean add(E e) {    // 扩容机制，    ensureCapacityInternal(size + 1);  // Increments modCount!!    // 直接在数组末尾插入元素    elementData[size++] = e;    return true;}// 扩容private void ensureCapacityInternal(int minCapacity) {    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);    }    ensureExplicitCapacity(minCapacity);}private void ensureExplicitCapacity(int minCapacity) {    modCount++;    // overflow-conscious code    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);}private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><pre><code>public void add(int index, E element) {    rangeCheckForAdd(index);    ensureCapacityInternal(size + 1);  // Increments modCount!!    System.arraycopy(elementData, index, elementData, index + 1,                     size - index);    elementData[index] = element;    size++;}</code></pre><p>可以看到在指定位置index插入元素的时候才会导致元素的移动</p><h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><pre><code>public E get(int index) {    rangeCheck(index);    return elementData(index);}@SuppressWarnings(&quot;unchecked&quot;)E elementData(int index) {    return (E) elementData[index];}</code></pre><p>时间复杂度为O(1)</p><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><pre><code>public E remove(int index) {    rangeCheck(index);    modCount++;    E oldValue = elementData(index);    // 向前移动的元素的位置    int numMoved = size - index - 1;    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);    elementData[--size] = null; // clear to let GC do its work    return oldValue;}// 原生方法public static native void arraycopy(Object src,  int  srcPos,                                    Object dest, int destPos,                                    int length);</code></pre><p>可以看到删除指定index的元素后，后面的所有元素向前移动。时间复杂度为O(n)</p><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><pre><code>public boolean remove(Object o) {    if (o == null) {        for (int index = 0; index &lt; size; index++)            if (elementData[index] == null) {                fastRemove(index);                return true;            }    } else {        for (int index = 0; index &lt; size; index++)            if (o.equals(elementData[index])) {                fastRemove(index);                return true;            }    }    return false;}private void fastRemove(int index) {    modCount++;    int numMoved = size - index - 1;    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);    elementData[--size] = null; // clear to let GC do its work}</code></pre><p>删除指定对象Object的元素，也会导致后面的元素向前移动，只不过中间多了对象的比较过程，时间复杂度为O(n)</p><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="插入元素-1"><a href="#插入元素-1" class="headerlink" title="插入元素"></a>插入元素</h2><h3 id="add-E-e-1"><a href="#add-E-e-1" class="headerlink" title="add(E e)"></a>add(E e)</h3><pre><code>// 在链表末尾插入元素public boolean add(E e) {    linkLast(e);    return true;}// 尾插法void linkLast(E e) {    final Node&lt;E&gt; l = last;    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);    last = newNode;    if (l == null)        //初始链表为空，这是插入第一个元素        first = newNode;    else        l.next = newNode;    size++;    modCount++;}</code></pre><p>插入元素默认为尾插法，所以时间复杂度为O(1)</p><h3 id="add-int-index-E-element-1"><a href="#add-int-index-E-element-1" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><pre><code>public void add(int index, E element) {    // 检查插入位置是否合法    checkPositionIndex(index);    if (index == size)        // 插入位置是末尾，包括列表为空的情况        linkLast(element);    else        linkBefore(element, node(index));}void linkBefore(E e, Node&lt;E&gt; succ) {    // 先根据index找到要插入的位置，再修改引用，完成插入操作    final Node&lt;E&gt; pred = succ.prev;    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);    succ.prev = newNode;    // 插入位置为0，即插入第一个节点    if (pred == null)        first = newNode;    else        pred.next = newNode;    size++;    modCount++;}</code></pre><p>如果指定index，仍然需要去遍历链表，时间复杂度为O(n)</p><h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><pre><code>public E set(int index, E element) {    checkElementIndex(index);    // 先找到指定位置节点    Node&lt;E&gt; x = node(index);    E oldVal = x.item;    x.item = element;    // 修改元素后返回旧值    return oldVal;}</code></pre><p>修改元素也是先找到节点，然后修改value，时间复杂度为O(n)</p><h2 id="查找元素-1"><a href="#查找元素-1" class="headerlink" title="查找元素"></a>查找元素</h2><pre><code>public E get(int index) {    checkElementIndex(index);    return node(index).item;}// 因为链表是双向的，具体从开始往后找还是从后往前找需要判断Node&lt;E&gt; node(int index) {    // assert isElementIndex(index);    if (index &lt; (size &gt;&gt; 1)) {        Node&lt;E&gt; x = first;        for (int i = 0; i &lt; index; i++)            x = x.next;        return x;    } else {        Node&lt;E&gt; x = last;        for (int i = size - 1; i &gt; index; i--)            x = x.prev;        return x;    }}</code></pre><p>查找index的元素，需要遍历链表，时间复杂度为O(n)</p><h2 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h2><h3 id="remove-int-index-1"><a href="#remove-int-index-1" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><pre><code>public E remove(int index) {    checkElementIndex(index);    return unlink(node(index));}E unlink(Node&lt;E&gt; x) {    // assert x != null;    final E element = x.item;    final Node&lt;E&gt; next = x.next;    final Node&lt;E&gt; prev = x.prev;    if (prev == null) {        first = next;    } else {        prev.next = next;        x.prev = null;    }    if (next == null) {        last = prev;    } else {        next.prev = prev;        x.next = null;    }    x.item = null;    size--;    modCount++;    return element;}</code></pre><h3 id="remove-Object-o-1"><a href="#remove-Object-o-1" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><pre><code>public boolean remove(Object o) {    if (o == null) {        for (Node&lt;E&gt; x = first; x != null; x = x.next) {            if (x.item == null) {                unlink(x);                return true;            }        }    } else {        for (Node&lt;E&gt; x = first; x != null; x = x.next) {            if (o.equals(x.item)) {                unlink(x);                return true;            }        }    }    return false;}</code></pre><p>可以看到删除元素，也会先遍历查找到节点，然后再删除，时间复杂度为O(n)。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>从源码可以看出<br>1、 get(int index)、set(int index, E element)，ArrayList明显快于LinkedList，因为LinkedList需要移动指针</p><p>2、add(E) ArrayList和LinkedList都是直接插入尾部</p><p>3、add(int index, E element) ArrayList需要移动后面的元素，LinkedList需要遍历指针(需要具体分析)</p><p>4、remove(int index)/remove(Object o) ArrayList需要移动后面的元素，LinkedList需要遍历指针(需要具体分析)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合之ConcurrentHashMap</title>
      <link href="/2018/08/14/java-concurrenthashmap/"/>
      <url>/2018/08/14/java-concurrenthashmap/</url>
      
        <content type="html"><![CDATA[<p>不同于HashMap,ConcurrentHashMap是线程安全的。</p><p>put(K, V)</p><p>get(Object)</p><p>containsKey(Object)</p><p>size()</p><a id="more"></a><h2 id="put-K-V"><a href="#put-K-V" class="headerlink" title="put(K, V)"></a>put(K, V)</h2><pre><code> @SuppressWarnings(&quot;unchecked&quot;)public V put(K key, V value) {    Segment&lt;K,V&gt; s;    if (value == null)        throw new NullPointerException();    // 第一次hash    int hash = hash(key);    // 第二次hash,得到segment的索引j    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;    // 用unsafe的方式获取segments[j]元素 (unsafe类提供原子操作)    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment        s = ensureSegment(j);    // 在segment.put中进行第三次hash    return s.put(key, hash, value, false);}</code></pre><p>Segment中加锁</p><pre><code>final V put(K key, int hash, V value, boolean onlyIfAbsent) {        // 加锁，ReentrantLock的tryLock()        HashEntry&lt;K,V&gt; node = tryLock() ? null :            scanAndLockForPut(key, hash, value);        V oldValue;        try {            HashEntry&lt;K,V&gt;[] tab = table;            int index = (tab.length - 1) &amp; hash;            HashEntry&lt;K,V&gt; first = entryAt(tab, index);            // 遍历            for (HashEntry&lt;K,V&gt; e = first;;) {                if (e != null) {                    K k;                    if ((k = e.key) == key ||                        (e.hash == hash &amp;&amp; key.equals(k))) {                        oldValue = e.value;                        if (!onlyIfAbsent) {                            e.value = value;                            ++modCount;                        }                        break;                    }                    e = e.next;                }                else {                    if (node != null)                        node.setNext(first);                    else                        node = new HashEntry&lt;K,V&gt;(hash, key, value, first);                    int c = count + 1;                    if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)                        rehash(node);                    else                        setEntryAt(tab, index, node);                    ++modCount;                    count = c;                    oldValue = null;                    break;                }            }        } finally {            // 解锁            unlock();        }        return oldValue;    }</code></pre><h2 id="get-Object"><a href="#get-Object" class="headerlink" title="get(Object)"></a>get(Object)</h2><pre><code>public V get(Object key) {    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead    HashEntry&lt;K,V&gt;[] tab;    int h = hash(key);    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;    // UNSAFE原子获取    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;        (tab = s.table) != null) {        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);             e != null; e = e.next) {            K k;            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))                return e.value;        }    }    return null;}</code></pre><h2 id="containsKey-Object"><a href="#containsKey-Object" class="headerlink" title="containsKey(Object)"></a>containsKey(Object)</h2><pre><code>@SuppressWarnings(&quot;unchecked&quot;)public boolean containsKey(Object key) {    Segment&lt;K,V&gt; s; // same as get() except no need for volatile value read    HashEntry&lt;K,V&gt;[] tab;    int h = hash(key);    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;        (tab = s.table) != null) {        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);             e != null; e = e.next) {            K k;            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))                return true;        }    }    return false;}</code></pre><p>可以看到其实containsKey(Object)和get(Object)实现是一致的</p><h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><pre><code>public int size() {    // Try a few times to get accurate count. On failure due to    // continuous async changes in table, resort to locking.    final Segment&lt;K,V&gt;[] segments = this.segments;    int size;    boolean overflow; // true if size overflows 32 bits    long sum;         // sum of modCounts    long last = 0L;   // previous sum    int retries = -1; // first iteration isn&apos;t retry    try {        for (;;) {            if (retries++ == RETRIES_BEFORE_LOCK) {                for (int j = 0; j &lt; segments.length; ++j)                    ensureSegment(j).lock(); // force creation            }            sum = 0L;            size = 0;            overflow = false;            for (int j = 0; j &lt; segments.length; ++j) {                Segment&lt;K,V&gt; seg = segmentAt(segments, j);                if (seg != null) {                    sum += seg.modCount;                    int c = seg.count;                    if (c &lt; 0 || (size += c) &lt; 0)                        overflow = true;                }            }            if (sum == last)                break;            last = sum;        }    } finally {        if (retries &gt; RETRIES_BEFORE_LOCK) {            for (int j = 0; j &lt; segments.length; ++j)                segmentAt(segments, j).unlock();        }    }    return overflow ? Integer.MAX_VALUE : size;}</code></pre><p>可以看到当retries++ == RETRIES_BEFORE_LOCK = 2的时候，也就是说会重试3次，然后对每一个segment进行加锁。</p><p>sum用来统计seg.modCount的个数，last用来记录上一次统计时sum的值。</p><p>第一次统计：last=0, </p><blockquote><p>如果sum=last=0，跳出for循环；</p><p>如果sum不等于last，则last=sum；</p></blockquote><p>第二次统计：</p><blockquote><p>如果sum=last，跳出for循环；</p><p>如果sum不等于last，则last=sum；</p></blockquote><pre><code>@SuppressWarnings(&quot;unchecked&quot;)private Segment&lt;K,V&gt; ensureSegment(int k) {    final Segment&lt;K,V&gt;[] ss = this.segments;    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset    Segment&lt;K,V&gt; seg;    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {        Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype        int cap = proto.table.length;        float lf = proto.loadFactor;        int threshold = (int)(cap * lf);        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))            == null) { // recheck            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))                   == null) {                // CAS算法                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))                    break;            }        }    }    return seg;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的NIO</title>
      <link href="/2018/08/14/java-nio/"/>
      <url>/2018/08/14/java-nio/</url>
      
        <content type="html"><![CDATA[<p>Unix系统中的I/O模型</p><a id="more"></a><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>nio的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>nio的核心组件其实就3个：</p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><h2 id="AIO-NIO2-0"><a href="#AIO-NIO2-0" class="headerlink" title="AIO/NIO2.0"></a>AIO/NIO2.0</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求一个数组中重复出现次数最多的数字以及出现次数</title>
      <link href="/2018/08/14/algorithms-1/"/>
      <url>/2018/08/14/algorithms-1/</url>
      
        <content type="html"><![CDATA[<h2 id="java语言实现"><a href="#java语言实现" class="headerlink" title="java语言实现"></a>java语言实现</h2><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><a id="more"></a><pre><code>public static void main(String[] args){      int[] arr = { 7, 1, 3, 5, 4, 6, 6, 8, 8, 9, 2, 8, 3 , 8};    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for(int i=0; i &lt; arr.length; i++) {        if(map.containsKey(arr[i])) {            map.put(arr[i], map.get(arr[i]) + 1);        } else {            map.put(arr[i], 1);        }    }    int count = -1;    int max = Integer.MIN_VALUE;    Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iter = map.entrySet().iterator();    while(iter.hasNext()){        Map.Entry&lt;Integer, Integer&gt; entry = iter.next();        if(entry.getValue() &gt; count) {            count = entry.getValue();            max = entry.getKey();        }    }    System.out.println(&quot;出现次数最多的元素：&quot; + max +&quot;--出现次数：&quot; + count);}</code></pre><h2 id="go语言实现"><a href="#go语言实现" class="headerlink" title="go语言实现"></a>go语言实现</h2><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><pre><code>package mainimport (    &quot;fmt&quot;)func main() {    arr := []int{ 7, 1, 3, 5, 4, 6, 6, 8, 8, 9, 2, 8, 3 , 8}    // 创建map类型key(数值)--value(出现次数)    maps := make(map[int]int)    for _, v := range arr {        if maps[v] != 0 {            maps[v]++        } else {            maps[v] = 1        }    }    max, count := maxInMap(maps)    fmt.Printf(&quot;出现次数最多的数字： %d， 次数： %d&quot;, max, count)}func maxInMap(maps map[int]int) (int, int) {    count := -1    var max int     for k, v := range maps {        if v &gt; count {            count = v            max = k        }    }    return max, count}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms, java, go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring bean分析</title>
      <link href="/2018/08/13/spring-bean/"/>
      <url>/2018/08/13/spring-bean/</url>
      
        <content type="html"><![CDATA[<p>Spring的东西有很多不经常用，就会忘记，还是要多记录一下。其实bean这一块儿有很多的东西要梳理，以后慢慢还债</p><a id="more"></a><h2 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h2><ol><li>实例化BeanFactoryPostProcessor实现类; </li><li>BeanFactoryPostProcessor#postProcessBeanFactory();</li><li>实例化BeanPostProcessor实现类</li><li>实例化InstantiationAwareBeanPostProcessorAdapter实现类</li><li>InstantiationAwareBeanPostProcessorAdapter#postProcessBeforeInstatiation()</li><li>bean构造器</li><li>InstantiationAwareBeanPostProcessorAdapter#postProcessPropertyValues()</li><li>bean设置属性值; </li><li>如果实现了BeanNameAware接口,调用setBeanName设置Bean的ID或者Name; </li><li>如果实现BeanFactoryAware接口,调用setBeanFactory 设置BeanFactory; </li><li>如果实现ApplicationContextAware,调用setApplicationContext设置ApplicationContext </li><li>调用BeanPostProcessor#postProcessBeforeInitialization(); </li><li>调用InitializingBean#afterPropertiesSet(); </li><li>调用bean属性中设置的init-method方法； </li><li>调用BeanPostProcessor#postProcessAfterInitialization();</li><li>InstantiationAwareBeanPostProcessorAdapter#postProcessAfterInstatiation()</li></ol><p>DiposibelBean#destroy()<br>执行bean属性中设置的destroy-method方法</p><h2 id="多bean加载顺序"><a href="#多bean加载顺序" class="headerlink" title="多bean加载顺序"></a>多bean加载顺序</h2><ol><li>xml配置的bean优先于注解bean</li><li>优先加载BeanPostProcessor实现的bean; </li><li>按bean文件(例如import标签)和bean的定义顺序装载,</li><li>如果顺序执行中，beanA通过属性ref引用别的beanB，加载完beanA后，加载beanB，然后再顺序执行</li><li>如果beanA属性中depen-on依赖beanB，则会优先装载beanB，然后装载beanA，然后顺序装载</li><li>BeanFactoryUtils类也会改变Bean的加载顺序</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java注解</title>
      <link href="/2018/08/13/java-annotation/"/>
      <url>/2018/08/13/java-annotation/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot封装了很多的注解类，所以回顾一下注解</p><h2 id="java内置注解"><a href="#java内置注解" class="headerlink" title="java内置注解"></a>java内置注解</h2><h3 id="3种标准注解："><a href="#3种标准注解：" class="headerlink" title="3种标准注解："></a>3种标准注解：</h3><p>@Override</p><p>@Desprecated</p><p>@Suppress Warnings</p><a id="more"></a><h3 id="4种元注解："><a href="#4种元注解：" class="headerlink" title="4种元注解："></a>4种元注解：</h3><p>@Target: 表示注解用于什么地方</p><pre><code>ElementType.CONSTRUCTORElementType.FIELDElementType.LOCAL_VARIABLEElementType.METHODElementType.PACKAGEElementType.PARAMETERElementType.TYPE</code></pre><p>@Retention: 表示需要在什么级别保存该注解信息</p><pre><code>RetentionPolicy.SOURCERetentionPolicy.CLASSRetentionPolicy.RUNTIME</code></pre><p>@Documented: 将此注解包含在Javadoc中</p><p>@Inherited: 允许子类继承父类中的注解</p><p>标记注解：没有元素的注解</p><p>例如：</p><pre><code>@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test{}</code></pre><p>注解元素的种类：</p><blockquote><p>所有基本类型</p><p>String</p><p>Class</p><p>enum</p><p>Annotation</p><p>以上所有类型的数组</p></blockquote><p><strong>注意:</strong>不允许使用任何包装类型</p><p>注解的一些默认规则：</p><p>1、元素不能有不确认的值</p><p>2、对于非基本类型的值，无论在源代码中声明，或者在注解接口中定义默认值都不能以null作为其值</p><p>例如：</p><pre><code>@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test{    public int id() default -1;    public String description() default &quot;&quot;;}</code></pre><h3 id="注解嵌套：注解作为注解的元素"><a href="#注解嵌套：注解作为注解的元素" class="headerlink" title="注解嵌套：注解作为注解的元素"></a>注解嵌套：注解作为注解的元素</h3><p>例如：<br>    @Target(ElementType.METHOD)<br>    @Retention(RetentionPolicy.RUNTIME)<br>    public @interface Test{<br>        public int id() default -1;<br>        public String description() default “”;<br>    }</p><pre><code>@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test2{    public int sid() default -1;    public Test test() default @Test;}@Test2(sid = 10, test = @Test(description=&quot;test&quot;))String testAnnotation;</code></pre><h3 id="组合注解：注解上除了元注解，还会有其他的注解"><a href="#组合注解：注解上除了元注解，还会有其他的注解" class="headerlink" title="组合注解：注解上除了元注解，还会有其他的注解"></a>组合注解：注解上除了元注解，还会有其他的注解</h3><p>例如：</p><pre><code>@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = {    @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),    @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {    ...}</code></pre><p>可以看到SpringBootApplication注解除了元注解，还有@SpringBootConfiguration、@EnableAutoCOnfiguration、@ComponentScan注解</p><h3 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-design-pattern</title>
      <link href="/2018/08/12/spring-design-pattern/"/>
      <url>/2018/08/12/spring-design-pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>设计原则：要依赖抽象，不要依赖具体类</p><p>避免违反依赖倒置原则的建议：</p><blockquote><p>变量不可以持有具体类的引用</p><p>不要让类派生自具体类</p><p>不要覆盖基类中已实现的方法</p></blockquote><a id="more"></a><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>Spring的BeanFactory</p><h2 id="建设者模式-生成器模式"><a href="#建设者模式-生成器模式" class="headerlink" title="建设者模式/生成器模式"></a>建设者模式/生成器模式</h2><p>Spring中BeanDefinitionBuilder</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>Spring中ProxyFactoryBean</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>设计原则：针对接口编程，而不是针对实现编程</p><p>spring中MethodNameResolver + ParameterMethodNameResolver</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>Spring中AbstractApplicationCOntext.obtainFreshBeanFactory、refreshBeanFactory、getBeanFactory + GenericApplicationContext</p><h2 id="策略、模板、状态3中设计模式的对比"><a href="#策略、模板、状态3中设计模式的对比" class="headerlink" title="策略、模板、状态3中设计模式的对比"></a>策略、模板、状态3中设计模式的对比</h2><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>Spring中bean的作用域scope=”prototype”</p><p>优点：</p><p>向客户隐藏制造新实例的复杂性</p><p>提供客户能够产生未知类型实例对象的选项</p><p>在某些环境下，复制对象比创建新对象更有效</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>Spring中AbstractApplicationContext.addApplicationListener + ApplicationListener + ApplicationEventMulticaster</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>Spring中AOP使用load-time-weaving针对AspectJ、CGLIB使用不同的逻辑</p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h2 id="适配器模式、装饰者模式的区别"><a href="#适配器模式、装饰者模式的区别" class="headerlink" title="适配器模式、装饰者模式的区别"></a>适配器模式、装饰者模式的区别</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的引用类型</title>
      <link href="/2018/08/11/java-reference/"/>
      <url>/2018/08/11/java-reference/</url>
      
        <content type="html"><![CDATA[<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>只要强引用还存在，垃圾回收器永远不会回收被引用的对象</p><p>Object obj = new Object()</p><a id="more"></a><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>在系统发生内存溢出之前，将会把这些对象列进回收范围进行第二次回收</p><p>JDK1.2+的SoftReference</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>比软引用更弱一些，当垃圾收集器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象</p><p>JDK1.2+的WeakReference</p><h2 id="虚引用-幽灵引用-幻影引用"><a href="#虚引用-幽灵引用-幻影引用" class="headerlink" title="虚引用(幽灵引用/幻影引用)"></a>虚引用(幽灵引用/幻影引用)</h2><p>它是最弱的一种引用，一个对象即使有虚引用，也会被回收。为对象设置虚引用的目的就是在这个对象被收集器回收时收到一个系统通知</p><p>JDK1.2+的PhantomReference</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Threadlocal原理分析</title>
      <link href="/2018/08/11/java-threadlocal/"/>
      <url>/2018/08/11/java-threadlocal/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal的底层实现"><a href="#ThreadLocal的底层实现" class="headerlink" title="ThreadLocal的底层实现"></a>ThreadLocal的底层实现</h2><h3 id="主要方法："><a href="#主要方法：" class="headerlink" title="主要方法："></a>主要方法：</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><pre><code>public void set(T value) {    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);}</code></pre><a id="more"></a><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><pre><code>public T get() {    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null) {        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null)            return (T)e.value;    }    return setInitialValue();}</code></pre><p>可以看到先获取当前线程t,然后根据t得到ThreadLocalMap对象，如果map为null则设置初始值。</p><h4 id="getMap-t"><a href="#getMap-t" class="headerlink" title="getMap(t)"></a>getMap(t)</h4><pre><code>ThreadLocalMap getMap(Thread t) {    return t.threadLocals;}</code></pre><p>从getMap可以看到返回的是当前线程的threadLocals属性。</p><h4 id="ThreadLocalMap类"><a href="#ThreadLocalMap类" class="headerlink" title="ThreadLocalMap类"></a>ThreadLocalMap类</h4><pre><code>static class ThreadLocalMap {    static class Entry extends WeakReference&lt;ThreadLocal&gt; {        /** The value associated with this ThreadLocal. */        Object value;        Entry(ThreadLocal k, Object v) {            super(k);            value = v;        }    }    private static final int INITIAL_CAPACITY = 16;    private Entry[] table;    ...    private Entry getEntry(ThreadLocal key) {        int i = key.threadLocalHashCode &amp; (table.length - 1);        Entry e = table[i];        if (e != null &amp;&amp; e.get() == key)            return e;        else            return getEntryAfterMiss(key, i, e);    }</code></pre><p>可以看到其实ThreadLocalMap就是HashMap的一个变形。</p><h4 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue"></a>setInitialValue</h4><pre><code>private T setInitialValue() {    T value = initialValue();    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);    return value;}protected T initialValue() {    return null;}void createMap(Thread t, T firstValue) {    t.threadLocals = new ThreadLocalMap(this, firstValue);}</code></pre><p>可以看到初始化时，为当前线程t设置了一个key为当前ThreadLocal对象，value为null的threadLocals属性。</p><h2 id="ThreadLocal初始化在堆上还是栈上"><a href="#ThreadLocal初始化在堆上还是栈上" class="headerlink" title="ThreadLocal初始化在堆上还是栈上"></a>ThreadLocal初始化在堆上还是栈上</h2><h2 id="ThreadLocal会导致内存泄漏吗"><a href="#ThreadLocal会导致内存泄漏吗" class="headerlink" title="ThreadLocal会导致内存泄漏吗?"></a>ThreadLocal会导致内存泄漏吗?</h2><ol><li><p>看到一篇博客讲不会发生内存泄漏，原因是Entry是一个弱引用，如果entry.get()=null，entry会被擦除</p><p> static class ThreadLocalMap {</p><pre><code>/** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object).  Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table.  Such entries are referred to * as &quot;stale entries&quot; in the code that follows. */static class Entry extends WeakReference&lt;ThreadLocal&gt; {    /** The value associated with this ThreadLocal. */    Object value;    Entry(ThreadLocal k, Object v) {        super(k);        value = v;    }}</code></pre><p> <a href="https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/" title="技术小黑屋" target="_blank" rel="noopener">技术小黑屋</a></p></li><li><p>还有一篇博客说会导致内存泄漏，</p><p> <a href="http://www.codeceo.com/article/threadlocal-leak-analyze.html" target="_blank" rel="noopener">Servlet</a></p></li></ol><h2 id="ThreadLocal和InheritableThreadLocal的区别"><a href="#ThreadLocal和InheritableThreadLocal的区别" class="headerlink" title="ThreadLocal和InheritableThreadLocal的区别"></a>ThreadLocal和InheritableThreadLocal的区别</h2><p>InheritableThreadLocal会自动将值传递给子线程，也就是说在子线程可以看到父线程的值。</p><p><strong>注意：</strong>为了保护线程安全，应该只对不可变的对象使用InheritableThreadLocal。但不能是有状态的对象，例如JDBC Connection</p><p>ThreadLocal</p><pre><code>static final ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal();public static void main(String[] args){    threadLocal.set(123);    System.out.println(&quot;父线程获取threadLocal:&quot; + threadLocal.get());    Thread t = new Thread(){        @Override        public void run() {            super.run();            System.out.println(&quot;设值前：子线程获取threadLocal:&quot; + threadLocal.get());            threadLocal.set(234);            System.out.println(&quot;设值后：子线程获取threadLocal:&quot; + threadLocal.get());        }    };    t.start();}</code></pre><p>返回值</p><pre><code>父线程获取threadLocal:123设值前：子线程获取threadLocal:null设值后：子线程获取threadLocal:234</code></pre><p>InheritableThreadLocal</p><pre><code>static final ThreadLocal threadLocal = new InheritableThreadLocal();public static void main(String[] args){    threadLocal.set(123);    System.out.println(&quot;父线程获取threadLocal:&quot; + threadLocal.get());    Thread t = new Thread(){        @Override        public void run() {            super.run();            System.out.println(&quot;设值前：子线程获取threadLocal:&quot; + threadLocal.get());            threadLocal.set(234);            System.out.println(&quot;设值后：子线程获取threadLocal:&quot; + threadLocal.get());        }    };    t.start();}</code></pre><p>返回值</p><pre><code>父线程获取threadLocal:123设值前：子线程获取threadLocal:123设值后：子线程获取threadLocal:234</code></pre><h3 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a>ThreadLocal的应用场景</h3><p>1.实现单个线程单例以及单个线程上下文信息存储，比如交易id等</p><p>2.实现对象线程安全，例如：数据库连接</p><p>3.承载一些线程相关的数据，避免在方法中来回传递参数。例如：Session管理</p><h3 id="InheritableThreadLocal的应用场景"><a href="#InheritableThreadLocal的应用场景" class="headerlink" title="InheritableThreadLocal的应用场景"></a>InheritableThreadLocal的应用场景</h3><p>1、用户标识</p><p>2、事务标识</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, threadlocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合之HashMap</title>
      <link href="/2018/08/09/java-hashmap/"/>
      <url>/2018/08/09/java-hashmap/</url>
      
        <content type="html"><![CDATA[<p>基于平常很少会看底层的实现，又频繁用到这些，所以简单看一下HashMap中几个主要方法的底层实现：</p><p>put(K, V)</p><p>resize(int)</p><p>get(Object)</p><p>containsKey(Object)</p><p>size()</p><a id="more"></a><h2 id="put-K-V-方法"><a href="#put-K-V-方法" class="headerlink" title="put(K, V)方法"></a>put(K, V)方法</h2><pre><code>public V put(K key, V value) {    if (table == EMPTY_TABLE) {        inflateTable(threshold);    }    if (key == null)        return putForNullKey(value);    // 先对map做一次查找，查看是否包含该元组，如果存在，则直接返回    int hash = hash(key);    // 返回 h &amp; (table.length-1)    int i = indexFor(hash, table.length);    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        }    }    // 每次对map修改一次，modCount加1    modCount++;    // i：bucketIndex    addEntry(hash, key, value, i);    return null;}// 添加void addEntry(int hash, K key, V value, int bucketIndex) {    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {        //自动扩容，并重新哈希        resize(2 * table.length);        hash = (null != key) ? hash(key) : 0;        bucketIndex = indexFor(hash, table.length);    }    createEntry(hash, key, value, bucketIndex);}// 在冲突链表头部插入新的entryvoid createEntry(int hash, K key, V value, int bucketIndex) {    Entry&lt;K,V&gt; e = table[bucketIndex];    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);    size++;}static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final K key;    V value;    Entry&lt;K,V&gt; next;    int hash;    ...}</code></pre><p>可以看到先通过hash(key)和table.length求得一个下标i，然后去遍历table[i]后面的Entry&lt;K,V&gt;链表,查找是否已经存储过该对象，如果存储过，则返回存储的e.value，并且重新赋值新的value；否则添加Entry</p><p>扩容机制可以看到，如果size &gt; threshold，则执行resize(2 * table.length)，</p><ol><li>在new HashMap()中默认threashold = DEFAULT_INITIAL_CAPACITY=16，否则为自定义值</li><li>在put(K,V)的时候先执行了inflateTable(threshold)，inflateTable中int capacity = roundUpToPowerOf2(toSize)，</li><li>所以inflateTable后现在threshold = capacity*0.75；</li></ol><p>同时可以看到在createEntry中size++，即当元素个数&gt;=0.75capacity时，扩容为2table.length = 2capacity</p><pre><code>private void inflateTable(int toSize) {    // Find a power of 2 &gt;= toSize    int capacity = roundUpToPowerOf2(toSize);    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);    table = new Entry[capacity];    initHashSeedAsNeeded(capacity);}private static int roundUpToPowerOf2(int number) {    // assert number &gt;= 0 : &quot;number must be non-negative&quot;;    return number &gt;= MAXIMUM_CAPACITY            ? MAXIMUM_CAPACITY            : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;}</code></pre><h2 id="resize-int-方法"><a href="#resize-int-方法" class="headerlink" title="resize(int)方法"></a>resize(int)方法</h2><pre><code>void resize(int newCapacity) {    Entry[] oldTable = table;    int oldCapacity = oldTable.length;        threshold = Integer.MAX_VALUE;        if (oldCapacity == MAXIMUM_CAPACITY) {        return;    }    Entry[] newTable = new Entry[newCapacity];    // 扩容后进行重hash操作    transfer(newTable, initHashSeedAsNeeded(newCapacity));    table = newTable;    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);}void transfer(Entry[] newTable, boolean rehash) {    int newCapacity = newTable.length;    // 遍历元素重hash    for (Entry&lt;K,V&gt; e : table) {        while(null != e) {            Entry&lt;K,V&gt; next = e.next;            if (rehash) {                e.hash = null == e.key ? 0 : hash(e.key);            }            int i = indexFor(e.hash, newCapacity);            e.next = newTable[i];            newTable[i] = e;            e = next;        }    }}</code></pre><p>可以看到在resize后，要对所有的元素重hash进行存储</p><h2 id="get-Object"><a href="#get-Object" class="headerlink" title="get(Object)"></a>get(Object)</h2><pre><code>public V get(Object key) {    if (key == null)        return getForNullKey();    Entry&lt;K,V&gt; entry = getEntry(key);    return null == entry ? null : entry.getValue();}final Entry&lt;K,V&gt; getEntry(Object key) {    if (size == 0) {        return null;    }    //先通过hash()函数得到key对应buckets的下标，然后依次遍历冲突链表    int hash = (key == null) ? 0 : hash(key);    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];         e != null;         e = e.next) {        Object k;        if (e.hash == hash &amp;&amp;            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))            return e;    }    return null;}</code></pre><p>可以看到其实查找元素就是先通过hash(key)定位到数组，然后再去遍历数组后的链表</p><h2 id="containsKey-Object"><a href="#containsKey-Object" class="headerlink" title="containsKey(Object)"></a>containsKey(Object)</h2><pre><code>public boolean containsKey(Object key) {    return getEntry(key) != null;}</code></pre><p>可以看到其实containsKey(Object)走的也是一个get(Object)</p><h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><pre><code>public int size() {    return size;}</code></pre><p>可以看到HashMap查找长度，其实就是返回了一个属性，Java集合中大多都是返回size属性，不同的是ConcurrentHashMap需要实时去查找。因为ConcurrentHashMap是线程安全的</p><h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h2><h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>加载因子越大,填满的元素越多,好处是,空间利用率高了,但冲突的机会加大了。链表长度会越来越长,查找效率降低。</p><p>反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但空间浪费多了。表中的数据将过于稀疏（很多空间还没用，就开始扩容了）</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>key、value都允许为null值</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>村上春树和三毛</title>
      <link href="/2018/08/08/thinking-in-today/"/>
      <url>/2018/08/08/thinking-in-today/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=410161216&auto=1&height=66"></iframe><p>不知道是因为下雨的原因，还是立秋的原因，今天走出门口，感觉凉凉的，有一点秋天的感觉。我想，也许有两者都有吧。然后赶往另一个地方，不经意间，就想起杨宗纬，想起村上春树，想起三毛。</p><a id="more"></a><p>想想自己来京一年多的时间里，自从去年在春雪未化的时候一个人去了碓臼峪，秋天去了中华民族园，去了香山。已经很久没有认真看过这个城市，正好搭公交去另一个地方。车上的人很少，大多是已上年纪的“老头”、“老太太”，依然选一个靠窗的位置坐下，开始百无聊赖的看窗外的故事。</p><p>窗外有三三两两骑着电动车带小孩子的母亲，我想附近应该是有个学校吧，男孩儿背着书包，安安静静的拉着母亲的衣角，倒是女孩儿显得有点调皮，东张西望的样子，又显得有点可爱。心里暗自在想，如果可以永远当一个长不大的孩子，永远没有烦恼该多好。一会儿，上来一位奶爸，抱着两三岁的女儿，一副很学究气的眼镜，给人一种学者的印象，运动休闲短裤，脚上是休闲的凉鞋，手上爆凸的青筋，正好坐在我的邻座，一路上爸爸和女儿有的没的说话，女儿一概不理，我想，假如有女本柔弱，为母则刚的话，这一定是男本刚强，为父则柔吧，心中顿生温暖。”静安庄到了，有到静安庄下车的乘客请注意”,车窗外是一位老爷爷，头发花白，应该在六十左右，双手背在身后，看着路上的一切，不知道在看些什么，也不知道在想些什么，三十而立，四十不惑，五十而知天命，六十而耳顺，七十而随心所欲不逾矩。如果我到了这个年纪，又会是什么样子呢？正当我陷入更多的思考后，车牌下一位头顶鸭舌帽，带着耳机，穿着短裤，我想她一定是个孤独而又对生活充满激情的人，有着年轻人该有的一切对生活不屈服的骄傲，一种来自内心的共鸣喷涌而出，如果说有什么让我坚持生活在这里，我想一定是在这里，每个人都在努力而又认真的活着。扫视窗外，路旁的清洁工正在打扫落叶，不知不觉，你已经离开我，后知后觉，又过了一个秋。生活就是这样，琐碎而又充满乐趣。</p><p>此时此刻，村上春树、三毛更多的占据我的内心，使我迫不及待地想要把这一切记录下来。</p><p>村上春树</p><blockquote><p>天下的事在许多情况下并没有结论。那事情越是重要，这种倾向就越明显。越是脚踏实地大量收集第一手讯息，花费大量时间采访，事物的真相就越扑朔迷离。结论越发渐行渐远，视点越发四分五裂。注定如此。结果我们走投无路。孰对孰错，孰前孰后，我们渐渐不明就里了。 </p><p>我们每个人或多或少，都是一只蛋，是拥有独一无二的灵魂和包裹这灵魂的脆弱外壳的蛋。我是这样，你们也是。而且我们每个人或多或少，都面对着一堵坚固的高墙。这堵墙是有名字的，它叫作“体制”。这体制本应是保护我们的东西。可在某些时候，它会自行其是，会杀死我们，会让我们杀人。它冷酷，高效，而且有条不紊。 </p><p>年轻时音乐也好书也好，哪怕条件差一点，不也照样会不由分说地沁入心灵么？人的心中可以容纳无穷无尽的音乐。</p><p>结果，大多数东西都烟消云散了。在那个时代里曾经震撼我们心灵、洞穿我们肉体的东西，当十年逝去回首往昔时，我们才知道那大多不过是经过粉饰的约定。我们追求了，于是给了我们。然而我们追求的东西太多，结果给我们的东西大多坠入了类型化。 </p><p>在某些情况下，虚构会深深吞噬我们的真实存在。就像康拉德的小说将我们实际带入非洲原始森林深处一样。人们必须在某一时刻阖上书本，从那个场所回归现实。我们必须在与虚构不同的地点，恐怕是采取与虚构相互交换力量的形式，打造出抗击现实世界的自己。 </p><p>与之相比，我们则生活在效率极低的混沌的社会里。阅读每日的报纸便可一目了然。不难理解毫不留恋地想逃出这种鬼地方，迅速融入心旷神怡的同质共同体的心情。 </p><p>说得再深入些，我认为这里的外在混沌，不应当作他者和障碍加以排斥，而应视为我们内在混沌的反映接纳下来。其间的矛盾、庸俗、伪善和软弱，其实不正与我们内心暗藏的矛盾、庸俗、伪善和软弱相同吗？就像跳进大海时，包围身体的海水与我们内部的体液在成分上彼此呼应…… </p><p>不过有个肉眼可见的变化。就是乘坐电车时，会极其自然地环视周围的乘客，想道，“这里的这些人，各自都有深刻的人生啊”。想道，“是的。我们在某种意义上是孤独的，但在某种意义上又不孤独”。着手这件工作之前，我根本没有这样的念头。电车仅仅是电车，乘客无非是“陌路人”罢了。</p></blockquote><p>对于未来，正如村上春树所说那样：<strong>“世上所有的人终其一生，都在寻求某个宝贵的东西，但能找到的人不多。即使幸运地找到了，那东西也大多受到致命的损伤。但是，我们必须继续寻求。因为不这么做，活着的意义就不复存在。”</strong></p><p>三毛</p><blockquote><p>结婚，小半是为荷西情痴，大半仍是为了父母，至于我自己，本可以一辈子光棍下去，人的环境和追求并不只有那么一条狭路，怎么活，都是一场人生，不该在这件事上谈成败，论英雄。</p><p>“每夜你上床时，一定要觉得——今天可真活了个够——那么你的一生都不会有遗憾”</p><p>生命，在这样荒僻落后而贫苦的地方，一样欣欣向荣地滋长着，它，并不是挣扎着在生存，对于沙漠的居民而言，他们在此地的生老病死都好似是如此自然的事。我看着那些上升的烟火，觉得他们安详得近乎优雅起来。</p><p>物质的文明对人类并不能说是必要，但是在我们同样生活着的地球上居然还有连镜子都没有看过的人，的确令我惊愕交加，继而对他们无由地产生了一丝怜悯。这样的无知只是地理环境的限制，还是人为的因素，我久久找不到答案。</p><p>这条荒野里唯一的柏油路，照样被我日复一日地来回驶着，它乍看上去，好似死寂一片，没有生命，没有哀乐。其实它跟这世界上任何地方的一条街，一条窄弄，一弯溪流一样，载着它的过客和故事，来来往往地度着缓慢流动的年年月月。</p><p>夏日的撒哈拉就似它漫天飞扬、永不止息的尘埃，好似再也没有过去的一天，岁月在令人欲死的炎热下粘了起来，缓慢而无奈的日子，除了使人懒散和疲倦之外，竟对什么都迷迷糊糊的不起劲，心里空空洞洞地熬着汗渍渍的日子。</p><p>“看破的，遁入空门，痴迷的，枉送了性命，好一似，食尽鸟投林，落了片白茫茫大地真干净！”</p><p>我蹲在远远的沙地上，不停地发着抖，发着抖，四周暗得快看不清他们了。风，突然没有了声音，我渐渐地什么也看不见，只听见屠宰房里骆驼嘶叫的悲鸣越来越响，越来越高，整个的天空，渐渐充满了骆驼们哭泣着的巨大的回声，像雷鸣似的向我罩下来。</p></blockquote><p>对于今天，则应该像三毛所说的那样：<strong>“每夜你上床时，一定要觉得——今天可真活了个够——那么你的一生都不会有遗憾”</strong></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life, reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql主从复制</title>
      <link href="/2018/08/08/mysql-master-slave/"/>
      <url>/2018/08/08/mysql-master-slave/</url>
      
        <content type="html"><![CDATA[<h2 id="主要解决的问题："><a href="#主要解决的问题：" class="headerlink" title="主要解决的问题："></a>主要解决的问题：</h2><p>数据分布</p><p>负载均衡</p><p>备份</p><p>高可用性和故障切换</p><p>升级测试</p><a id="more"></a><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>1、主库把数据更新记录到二进制日志</p><p>2、备库将主库的日志复制到自己的中继日志</p><blockquote><p>备库启动I/O线程，和主库建立一个客户端连接</p><p>主库启动特殊的转储线程，读取主库上二进制日志中的事件</p><p>备库I/O线程将接收到的事件记录到中继日志</p></blockquote><p>3、备库读取中继日志的事件，写入数据</p><p>备库sql线程从中继日志读取事件、执行事件</p><h3 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h3><p>主库会记录所有数据更新的sql，当备库读取重放这些事件时，实际上是把所有执行过的sql语句执行一遍。</p><p>优点：</p><p>缺点：</p><h3 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h3><p>将实际的数据记录在二进制日志中。</p><p>优点：</p><p>缺点：</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="主库"><a href="#主库" class="headerlink" title="主库"></a>主库</h3><p>1、修改配置文件</p><pre><code>vi /etc/my.cnf</code></pre><p>配置参数</p><pre><code>log_bin=mysql-bin  server-id=1 replay_log=/var/lib/mysql/mysql-replay-binlog_slave_updates=1read_only=1innodb_flush_log_at_trx_commit=1 sync_binlog=1</code></pre><p>启动MySQL</p><pre><code>systemctl restart mysqld;</code></pre><p><strong>注意：</strong> log_bin一定要开启，也可以是’log-bin’,如果不开启可能会报错：</p><p>ERROR 2006 (HY000): MySQL server has gone away<br>No connection. Trying to reconnect…<br>Connection id:    3<br>Current database: <strong><em> NONE </em></strong></p><p>Empty set (0.00 sec)</p><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h4><p>2、创建一个供局域网内连接的用户(有的提到要加锁)</p><pre><code>grant replication slave on *.* to &apos;admin&apos;@&apos;192.168.117.%&apos; identified by &apos;xxxxxx&apos;;flush privileges;</code></pre><p><strong>注意：</strong> on后面是’<em>.</em>‘,否则可能会报错：</p><p>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘to ‘admin-m‘@’192.168.117.%’ identified by ‘admin234’’ at line 1</p><p>3、查看主库</p><pre><code>mysql -uroot -pshow master status \G;</code></pre><h3 id="从库"><a href="#从库" class="headerlink" title="从库"></a>从库</h3><p>1、修改配置(有的提到修改/var/lib/mysql/auto.cnf文件)</p><pre><code>vi /etc/my.cnf</code></pre><p>配置参数：</p><pre><code>server_id=22relay_log=relay-log-binskip_slave_startread_onlyrelay_log_index=slave-relay-bin.index</code></pre><p>2、连接到主库</p><pre><code>change master to master_host=&apos;192.168.117.135&apos;,master_port=3306,master_user=&apos;admin&apos;,master_password=&apos;xxxxx&apos;,master_log_file=&apos;mysql-bin.000003&apos;,master_log_pos=154;</code></pre><p>参数解释：</p><p>3、启动从库，查看是否启动成功</p><pre><code>start slave;show slave status \G;</code></pre><p>如果Slave_IO_Running: YES Slave_SQL_Running: Yes,则表明启动成功。</p><p>参数Last_IO_Errno: 1236 Last_IO_Error显示失败的原因。</p><p>错误1:中间重启从库mysql,启动后直接start slave;</p><p>报错：ERROR 1872 (HY000): Slave failed to initialize relay log info structure from the repository</p><p>解决：</p><pre><code>reset slave;change master .....;start slave;</code></pre><p>启动成功；</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL, </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的IOC原理分析</title>
      <link href="/2018/08/08/spring-ioc/"/>
      <url>/2018/08/08/spring-ioc/</url>
      
        <content type="html"><![CDATA[<p>BeanFactory</p><p>ListableBeanFactory</p><p>HierarchicalBeanFactory</p><p>AutowireCapableBeanFactory</p><p>ApplicationContext</p><h2 id="传统编程和IoC的对比"><a href="#传统编程和IoC的对比" class="headerlink" title="传统编程和IoC的对比"></a>传统编程和IoC的对比</h2><p>传统编程：决定使用哪个具体的实现类的控制权在调用类本身，在编译阶段就确定了。</p><p>IoC模式：调用类只依赖接口，而不依赖具体的实现类，减少了耦合。控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, Spring, ioc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM虚拟机命令详解</title>
      <link href="/2018/08/07/java-jvm-cmd/"/>
      <url>/2018/08/07/java-jvm-cmd/</url>
      
        <content type="html"><![CDATA[<p>其实去年就一直在做这些东西，只是没有整理出来，这一段时间面试还是遇到很多问jvm的东西，特别整理以下</p><h2 id="jvm的默认参数"><a href="#jvm的默认参数" class="headerlink" title="jvm的默认参数"></a>jvm的默认参数</h2><p>安装完jdk后，先来看一看一些默认参数，以下统一以jdk1.8为例。</p><pre><code>java -XX:+PrintFlagsFinal -version | grep :</code></pre><p>“=”:表示jvm参数的默认值，</p><p>“:=”:表示被用户或者jvm赋值的参数</p><a id="more"></a><pre><code> intx CICompilerCount                          := 2                                   {product}uintx InitialHeapSize                          := 48234496                            {product}uintx MaxHeapSize                              := 742391808                           {product}uintx MaxNewSize                               := 247463936                           {product}uintx MinHeapDeltaBytes                        := 524288                              {product}uintx NewSize                                  := 15728640                            {product}uintx OldSize                                  := 32505856                            {product} bool PrintFlagsFinal                          := true                                {product} bool UseCompressedClassPointers               := true                                {lp64_product} bool UseCompressedOops                        := true                                {lp64_product} bool UseParallelGC                            := true                                {product}</code></pre><p>查看参数配置：</p><pre><code>java -XX:+PrintCommandLineFlags -version-XX:InitialHeapSize=46359872 -XX:MaxHeapSize=741757952 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC java version &quot;1.8.0_161&quot;Java(TM) SE Runtime Environment (build 1.8.0_161-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</code></pre><h3 id="参数分析"><a href="#参数分析" class="headerlink" title="参数分析"></a>参数分析</h3><p>-XX:+UseParallelGC参数可知，使用的收集器为Parallel Scavenge + Serial Old(PS MarkSweep)组合。</p><h2 id="jstat-统计信息监控"><a href="#jstat-统计信息监控" class="headerlink" title="jstat: 统计信息监控"></a>jstat: 统计信息监控</h2><p>jstat option vmid [interval] [count]</p><h4 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h4><p>Options — 选项，我们一般使用 -gcutil 查看gc 情况</p><p>vmid — VM 的进程号，即当前运行的java 进程号</p><p>interval– 间隔时间，单位为秒或者毫秒</p><p>count — 打印次数，如果缺省则打印无数次</p><h4 id="具体参数如下："><a href="#具体参数如下：" class="headerlink" title="具体参数如下："></a>具体参数如下：</h4><p>-class：统计class loader行为信息</p><p>-compile：统计编译行为信息</p><p>-gc：统计jdk gc时heap信息</p><p>-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况</p><p>-gccause：统计gc的情况，（同-gcutil）和引起gc的事件</p><p>-gcnew：统计gc时，新生代的情况</p><p>-gcnewcapacity：统计gc时，新生代heap容量</p><p>-gcold：统计gc时，老年区的情况</p><p>-gcoldcapacity：统计gc时，老年区heap容量</p><p>-gcpermcapacity：统计gc时，permanent区heap容量</p><p>-gcutil：统计gc时，heap情况</p><p>-printcompilation：不知道干什么的，一直没用过。</p><h4 id="案例分析："><a href="#案例分析：" class="headerlink" title="案例分析："></a>案例分析：</h4><p>S0 — Heap 上的 Survivor space 0 区已使用空间的百分比</p><p>S1 — Heap 上的 Survivor space 1 区已使用空间的百分比</p><p>E — Heap 上的 Eden space 区已使用空间的百分比</p><p>O — Heap 上的 Old space 区已使用空间的百分比</p><p>P — Perm space 区已使用空间的百分比</p><p>YGC — 从应用程序启动到采样时发生 Young GC 的次数</p><p>YGCT– 从应用程序启动到采样时 Young GC 所用的时间( 单位秒 )</p><p>FGC — 从应用程序启动到采样时发生 Full GC 的次数</p><p>FGCT– 从应用程序启动到采样时 Full GC 所用的时间( 单位秒 )</p><p>GCT — 从应用程序启动到采样时用于垃圾回收的总时间( 单位秒)</p><p>jstat -gc 1909</p><pre><code>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU      CCSC   CCSU     YGC     YGCT    FGC    FGCT     GCT   3456.0 3456.0 3456.0  0.0   28224.0  23968.9   70124.0    66785.0   43264.0 42270.5 4864.0  4588.8    128    1.487    8    0.779    2.266</code></pre><p>jstat -gccapacity 1909</p><pre><code>NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC 5440.0  83968.0  35136.0 3456.0 3456.0  28224.0    10944.0   167936.0    70124.0    70124.0      0.0 1087488.0  43264.0   0.0    1048576.0   4864.0  128     8</code></pre><p>jstat -gcutil 1909</p><p>jstat -gcutil 1909 1000 100      #每1000ms打印一次，总共打印100次</p><pre><code>S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   0.00   0.00   3.41  60.00  97.54  94.07    129    1.534     9    1.148    2.682</code></pre><p>jstat -gcnew 1909</p><pre><code>S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  3584.0 3584.0    0.0    0.0  1  15 1728.0  29248.0   2123.2    129    1.534</code></pre><p>jstat -gcnewcapacity 1909</p><pre><code>NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC 5440.0    83968.0    36416.0   8384.0   3584.0   8384.0   3584.0    67200.0    29248.0   129     9</code></pre><p>jstat -gcold pid</p><p>jstat -gcoldcapacity pid</p><p>jstat -gcpermcapacity pid</p><p>jstat -class 1909</p><pre><code>Loaded  Bytes  Unloaded  Bytes     Time   6688 13143.8       24    31.1      52.45</code></pre><p>jstat -compiler 1909</p><pre><code>Compiled Failed Invalid   Time   FailedType FailedMethod7578      3       0    38.61          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run</code></pre><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>jmap option vmid</p><h4 id="具体参数如下：-1"><a href="#具体参数如下：-1" class="headerlink" title="具体参数如下："></a>具体参数如下：</h4><p>-dump</p><p>-heap</p><p>-histo</p><p>-finalizeerinfo</p><p>-permstat</p><p>-F</p><h4 id="案例分析：-1"><a href="#案例分析：-1" class="headerlink" title="案例分析："></a>案例分析：</h4><p>使用hprof二进制形式,输出jvm的heap内容到文件，.live子选项是可选的，假如指定live选项,那么只输出活的对象到文件. 【执行过程会暂停应用】</p><p>记录堆内存快照文件，然后利用第三方工具mat分析整个Heap的对象关联情况 【如果添加参数:live，JVM会先触发gc，然后再统计信息。】</p><pre><code>jmap -dump:format=b,file=[filename][pid]jmap -dump:live,format=b,file=20170509.hprof 1909</code></pre><p>打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.</p><pre><code>jmap -heap 1909</code></pre><p>打印每个class的实例数目,内存占用,类全名信息。VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量. 【如果添加参数:live，JVM会先触发gc，然后再统计信息。】</p><pre><code>jmap -histo:live 1909 | head -n 100 &gt; jmaphisto.log</code></pre><p>打印正等候回收的对象的信息</p><pre><code>jmap -finalizerinfo 1283</code></pre><p>打印classload和jvm heap永久层的信息. 【执行过程会暂停应用】</p><p>包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来.</p><pre><code>jmap -permstat 1909</code></pre><p>结合MAT分析。</p><h4 id="补充：保留现场，使用更快的gcore分析"><a href="#补充：保留现场，使用更快的gcore分析" class="headerlink" title="补充：保留现场，使用更快的gcore分析"></a>补充：保留现场，使用更快的gcore分析</h4><ol><li>Linux内核里面生成的core file文件相关的代码</li><li>core dump file 相关的设置</li><li>如何在程序中调用代码生成 core dump file，程序又不用退出。</li><li>使用gdb分析 core dump file 文件</li><li>用gdb 生成core文件</li></ol><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><h4 id="具体参数如下：-2"><a href="#具体参数如下：-2" class="headerlink" title="具体参数如下："></a>具体参数如下：</h4><h4 id="案例分析：-2"><a href="#案例分析：-2" class="headerlink" title="案例分析："></a>案例分析：</h4><p>生成虚拟机当前时刻线程快照:</p><pre><code>jstack -l 1909jstack 1909 &gt; jstack.log</code></pre><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><h2 id="jcmd-新版jdk的命令，用于取代旧版本命令"><a href="#jcmd-新版jdk的命令，用于取代旧版本命令" class="headerlink" title="jcmd: 新版jdk的命令，用于取代旧版本命令"></a>jcmd: 新版jdk的命令，用于取代旧版本命令</h2><h4 id="具体参数如下：-3"><a href="#具体参数如下：-3" class="headerlink" title="具体参数如下："></a>具体参数如下：</h4><h4 id="案例分析：-3"><a href="#案例分析：-3" class="headerlink" title="案例分析："></a>案例分析：</h4><p>查看jvm的pid,类似于jps命令</p><pre><code>jcmd -l1283 org.apache.catalina.startup.Bootstrap start2293 sun.tools.jcmd.JCmd -l27449 org.apache.activemq.apollo.boot.Apollo /usr/local/tbroker/lib\;/usr/local/apollo-1.7.1/lib org.apache.activemq.apollo.cli.Apollo runjps1283 Bootstrap27449 Apollo2315 Jps</code></pre><p>查看 JVM 的启动时长：</p><pre><code>jcmd PID VM.uptime</code></pre><p>查看 JVM 的类信息：这个可以查看每个类的实例数量和占用空间大小。</p><pre><code>jcmd PID GC.class_histogram</code></pre><p>查看 JVM 的线程快照：</p><pre><code>jcmd PID Thread.print</code></pre><p>查看 JVM 的Heap Dump：</p><pre><code>jcmd PID GC.heap_dump FILE_NAME</code></pre><p><strong>注意</strong>，如果只指定文件名，默认会生成在启动 JVM 的目录里。</p><p>查看 JVM 的属性信息：</p><pre><code>jcmd 1283 VM.system_properties1283:java.lang.OutOfMemoryError: Java heap space</code></pre><p>查看 JVM 的启动参数：注意，可以看到 -X 和 -XX 的参数信息，比较有用。</p><pre><code>jcmd 1283 VM.flags1283:-XX:CICompilerCount=2 -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=262144000 -XX:MaxNewSize=87359488 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=5570560 -XX:OldSize=11206656 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops </code></pre><p>查看 JVM 的启动命令行：</p><pre><code>jcmd 1283 VM.command_line</code></pre><p>对JVM执行 java.lang.System.runFinalization()：</p><pre><code>jcmd 1283 GC.run_finalization</code></pre><p>对JVM执行 java.lang.System.gc()：</p><pre><code>jcmd 1283 GC.run</code></pre><p><strong>注意：</strong>告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的。</p><p>查看 JVM 的性能：</p><p>jcmd PID PerfCounter.print</p><p><strong>补充</strong> </p><p>常用命令</p><pre><code>toptop -p 1909 -Hfree free -m</code></pre><p>高内存占用分析</p><pre><code>ps -mp 1909 -o THREAD,tid,time,rss,size,%mem</code></pre><p>查看进程内存</p><pre><code>pmap -x 5454pmap -q 5454pmap -d -q 5454</code></pre>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm垃圾回收器</title>
      <link href="/2018/08/07/java-jvm-gc/"/>
      <url>/2018/08/07/java-jvm-gc/</url>
      
        <content type="html"><![CDATA[<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>1.标记-清除算法(Mark-Sweep):</p><p>缺点：</p><blockquote><p>效率不高</p><p>产生大量不连续的内存碎片</p></blockquote><a id="more"></a><p>2.复制算法</p><p>优点：</p><blockquote><p>实现简单，运行高效</p></blockquote><p>缺点：</p><blockquote><p>内存浪费</p></blockquote><p>商业用例：</p><pre><code>Eden:Survivor = 8:1</code></pre><p>3.标记-整理算法/标记-压缩算法</p><p>4.分代收集算法</p><blockquote><p>新生代：复制算法</p><p>老年代：标记-清除/标记-整理</p></blockquote><h3 id="案例分析：HotSpot的实现"><a href="#案例分析：HotSpot的实现" class="headerlink" title="案例分析：HotSpot的实现"></a>案例分析：HotSpot的实现</h3><p>1.枚举根节点</p><p>2.安全点</p><p>3.安全区域</p><h2 id="gc回收器"><a href="#gc回收器" class="headerlink" title="gc回收器"></a>gc回收器</h2><p>常用的参数</p><table><thead><tr><th>参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>UseSerialGC</td><td style="text-align:center">client模式下的默认值，Serial + Serial Old收集器</td></tr><tr><td>UseParallelGC</td><td style="text-align:center">Server模式下的默认值，Parallel Scavenge + Serial Old收集器</td></tr></tbody></table><h3 id="1-Serial"><a href="#1-Serial" class="headerlink" title="1. Serial"></a>1. Serial</h3><h3 id="2-ParNew"><a href="#2-ParNew" class="headerlink" title="2. ParNew"></a>2. ParNew</h3><h3 id="3-Parallel-Scavenge"><a href="#3-Parallel-Scavenge" class="headerlink" title="3. Parallel Scavenge"></a>3. Parallel Scavenge</h3><h3 id="4-Serial-Old"><a href="#4-Serial-Old" class="headerlink" title="4. Serial Old"></a>4. Serial Old</h3><h3 id="5-Parallel-Old"><a href="#5-Parallel-Old" class="headerlink" title="5. Parallel Old"></a>5. Parallel Old</h3><h3 id="6-CMS"><a href="#6-CMS" class="headerlink" title="6. CMS"></a>6. CMS</h3><p>(并发低停顿收集器), 基于标记-清除算法</p><p>目标：以获取最短回收停顿时间</p><p>原理：</p><blockquote><p>初始标记</p><p>并发标记</p><p>重新标记</p><p>并发清除</p></blockquote><p>优点：</p><p>缺点：</p><blockquote><p>对CPU资源非常敏感</p><p>无法处理浮动垃圾</p><p>产生大量空间碎片</p></blockquote><h3 id="7-G1"><a href="#7-G1" class="headerlink" title="7. G1"></a>7. G1</h3><p>目标：</p><p>原理：</p><p>概念：<br>优先列表</p><p>Region</p><p>Remembered Set</p><p>Write Barrier</p><p>CarTable</p><blockquote><p>初始标记</p><p>并发标记</p><p>最终标记</p><p>筛选回收</p></blockquote><p>优点：</p><blockquote><p>并行与并发</p><p>分代收集</p><p>空间整合：与CMS的标记-清除算法不同，G1整理看是标记-整理算法，局部(Region)看则是复制算法，不会产生内存碎片。</p><p>可预测的停顿：这是G1相比CMS的一大优势，降低停顿时间时G1和CMS共同的关注点，但G1除了追求低停顿，还能建立可预测的停顿时间模型</p></blockquote><p>缺点：</p><h3 id="8-ZGC"><a href="#8-ZGC" class="headerlink" title="8. ZGC"></a>8. ZGC</h3><p>目标：</p><blockquote><p>GC停顿时间不超过10ms<br>处理堆从MB到TB<br>相比G1减少了15%的吞吐量</p></blockquote><h3 id="9-Shenandoah-GC"><a href="#9-Shenandoah-GC" class="headerlink" title="9. Shenandoah GC"></a>9. Shenandoah GC</h3><p>对比：</p><p>Zing/Azul有一个低停顿的收集器，但是没有贡献到OpenJDK。</p><p>ZGC是基于colored pointers的收集器。Shenandoah GC是基于brook pointer的收集器。</p><p>G1可以并行、并发的工作，但是不能并发的evacuation。</p><p>CMS并发标记，在停顿期间复制年轻代，但是不压缩老年代。结果导致更多的时间管理剩余空间和碎片空间。</p><h2 id="内存分配、回收策略"><a href="#内存分配、回收策略" class="headerlink" title="内存分配、回收策略"></a>内存分配、回收策略</h2><p>Minor GC: 指发生在新生代的垃圾回收动作</p><p>Full GC/Major GC: 指发生在老年代的GC，出现Full GC，经常会伴随至少一次Minor GC;</p><p><strong>如果更细粒度，Major GC可以认为只对老年的GC，而Full GC是对整个堆来说的。</strong></p><p>1、对象优先在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</p><p>2、大对象直接进入老年代。大对象典型的就是那些很长的字符串、数组</p><p>参数-XX:PretenureSizeThreshold可以设定大对象的标准</p><p>3、长期存活的对象将进入老年代(默认是15岁)</p><p>Eden区对象经过Minor GC后，年龄增1，然后在Survivor每经历一次Minor GC，年龄增长1，达到指定年龄，进入老年代</p><p>参数-XX:MaxTenuringThreshold</p><p>4、动态年龄判定</p><p>如果在Survivor区，相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于等于该年龄的对象可以直接进入老年代。【可以破坏规则3】</p><p>5、空间分配担保</p><h3 id="GC触发"><a href="#GC触发" class="headerlink" title="GC触发"></a>GC触发</h3><p><a href="https://blog.csdn.net/chenleixing/article/details/46706039" target="_blank" rel="noopener">参考</a></p><p>Minor GC触发条件：</p><blockquote><p>Eden区没有足够空间分配时，触发</p></blockquote><p>Full GC触发条件：</p><blockquote><ol><li><p>显式调用System.gc()。可以通过-XX:+ DisableExplicitGC禁止显式调用</p></li><li><p>方法区(永生代)空间不足。方法区在HotSpot中又被称为永生代/永生区。如果被占满，在未配置为CMS GC的情况下，会执行一次Full GC，如果空间还是不足，则抛出异常java.lang.OutOfMemoryError: PermGen space </p></li><li><p>老年代空间不足。出现的原因：新生代对象转入；分配大对象、大数组。如果Full GC后空间仍然不够，则抛出java.lang.OutOfMemoryError: Java heap space </p></li><li><p>Eden区对象执行Minor GC后，进入老年代的所有对象和大于老年代可用内存时，触发Full GC</p></li><li><p>(promotion failed)Eden + From执行Minor GC时，如果存活对象大于To内存区，则直接进入老年代，如果老年代的可用内存小于该对象，则触发Full GC</p></li><li><p>(concurrent mode failure)执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足，则执行一次Full GC </p></li></ol></blockquote><p><strong>注意:</strong>jdk1.6_24之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会执行Minor GC,否则进行Full GC</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的事务机制</title>
      <link href="/2018/08/07/spring-transaction/"/>
      <url>/2018/08/07/spring-transaction/</url>
      
        <content type="html"><![CDATA[<h2 id="事务的7种传播机制"><a href="#事务的7种传播机制" class="headerlink" title="事务的7种传播机制"></a>事务的7种传播机制</h2><p>TransactionDefinition接口中定义了7种类型的事务传播机制：</p><ol><li><p>PROPAGATION_REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。<strong>这是最常见的选择，也是 Spring 默认的事务的传播</strong>。</p></li><li><p>PROPAGATION_REQUIRES_NEW: 新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，<strong>外层事务失败回滚之后，不能回滚内层事务执行的结果</strong>，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作</p></li><li><p>PROPAGATION_SUPPORTS: 支持当前事务，如果当前没有事务，就以非事务方式执行。</p></li><li><p>PROPAGATION_MANDATORY: 支持当前事务，如果当前没有事务，就抛出异常。</p></li><li><p>PROPAGATION_NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p></li><li><p>PROPAGATION_NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常。</p></li><li><p>PROPAGATION_NESTED: 嵌套事务   </p></li></ol><a id="more"></a><h2 id="事务的5种隔离级别"><a href="#事务的5种隔离级别" class="headerlink" title="事务的5种隔离级别"></a>事务的5种隔离级别</h2><ol><li><p>ISOLATION_DEFAULT: <strong>PlatfromTransactionManager默认的隔离级别</strong>，使用后端数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。MySQL默认使用REPEATABLE_READ，Oracle默认采用READ_COMMITED</p></li><li><p>ISOLATION_READ_UNCOMMITTED: 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</p></li><li><p>ISOLATION_READ_COMMITTED: 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。<strong>可以防止脏读</strong></p></li><li><p>ISOLATION_REPEATABLE_READ: 事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</p></li><li><p>ISOLATION_SERIALIZABLE: 花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</p></li></ol><h2 id="事务失效的情况"><a href="#事务失效的情况" class="headerlink" title="事务失效的情况"></a>事务失效的情况</h2><p>1、MySQL数据表的引擎必须为InnoDB，MyISAM引擎不支持事务</p><p>2、调用的类必须是由Spring容器管理的代理类</p><p>jdk代理</p><p>cglib代理</p><p>3、调用的方法必须是public方法，这是由Spring的AOP特性决定的</p><p>4、抛出runtimeException才能回滚。</p><p>事务默认支持CheckException不会滚，unCheckException回滚，如果需要checkException回滚，注解需要标明@Transactional(rollbackFor=Exception.class)</p><p>5、事务传播策略在内部方法调用时将不起作用</p><p>情景1：</p><pre><code>public void insert2(Person person, Book book){    insert(person, book);}@Transactionalpublic void insert(Person person, Book book){    insertPerson(person);    insertBook(book);}personServiceImpl.insert(person, book)事务起作用personServiceImpl.insert2(person, book)事务不起作用</code></pre><p>解决方案1：</p><blockquote><p>增加&lt;aop:config proxy-target-class=”true” expose-proxy=”true”&gt;&lt;/aop:config&gt;</p><p>在外层调用内层的事务方法时使用AopContext代理 </p></blockquote><pre><code>public void insert2(Person person, Book book){    ((PersonServiceImpl)AopContext.currentProxy()).insert(person, book);}</code></pre><p>解决方案2：</p><blockquote><p>增加&lt;aop:config proxy-target-class=”true”&gt;&lt;/aop:config&gt;</p><p>在外层调用内层的事务方法时使用Spring的IOC容器代理 </p></blockquote><pre><code>@Autowiredprivate ApplicationContext ctx;public void insert2(Person person, Book book){    ctx.getBean(PersonServiceImpl.class).insert(person, book);;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring, 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中的锁lock</title>
      <link href="/2018/08/07/mysql-lock/"/>
      <url>/2018/08/07/mysql-lock/</url>
      
        <content type="html"><![CDATA[<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="1-表级锁-MyISAM-："><a href="#1-表级锁-MyISAM-：" class="headerlink" title="1. 表级锁(MyISAM)："></a>1. 表级锁(MyISAM)：</h3><blockquote><p>开销小，加锁快</p><p>不会出现死锁</p><p>锁定力度大，发生锁冲突概率最高，并发度低</p></blockquote><a id="more"></a><h4 id="表共享读锁、表独占写锁"><a href="#表共享读锁、表独占写锁" class="headerlink" title="表共享读锁、表独占写锁"></a>表共享读锁、表独占写锁</h4><p>MyISAM在执行select语句时，会自动给相关表加读锁；<br>执行insert/update/delete    语句时，自动加写锁；</p><pre><code>LOCK tables table1 read local, table2 read local;select ***select ***Unlock tables;</code></pre><p>local：</p><p>锁升级：</p><h3 id="2-行级锁-InnoDB-："><a href="#2-行级锁-InnoDB-：" class="headerlink" title="2. 行级锁(InnoDB)："></a>2. 行级锁(InnoDB)：</h3><blockquote><p>开销大，加锁慢</p><p>会导致死锁</p><p>锁定粒度最小，发生锁冲突最低，并发度也最高</p></blockquote><h4 id="事务ACID"><a href="#事务ACID" class="headerlink" title="事务ACID"></a>事务ACID</h4><p>原子性</p><p>一致性</p><p>隔离性</p><p>持久性</p><h4 id="事务带来的问题"><a href="#事务带来的问题" class="headerlink" title="事务带来的问题"></a>事务带来的问题</h4><p>更新丢失</p><p>脏读</p><p>不可重复度</p><p>幻读</p><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ol><li>加锁</li><li>MVCC多版本控制</li></ol><table><thead><tr><th>隔离级别/读数据一致性及允许的并发副作用</th><th style="text-align:center">读数据一致性</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td>未提交读(Read uncommitted)</td><td style="text-align:center">最低级别，只能保证不读取物理上损坏的数据</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td>已提交度(Read committed)</td><td style="text-align:center">语句级</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td>可重复读(Repeatable read)</td><td style="text-align:center">事务级</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td>可序列化(Serializable)</td><td style="text-align:center">最高级别，事务级</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr></tbody></table><p>查看系统行级锁占用</p><pre><code>show status like &apos;innodb_row_lock%&apos;;</code></pre><h4 id="共享锁-S-、排他锁-X"><a href="#共享锁-S-、排他锁-X" class="headerlink" title="共享锁(S)、排他锁(X)"></a>共享锁(S)、排他锁(X)</h4><p>显式加锁：</p><pre><code>共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE</code></pre><h4 id="意向共享锁-IS-、意向排他锁-IX"><a href="#意向共享锁-IS-、意向排他锁-IX" class="headerlink" title="意向共享锁(IS)、意向排他锁(IX)"></a>意向共享锁(IS)、意向排他锁(IX)</h4><p>这两种锁都是<strong>表锁</strong></p><p><strong>注意：</strong>只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！</p><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><h3 id="3-页面锁："><a href="#3-页面锁：" class="headerlink" title="3. 页面锁："></a>3. 页面锁：</h3><pre><code>&gt; 开锁、加锁时间介于表锁和行锁之间，&gt; &gt; 会导致死锁&gt; &gt; 粒度介于两者之间，并发度一般</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized和ReentrantLock</title>
      <link href="/2018/08/07/java-synchronized-lock/"/>
      <url>/2018/08/07/java-synchronized-lock/</url>
      
        <content type="html"><![CDATA[<p>Java内置锁和Lock</p><a id="more"></a><h2 id="1、synchronized"><a href="#1、synchronized" class="headerlink" title="1、synchronized"></a>1、synchronized</h2><h3 id="sychronized的几种不同用法："><a href="#sychronized的几种不同用法：" class="headerlink" title="sychronized的几种不同用法："></a>sychronized的几种不同用法：</h3><p>1、修饰类</p><p>锁的对象是该类的所有实例</p><p>2、修饰静态方法</p><p>锁的对象是该类的所有实例对象</p><p>3、修饰方法</p><p>锁的对象是调用该方法的实例对象</p><p>4、修饰代码块</p><p>和修饰方法类似，锁对象都是调用该方法的实例对象</p><h2 id="2、ReentrantLock"><a href="#2、ReentrantLock" class="headerlink" title="2、ReentrantLock"></a>2、ReentrantLock</h2><h2 id="3、synchronize和ReentrantLock的比较"><a href="#3、synchronize和ReentrantLock的比较" class="headerlink" title="3、synchronize和ReentrantLock的比较"></a>3、synchronize和ReentrantLock的比较</h2><p>ReentranLock使用场景：</p><blockquote><p>需要时间锁、可中断锁、无块结构锁、轮询锁、多个条件变量时使用</p><p>需要可伸缩性、高度竞争的情况下使用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2018/08/07/java-threadpool/"/>
      <url>/2018/08/07/java-threadpool/</url>
      
        <content type="html"><![CDATA[<p>“Stay hungry,Stay foolish”, 要时刻保持学习的激情，要经常温故而知新</p><h2 id="Executors中的静态工厂方法"><a href="#Executors中的静态工厂方法" class="headerlink" title="Executors中的静态工厂方法"></a>Executors中的静态工厂方法</h2><ol><li><p>newFixedThreadPool:创建一个固定长度的线程池，(无界的阻塞队列LinkedBlockingQueue)</p></li><li><p>newSingleThreadExecutor:创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程代替(无界的阻塞队列LinkedBlockingQueue)</p><p> <strong>注意：</strong> 因为以上两个都是使用的无界队列，允许请求队列长度为Integer.MAX_VALUE，所以可能堆积大量的请求，导致OOM</p></li><li><p>newCachedThreadPool:创建一个可缓存的线程池，(队列SynchronizedQueue)</p></li><li><p>newScheduledThreadPool:创建一个固定长度的线程池，而且以延迟或者定时的方式来执行任务,类似于Timer</p></li></ol><p><strong>注意：</strong>以上两个允许创建线程数为Integer.MAX_VALUE,可能创建大量线程，导致OOM</p><a id="more"></a><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="创建与销毁"><a href="#创建与销毁" class="headerlink" title="创建与销毁"></a>创建与销毁</h3><pre><code>public ThreadPoolExecutor(int corePoolSize,                      int maximumPoolSize,                      long keepAliveTime,                      TimeUnit unit,                      BlockingQueue&lt;Runnable&gt; workQueue,                      ThreadFactory threadFactory,                      RejectedExecutionHandler handler) {}</code></pre><p>corePoolSize:没有任务执行时线程池的大小，当工作队列满了的时候，才会创建超出该数量的线程</p><p>maximumPoolSize:表示可同时活动的线程数量的上限</p><p>keepAliveTime:空闲线程存活时间，如果某个线程的空闲时间超过了keepAliveTIme，则被标记为可回收，并且当线程池当前大小超出corePoolSize时，这个线程将被终止。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>基本的任务队列有3种：</p><ol><li><p>无界队列：</p><blockquote><p>ArrayBlockingQueue：先进先出队列，任务的执行顺序和到达顺序一致</p></blockquote></li><li><p>有界队列：</p><blockquote><p>LinkedBlockingQueue：用链表实现的队列，可以是有界的，也可以是无界的</p><p>PriorityBlockingQueue：根据任务优先级安排任务，可以进一步控制任务的执行顺序</p></blockquote><p> 有界队列可以避免资源耗尽，同时带来问题，当队列已满的时候，新任务需要配合饱和策略执行。</p></li><li><p>同步移交</p><blockquote><p>SynchronouseQueue：对于非常大或者无界的线程池，可以通过使用该队列避免任务排队。原理：如果有线程等待，直接移交给线程；如果没有线程，且当前线程数量corePoolSize，则创建一个新线程移交；否则根据饱和策略处理。所以使用SynchronouseQueue时，maximumPoolSize是不起作用的。</p></blockquote></li></ol><h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><p>当线程池已满，同时队列也满了以后，根据饱和策略处理请求线程</p><p>JDK提供了4种饱和策略：</p><blockquote><p>AbortPolicy:默认的饱和策略，当队列满时，将抛出未检查的RejectedExecutionException</p><p>CallerRunsPolicy:该策略不会抛弃任务，也不会抛出异常，而是将任务交给提交任务的线程执行，从而降低新任务的流量</p><p>DiscardPolicy:当新提交的任务无法保存到队列时，该策略将抛弃该任务</p><p>DiscardOldestPolicy:该策略将抛弃下一个被执行的任务(即最早排队而尚未执行的任务)，然后重新提交新任务</p></blockquote><h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><p>默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息</p><pre><code>public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue) {    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,         Executors.defaultThreadFactory(), defaultHandler);}</code></pre><p>可以看到默认情况下，使用DefaultThreadFactory线程工厂，AbortPolicy策略</p><h2 id="Thread-Pool使用不当导致的死锁"><a href="#Thread-Pool使用不当导致的死锁" class="headerlink" title="Thread Pool使用不当导致的死锁"></a>Thread Pool使用不当导致的死锁</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原子变量与非阻塞同步机制</title>
      <link href="/2018/07/31/java-atomic/"/>
      <url>/2018/07/31/java-atomic/</url>
      
        <content type="html"><![CDATA[<p>非阻塞算法：用底层的原子机器指令(比较交换指令)代替锁来确保数据并发访问的一致性。</p><p>优点：</p><blockquote><p>在粒度更细的层次上进行协调，极大地减少调度开销。</p><p>不存在死锁和其它活跃性问题。</p></blockquote><a id="more"></a><h2 id="硬件对并发的支持"><a href="#硬件对并发的支持" class="headerlink" title="硬件对并发的支持"></a>硬件对并发的支持</h2><p>处理器实现原子指令：</p><p>CAS: 比较并交换(Compare-and-Swap)</p><p>LL/SC: 关联加载/条件存储(Load-Linked/Store-Conditional)</p><h3 id="1、比较并交换"><a href="#1、比较并交换" class="headerlink" title="1、比较并交换"></a>1、比较并交换</h3><p>CAS包括3个操作数：</p><blockquote><p>需要读写的内存位置V</p><p>进行比较的值A</p><p>拟写入的新值B</p></blockquote><p>当且仅当V=A时，CAS才会通过原子方式用新值B来更新V的值。</p><p>优点：</p><blockquote><p>在竞争程度不高时，性能远远超过基于锁</p></blockquote><p>缺点：</p><blockquote><p>它使调用者处理竞争问题(通过重试、回退、放弃)，而在锁中能自动处理竞争问题(线程在获得锁之前将一直阻塞)</p></blockquote><p>2、</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程</title>
      <link href="/2018/07/27/java-thread-base/"/>
      <url>/2018/07/27/java-thread-base/</url>
      
        <content type="html"><![CDATA[<p>synchronized</p><p>public static void synchronized </p><a id="more"></a><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>当且仅当满足以下所有条件时，才应该使用volatile变量：</p><p>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值；</p><p>该变量不会与其它状态变量一起纳入不变性条件中；</p><p>在访问变量时不需要加锁。</p><p>发布：</p><p>逸出：</p><p>构造过程导致this引用逸出的常见错误：</p><p>1、在构造函数中启动一个线程。在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个sart/initialize方法启动它。</p><p>2、在构造函数中调用一个可改写的实例方法时(既不是私有方法，也不是终结方法)</p><p>如果在构造函数中注册一个事件监听器或者启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法。</p><p>线程封闭：如果仅在单线程内访问数据，就不需要同步，这种技术被称为线程封闭</p><p>应用场景：</p><blockquote><p>在Swing中大量使用</p><p>JDBC的Connection对象</p></blockquote><p>1、Ad-hoc线程封闭：维护线程封闭性的职责完全由程序来承担</p><p>Demo:</p><p>2、栈封闭：将对象封闭在栈内，只能通过局部变量才能访问</p><p>Demo:</p><p>3、TreadLocal类:</p><p>场景：</p><blockquote><p>通常用于防止对可变的单实例变量、全局变量进行共享</p></blockquote><p>Demo:</p><pre><code>private static ThreadLocal&lt;Connection&gt; connection = new ThreadLocal&lt;Connection&gt;(){};</code></pre><h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><p>闭锁(CountdownLatch)：</p><p>FutureTask</p><p>信号量(Semphore):</p><p>栅栏(CyclicBarrier):</p><h3 id="基本的任务排队方法"><a href="#基本的任务排队方法" class="headerlink" title="基本的任务排队方法"></a>基本的任务排队方法</h3><p>1、无界队列</p><p>2、有界队列</p><p>3、同步移交</p><p>SynchronousQueue</p><p>ArrayBlockingQueue</p><p>LinkedBlockingQueue</p><p>PriorityBlockingQueue</p><h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><p>AbortPolicy</p><p>CallerRunsPolicy</p><p>DiscardPolicy</p><p>DiscardOldestPolicy</p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>Synchronized和ReentrantLock</p><p>独占锁和读写锁(ReentrantReadWriteLock/ReadWriteLock)</p><p>ConcurrentHashMap(ConcurrentMap)</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>基于AQS实现的类：</p><p>CountDownLatch</p><p>Semaphore</p><p>FutureTask</p><p>SynchronousQueue</p><p>ReentrantLock</p><p>ReentrantReadWriteLock</p><h2 id="原子变量与非阻塞同步机制"><a href="#原子变量与非阻塞同步机制" class="headerlink" title="原子变量与非阻塞同步机制"></a>原子变量与非阻塞同步机制</h2><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Happens-Before原则：</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派实现简单的人脸识别</title>
      <link href="/2018/07/25/raspberry-facerecognition/"/>
      <url>/2018/07/25/raspberry-facerecognition/</url>
      
        <content type="html"><![CDATA[<p><strong>硬件需求：</strong></p><blockquote><p>树莓派开发板</p><p>pi摄像头</p><p>16g内存卡</p><p>读卡器</p></blockquote><a id="more"></a><h2 id="1、更新镜像源"><a href="#1、更新镜像源" class="headerlink" title="1、更新镜像源"></a>1、更新镜像源</h2><pre><code>apt-get updateapt-get upgradeapt-get install python-opencv</code></pre><h2 id="2、针对PiCamera安装包"><a href="#2、针对PiCamera安装包" class="headerlink" title="2、针对PiCamera安装包"></a>2、针对PiCamera安装包</h2><pre><code>apt-get install python-pipapt-get install python-devpip install picamera</code></pre><p><strong>pip报错(1)</strong></p><p>TypeError: unsupported operand type(s) for -=: ‘Retry’ and ‘int’</p><p>解决方案：pip内部bug,升级pip版本</p><p><strong>pip报错(2)</strong></p><p>from pip import main ImportError: cannot import name main</p><p>解决方案：pip版本冲突，pip -V; cd /usr/bin; cat pip; mv pip9.0; pip2 -V</p><p><strong>下载open-cv报错</strong></p><p>Unable to establish SSL connection</p><p>解决方案：手动下载</p><p><a href="https://github.com/opencv/opencv/archive/3.4.0.tar.gz" target="_blank" rel="noopener">https://github.com/opencv/opencv/archive/3.4.0.tar.gz</a></p><p><a href="https://codeload.github.com/opencv/opencv_contrib/zip/master" target="_blank" rel="noopener">https://codeload.github.com/opencv/opencv_contrib/zip/master</a></p><h3 id="安装视频I-O包"><a href="#安装视频I-O包" class="headerlink" title="安装视频I/O包"></a>安装视频I/O包</h3><pre><code>sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt-get install libgtk2.0-dev</code></pre><h3 id="优化函数包："><a href="#优化函数包：" class="headerlink" title="优化函数包："></a>优化函数包：</h3><p><code>sudo apt-get install libatlas-base-dev gfortran</code></p><p><strong>报错,安装依赖包</strong></p><pre><code>apt-get install libgstreamer-plugins-base1.0-devapt-get install libgphoto2-devapt-get install libavresample-devapt-get install libdc1394-22-devapt-get install libgtk-3-dev</code></pre><p><strong>如果中间缺少以下依赖包，则进行安装</strong><br>apt-get install gtk+-3.0 gtk+-2.0 gthread-2.0 gstreamer-base-1.0</p><p>apt-get install libavresample libgphoto2</p><h2 id="3、编译open-cv"><a href="#3、编译open-cv" class="headerlink" title="3、编译open-cv"></a>3、编译open-cv</h2><p><code>sudo cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local  -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.3.1/modules ..    -D INSTALL_PYTHON_EXAMPLES=ON \    -D BUILD_EXAMPLES=ON ..</code></p><h2 id="4、编写pytho脚本，并执行"><a href="#4、编写pytho脚本，并执行" class="headerlink" title="4、编写pytho脚本，并执行"></a>4、编写pytho脚本，并执行</h2><pre><code>python TestOpencv.py </code></pre><p><strong>报错</strong></p><p>Found 0 face(s)</p><p>Unable to init server: Could not connect: Connection refused</p><p>(Frame:15788): Gtk-WARNING **: cannot open display: </p><p>解决：原因是raspberry系统stetch最小化安装，没有图形界面</p><pre><code>sudo apt-get install xorgsudo apt-get install lxde openboxsudo startx  #不要通过ssh执行sudo apt-get install raspberrypi-ui-mods</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raspberry, python, 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础入门</title>
      <link href="/2018/07/25/go-base/"/>
      <url>/2018/07/25/go-base/</url>
      
        <content type="html"><![CDATA[<p>一段时间不写Go,很多东西都忘了，还是记录一下吧！</p><h2 id="一、基础入门"><a href="#一、基础入门" class="headerlink" title="一、基础入门"></a>一、基础入门</h2><p><code>go run hello.go</code></p><p>行分隔符：一行代表一个语句结束，不需要分号’;’，多个语句在一行使用’;’，类似于Scala</p><p>25个关键字：</p><p>break  default    func  interface     select<br>case    defer    go    map    struct<br>chan    else    goto    package    switch<br>const    fallthrough    if    range    type<br>continue    for    import    return    var</p><a id="more"></a><p>36个预定义标识符:</p><p>append     bool     byte     cap     close     complex     complex64     complex128     uint16<br>copy     false     float32     float64     imag     int     int8     int16     uint32<br>int32     int64     iota     len     make     new     nil     panic     uint64<br>print     println     real     recover     string     true     uint     uint8     uintptr</p><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p>1、布尔类型</p><p>2、数字类型</p><blockquote><p>uint8 无符号 8 位整型 (0 到 255)</p><p>uint16 无符号 16 位整型 (0 到 65535)</p><p>uint32 无符号 32 位整型 (0 到 4294967295)</p><p>uint64 无符号 64 位整型 (0 到 18446744073709551615)</p><p>int8 有符号 8 位整型 (-128 到 127)</p><p>int16 有符号 16 位整型 (-32768 到 32767)</p><p>int32 有符号 32 位整型 (-2147483648 到 2147483647)</p><p>int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</p></blockquote><p>byte 类似 uint8<br>rune 类似 int32<br>uint 32 或 64 位<br>int 与 uint 一样大小<br>uintptr 无符号整型，用于存放一个指针</p><p>3、字符串类型</p><p>4、派生类型：<br>    (a) 指针类型（Pointer）<br>    (b) 数组类型<br>    (c) 结构化类型(struct)<br>    (d) Channel 类型<br>    (e) 函数类型<br>    (f) 切片类型<br>    (g) 接口类型（interface）<br>    (h) Map 类型 </p><h2 id="三、变量与常量"><a href="#三、变量与常量" class="headerlink" title="三、变量与常量"></a>三、变量与常量</h2><table><thead><tr><th>数据类型</th><th style="text-align:center">初始化默认值</th></tr></thead><tbody><tr><td>int</td><td style="text-align:center">0</td></tr><tr><td>float32</td><td style="text-align:center">0</td></tr><tr><td>pointer</td><td style="text-align:center">nil</td></tr></tbody></table><p>1、var 声明变量</p><p>`var identifier type  //声明后若不赋值，则使用默认值</p><p>var v_name = value  //不声明类型时，执行类型推断，类似于Scala</p><p>v_name := value`</p><p>多变量声明：var a, b, c = a1, b1, c1</p><p>2、const 声明常量<br>const可以用于枚举</p><p>`const( </p><p>  Unkonwn = 0</p><p>  Female = 1</p><p>  Male = 2</p><p>)<br>`</p><p>常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过</p><p><code>const(    a = &quot;abc&quot;    b = len(a))</code></p><p>3、<strong>iota 特殊常量</strong></p><p>空白标识符’_’用于抛弃值，类似于Scala</p><h2 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h2><p>Go语言循环中有：break、continue、goto</p><h2 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h2><p>Go语言中全局变量和局部变量可以相同，函数内变量优先考虑</p><p>Go函数可以返回多个值，这个比Java好很多</p><p><code>func swap(x, y string) (string, string){    return y, x}</code></p><p>值传递: 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p><p>引用传递: 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><p><strong>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</strong></p><p>函数作为值传递，类似于Scala高阶函数<br>getSquareRoot := func(x float64) float64 {  //类似于Scala匿名函数<br>    return math.Sqrt(x)<br>}</p><p><em>Go支持匿名函数可以作为闭包，和Scala的闭包有什么区别？</em></p><p>Go语言中函数不同于方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。</p><p><strong>接口类型(interface)</strong></p><p><strong>方法集</strong></p><h2 id="六、"><a href="#六、" class="headerlink" title="六、"></a>六、</h2><p>1、数组</p><p><code>var array [size] arr_typevar array = [5]int{1,2,3,4,5}</code></p><p>2、切片：切片是对数组的抽象，数组长度不可变，切片是动态数组<br><code>var slice [] slice_typevar slice [] slice_type = make([]slice_type, len)slice := make([]slice_type, len)</code></p><p>3、范围range 类似于Java在for-Each，Scala中&lt;-遍历<br>Go 语言中 range 关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。<br>在数组和切片中它返回元素的索引值，在集合中返回 key-value 对的 key 值。 </p><p>4、Map声明后必须make初始化，否则为nil，类似于Java的null</p><p><code>var cmap map[string]stringcmap = make(map[string]string)</code></p><p>5、类型转换，不同于Java的向上向下转型</p><p><code>var i int = 10float32(i)</code></p><p>结构体：类似于c语言的结构体</p><p>结构体指针</p><h2 id="七、错误处理"><a href="#七、错误处理" class="headerlink" title="七、错误处理"></a>七、错误处理</h2><p>Go语言通过内置的错误接口(error)提供了非常简单的错误处理机制。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言, go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三十而立(Thirtysomething)</title>
      <link href="/2018/07/24/thinking-about-thirty/"/>
      <url>/2018/07/24/thinking-about-thirty/</url>
      
        <content type="html"><![CDATA[<p>虽说不是三十，却也是即将奔三。</p><p>2018年2月份的时候离开上家公司，当初胸怀大志，希望出来能在一个更好的平台上施展一番。如今已经过去四之三，却感觉收获寥寥无几。其实这半年经历了很多的事情，也想了很多很多的东西：关于爱情，关于工作，关于生活。正好最近空闲下来，好好整理下自己，也整理一下生活。</p><a id="more"></a><h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>一塌糊涂的爱情，和她见过最后一面，吃过最后一顿饭，走过最后一段，我想，也许我还没有放下，但生活总要继续。过年去姑姑家拜年的时候，也是各种被劝说，一直以来自己也想了很多，但是缘分这种事情，也是急不来的。从《不能承受的生命之轻》到《霍乱时期的爱情》，爱情观被不断的冲击，最近开始让自己静下来，遇到真正合适的再义无反顾的去争取吧。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>三月份来到新的公司，项目组是新组建的，管理上一塌糊涂，哎。对写代码的热情被慢慢的消耗，很多时候我都在想，什么才是有意义的工作，怎样才能发挥自己最大的价值，究竟该选择什么方向努力。希望能尽快步入正轨吧。</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>四月份飞了重庆，当初说好带她去重庆的，结果是自己一个人去，中间在三生有信还看到一个女生一边抹着眼泪，一边给某人写着寄语。</p><p>五月份第一次远程骑行到十三陵，摔了膝盖疼了好几天，骑行中间还突然下了一场雨，感觉好狼狈，由于没有远程骑行经验，中间轮子还掉了两次。。。最后终于在十一点多回家，累到倒床就睡。</p><p>上周末搬了家，终于从一个“北京村”，搬到了另一个“北京村”，好在新的“村”是个小区，虽然环境不是那么理想，但终于脱离了那种杂乱的环境，为了再接再厉吧！</p><p>今年可以说是熬夜最多的一年，更多的还是因为生活中一些不如意的事情吧。有些时候我是一个很情绪化的人，遇到一些苦恼的事情，就会像很多很多，最后一觉醒来，也就没那么多烦恼。前一段时间，终于狠心办了张健身卡，终于第一次去健身房，想想也是自 工作以来，很少去健身房锻炼了，以后还是要规律饮食，勤去健身房才好。</p><h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>《人类简史》 终于完结了一下，真的是从2017年读到2018年，拖延症太可怕</p><p>《黑客与画家》 思想论的东西，和写代码有关，不得不佩服格雷厄姆思想的深刻，毕竟是硅谷创业之父啊</p><p>《引爆点》 有点心理学的意味，大多是在地铁上读完的，其实生活中很多的行为都是被潜移默化的影响</p><p>《商业的本质》 管理学，大师的作品，正好自己也有兴趣，正好就在地铁上完成吧</p><p>《小王子》 重读了一遍，还是有很多不同的感受</p><p>《无比无杂的心绪》 很符合今年上半年的心绪，又是偶然发现，村上村树的作品，写的很深刻，直入内心的触动，需要多读几遍</p><p>《独居的一年》 感觉有昆德拉的影子在里面，正在读</p><p>距离2019年还有五个月的时间，希望自己能在不断的思考中，更成熟、更深刻、更充实。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life, thirty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot注解自动装配原理分析</title>
      <link href="/2018/07/12/spring-boot-loader/"/>
      <url>/2018/07/12/spring-boot-loader/</url>
      
        <content type="html"><![CDATA[<p>熟悉Spring Boot项目搭建的同学都知道基本的配置。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先看Application main类需要基本的注解@SpringBootApplication：</p><pre><code>@RestController@SpringBootApplicationpublic class AutoconfigDemoTestApplication {    public static void main(String[] args) {        SpringApplication.run(AutoconfigDemoTestApplication.class, args);    }}</code></pre><p>进入@SpringBootApplication可以看到：</p><pre><code>@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = {        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {}</code></pre><p>除去基本的元注解，进入@SpringBootConfiguration，可以看到是一些基本的注解：</p><pre><code>@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration {}</code></pre><p>进入注解@EnableAutoConfiguration，可以看到除了注解@AutoConfigurationPackage，还有一个@Import(AutoConfigurationImportSelector.class)：</p><pre><code>@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration {    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;    //    Class&lt;?&gt;[] exclude() default {};    //    String[] excludeName() default {};}</code></pre><p>@AutoConfigurationPackage是一些：</p><pre><code>@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage {}</code></pre><p>进入AutoConfigurationImportSelector类，可以看到方法selectImports来确定要导入的类：</p><pre><code>@Overridepublic String[] selectImports(AnnotationMetadata annotationMetadata) {    if (!isEnabled(annotationMetadata)) {        return NO_IMPORTS;    }    // 加载&quot;META-INF/spring-autoconfigure-metadata.properties&quot;    AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader            .loadMetadata(this.beanClassLoader);    //    AnnotationAttributes attributes = getAttributes(annotationMetadata);    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,            attributes);    configurations = removeDuplicates(configurations);    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);    checkExcludedClasses(configurations, exclusions);    configurations.removeAll(exclusions);    configurations = filter(configurations, autoConfigurationMetadata);    fireAutoConfigurationImportEvents(configurations, exclusions);    return StringUtils.toStringArray(configurations);}</code></pre><p>先看方法getCandidateConfigurations，回头有时间再慢慢分析其它方法：</p><pre><code>protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,        AnnotationAttributes attributes) {    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(            getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());    Assert.notEmpty(configurations,            &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;                    + &quot;are using a custom packaging, make sure that file is correct.&quot;);    return configurations;}</code></pre><p>再看SpringFactoriesLoader.loadFactoryNames，可以知道最终读取的是所有jar包META-INF目录下的spring.factories文件：<br>    public static final String FACTORIES_RESOURCE_LOCATION = “META-INF/spring.factories”;</p><pre><code>public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {    String factoryClassName = factoryClass.getName();    return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());}private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);    if (result != null) {        return result;    }    try {        Enumeration&lt;URL&gt; urls = (classLoader != null ?                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));        result = new LinkedMultiValueMap&lt;&gt;();        while (urls.hasMoreElements()) {            URL url = urls.nextElement();            UrlResource resource = new UrlResource(url);            Properties properties = PropertiesLoaderUtils.loadProperties(resource);            for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {                List&lt;String&gt; factoryClassNames = Arrays.asList(                        StringUtils.commaDelimitedListToStringArray((String) entry.getValue()));                result.addAll((String) entry.getKey(), factoryClassNames);            }        }        cache.put(classLoader, result);        return result;    }    catch (IOException ex) {        throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +                FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);    }}</code></pre><h2 id="Fat-jar"><a href="#Fat-jar" class="headerlink" title="Fat jar"></a>Fat jar</h2><h3 id="PropertiesLauncher加载规则："><a href="#PropertiesLauncher加载规则：" class="headerlink" title="PropertiesLauncher加载规则："></a>PropertiesLauncher加载规则：</h3><blockquote><p>loader.properties属性，先在loader.home中查找； 再去classpath根路径查找； 最后到<code>classpath:/BOOT-INF/classes</code>中查找;第一次找到的即使用</p><p>如果loader.config.location没有配置，loader.home下的属性文件会覆盖默认的属性文件<br>loader.path可以包括目录、文件路径、jar包中的目录<code>dependencies.jar!/lib</code>、正则匹配；文件路径可以是loader.home指定的路径或者文件系统中以<code>jar:file:</code>前缀开头的路径</p><p>loader.path如果为空，默认放在<code>BOOT-INF/lib</code>下，同时loader.path不能用来配置loader.properties的存放路径</p><p>变量的搜索路径顺序：环境变量、系统变量、loader.properties、外部的manifest文件、内部的manifest文件</p></blockquote><h3 id="打包限制规则："><a href="#打包限制规则：" class="headerlink" title="打包限制规则："></a>打包限制规则：</h3><ol><li>zip压缩，必须使用ZipEntry.STORED方法压缩</li><li>SystemClassLoader，加载class文件使用Thread.getContextClassLoader()，使用ClassLoader.getSystemClassLoader()加载会导致失败，由于java.util.Logging类使用SystemClassLoader加载，所以需要重写Logging的继承类</li></ol><h3 id="可执行jar的其他构建方法"><a href="#可执行jar的其他构建方法" class="headerlink" title="可执行jar的其他构建方法"></a>可执行jar的其他构建方法</h3><ol><li>Maven Shade Plugin</li><li>JarClassLoader</li><li>OneJar</li><li>Gradle Shadow Plugin</li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, springboot, 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot内嵌tomcat分析</title>
      <link href="/2018/07/12/spring-boot-tomcat/"/>
      <url>/2018/07/12/spring-boot-tomcat/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot内嵌web容器tomcat，</p><a id="more"></a><h2 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h2>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, springboot, 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala基础入门</title>
      <link href="/2018/05/13/scala-base/"/>
      <url>/2018/05/13/scala-base/</url>
      
        <content type="html"><![CDATA[<p>与Scala大约是三年之前，在一本《程序员面试宝典》看到，2016年买了《Scala快速入门》，感觉好繁琐，后来慢慢放下，去年接触到Apache Apollo，是一个MQTT的代理服务器开源软件(貌似是2007年发布的，就没有更新过)。最近突然想要捡起来</p><p>学习新语言语法最快的途径就是打开<a href="http://www.runoob.com/scala/scala-tutorial.html" title="菜鸟教程Scala" target="_blank" rel="noopener">菜鸟教程网</a>跟着敲一遍，以下内容权当记录：</p><a id="more"></a><h4 id="一、基础语法："><a href="#一、基础语法：" class="headerlink" title="一、基础语法："></a>一、基础语法：</h4><blockquote><p>区分大小写 -  Scala是大小写敏感的，这意味着标识Hello 和 hello在Scala中会有不同的含义。</p></blockquote><blockquote><p>类名 - 对于所有的类名的第一个字母要大写。</p></blockquote><blockquote><p>如果需要使用几个单词来构成一个类的名称，每个单词的第一个字母要大写。示例：class MyFirstScalaClass</p></blockquote><blockquote><p>方法名称 - 所有的方法名称的第一个字母用小写。</p></blockquote><blockquote><p>如果若干单词被用于构成方法的名称，则每个单词的第一个字母应大写。示例：def myMethodName()</p></blockquote><blockquote><p>程序文件名 - 程序文件的名称应该与对象名称(object)完全匹配。</p></blockquote><blockquote><p>保存文件时，应该保存它使用的对象名称（记住Scala是区分大小写），并追加”.scala”为文件扩展名。 （如果文件名和对象名称不匹配，程序将无法编译）。</p></blockquote><blockquote><p>def main(args: Array[String]) - Scala程序从main()方法开始处理，这是每一个Scala程序的强制程序入口部分。(类似于Java)</p></blockquote><h4 id="二、标识符"><a href="#二、标识符" class="headerlink" title="二、标识符"></a>二、标识符</h4><blockquote><p>避免使用$开头的标识符</p></blockquote><blockquote><p>避免使用下划线结尾的标识符</p></blockquote><p><strong>混合标识符</strong>：例如unary_+</p><p><strong>字面标识符</strong>：例如<code>x`</code>yield`</p><p><strong><em>在Scala中不能使用Thread.yield(),必须使用Thread.<code>yield</code>();</em></strong></p><h4 id="三、包"><a href="#三、包" class="headerlink" title="三、包"></a>三、包</h4><p>定义包<br>引用包，import语句可以出现在任何地方，而不只是文件顶部</p><p>引入包内所有成员：import java.awt._</p><p>重命名成员：import java.util.{HashMap =&gt; JavaHashMap}</p><p>隐藏成员：import java.util.{HashMap =&gt; _, _}</p><p><strong><em>默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._，这里也能解释，为什么以scala开头的包，在使用时都是省去scala.的。</em></strong></p><h4 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h4><p>Unit<br>Null<br>Nothing<br>Any<br>AnyRef</p><p>符号字面量<br>字符字面量 ‘wangsir’<br>字符串字面量 “Hello World!”<br>多行字符串<br>    val foo = “”” Hello<br>        World!<br>        Scala<br>    “””</p><h4 id="五、变量"><a href="#五、变量" class="headerlink" title="五、变量"></a>五、变量</h4><p>var 声明变量</p><p>val 声明常量</p><p>变量不一定要声明类型，会有类型推断; 但是如果声明类型，必须初始化。</p><p>声明多个变量 val xmax, ymax = 100 //xmax=ymax=100<br>声明元组 val person = (“wangsir”, 27)</p><h4 id="六、访问修饰符"><a href="#六、访问修饰符" class="headerlink" title="六、访问修饰符"></a>六、访问修饰符</h4><blockquote><p>private：比Java更严格，在嵌套类情况下，外部类甚至不能访问嵌套类的私有成员</p></blockquote><blockquote><p>protected：比Java更严格，只允许在该类的子类中被访问</p></blockquote><blockquote><p>public：和Java不同，Scala默认访问为public</p></blockquote><p>作用域保护：private[x] protected[x]</p><h4 id="七、"><a href="#七、" class="headerlink" title="七、"></a>七、</h4><p>Scala不支持break或continue语句，但是2.8版本后提供了一种中断循环</p><p>1、字符串<br>Scala本身没有String类，所以Scala中的String类实际上是Java String</p><pre><code>API：str1.concat(str2)</code></pre><p>2、数组:<br>var z:Array[String] = new Array<a href="3">String</a><br>var z = new Array<a href="3">String</a><br>var z = Array(“”,””,””)<br>区间数组：var z = range(10, 20, 2)</p><p>for(a &lt;- array)<br>for(i &lt;- 0 to (array.length-1))</p><p>3、集合(类似于Java、Python)</p><p>List:</p><p>Set:</p><p>Map:</p><p>元组: var x = (10, “”)</p><p>Option:Option有两个子类(Some、None) var x:Option[Int] = Some(5)</p><p>Iterator:</p><p>4、模式匹配，类似于Java中的switch<br>x match {case Any =&gt; Any}</p><h4 id="八、函数"><a href="#八、函数" class="headerlink" title="八、函数"></a>八、函数</h4><p><strong>函数传名调用</strong>：传名调用，传值调用</p><p><strong>内嵌函数</strong></p><p><strong>偏应用函数</strong></p><p>递归函数</p><p><strong>高阶函数</strong>：允许使用其他函数作为参数/返回值 def f1(f2(), arg) = f2();</p><p><strong>匿名函数</strong>：<br><code>var inc = (x:Int) =&gt; x+1; var print = () =&gt; {System.getProperty(&quot;&quot;)}</code></p><p><strong>函数柯里化</strong></p><p>闭包**：</p><h4 id="九、对象、类、特征"><a href="#九、对象、类、特征" class="headerlink" title="九、对象、类、特征"></a>九、对象、类、特征</h4><p>1、继承</p><blockquote><p>1、重写一个非抽象方法必须使用override修饰符。</p><p>2、只有主构造函数才可以往基类的构造函数里写参数。</p><p>3、在子类中重写超类的抽象方法时，你不需要使用override关键字。</p></blockquote><p><strong><em>Scala没有static</em></strong></p><p>Scala定义单利模式时，需要在同一个源文件中定义一个类(伴生类)，和一个同名的object对象(伴生对象),类和对象可以互相访问其私有成员</p><p>2、特征：相当于Java的接口，不同的是特征可以定义属性和方法的实现，所以更像Java的抽象类<br>特征也有构造器</p><p>构造器的执行顺序：</p><blockquote><p>调用超类的构造器；</p><p>特征构造器在超类构造器之后、类构造器之前执行；</p><p>特征由左到右被构造；</p><p>每个特征当中，父特征先被构造；</p><p>如果多个特征共有一个父特征，父特征不会被重复构造</p><p>所有特征被构造完毕，子类被构造。</p></blockquote><p>3、样例类，用于模式匹配</p><p><code>case class Person(name: String, age: Int)</code></p><p>在声明样例类时，下面的过程自动发生了：</p><blockquote><p>构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做；</p><p>在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象；</p><p>提供unapply方法使模式匹配可以工作；</p><p>生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。</p></blockquote><p>4、提取器：从传递的对象中提出构造该对象的参数<br>apply<br>unapply</p><h4 id="十、异常"><a href="#十、异常" class="headerlink" title="十、异常"></a>十、异常</h4><p>和Java类似</p><h4 id="十一、web框架"><a href="#十一、web框架" class="headerlink" title="十一、web框架"></a>十一、web框架</h4><p>Lift框架<br>Play框架</p>]]></content>
      
      
      
        <tags>
            
            <tag> Scala, 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派系统搭建踩坑</title>
      <link href="/2018/04/26/raspberry-base/"/>
      <url>/2018/04/26/raspberry-base/</url>
      
        <content type="html"><![CDATA[<h3 id="一、安装树莓派系统"><a href="#一、安装树莓派系统" class="headerlink" title="一、安装树莓派系统"></a>一、安装树莓派系统</h3><p>1、SDFormatter格式化优盘</p><p>2、win32Disk写入镜像</p><p>3、pi用户登录系统，pi/raspberry</p><a id="more"></a><h3 id="二、修改键盘布局-因为树莓派默认英国键盘布局，会导致出错"><a href="#二、修改键盘布局-因为树莓派默认英国键盘布局，会导致出错" class="headerlink" title="二、修改键盘布局(因为树莓派默认英国键盘布局，会导致出错"></a>二、修改键盘布局(因为树莓派默认英国键盘布局，会导致出错</h3><pre><code>sudo raspi-config</code></pre><blockquote><ol><li>Locals Options</li></ol></blockquote><blockquote><ol start="2"><li>Choose Keyword Layout</li></ol></blockquote><blockquote><ol start="3"><li>Generic 104-key PC #键盘101布局和104布局</li></ol></blockquote><blockquote><ol start="4"><li>English(US, alternative international)</li></ol></blockquote><p>重启系统</p><pre><code>reboot</code></pre><h3 id="三、设置远程登录，使用xshell操作"><a href="#三、设置远程登录，使用xshell操作" class="headerlink" title="三、设置远程登录，使用xshell操作"></a>三、设置远程登录，使用xshell操作</h3><p>开启22号端口<br>    sudo raspi-config</p><blockquote><p>1、Advanced Options</p></blockquote><blockquote><p>2、SSH Enable</p></blockquote><p>树莓派默认pi用户，开启root用户<br>    sudo passwd root</p><pre><code>sudo passwd --unlock rootsu root</code></pre><p>设置允许root用户远程登录系统</p><pre><code>vi /etc/ssh/sshd_config</code></pre><blockquote><p>PermitRootLogin yes</p></blockquote><pre><code>reboot</code></pre><h3 id="四、配置WiFi"><a href="#四、配置WiFi" class="headerlink" title="四、配置WiFi"></a>四、配置WiFi</h3><pre><code>su rootvi /etc/wpa_supplicant/wpa_supplicant.conf</code></pre><blockquote><p>network={</p><pre><code>ssid=&quot;wifi名称&quot;psk=&quot;wifi密码&quot;</code></pre><p>}</p></blockquote><p>重启查看网络</p><pre><code>rebootifconfig wlan0</code></pre><h3 id="五、卸载系统自带vim，安装vim-自带vim上下左右键盘为ABCD"><a href="#五、卸载系统自带vim，安装vim-自带vim上下左右键盘为ABCD" class="headerlink" title="五、卸载系统自带vim，安装vim(自带vim上下左右键盘为ABCD)"></a>五、卸载系统自带vim，安装vim(自带vim上下左右键盘为ABCD)</h3><pre><code>apt-get remove vim-commonapt-get install vim</code></pre><h3 id="六、修改镜像源"><a href="#六、修改镜像源" class="headerlink" title="六、修改镜像源"></a>六、修改镜像源</h3><p>vi /etc/apt/sources.list</p><p>deb <a href="http://mirrors.aliyun.com/raspbian/raspbian/" target="_blank" rel="noopener">http://mirrors.aliyun.com/raspbian/raspbian/</a> stretch main contrib non-free rpi<br>deb-src <a href="http://mirrors.aliyun.com/raspbian/raspbian/" target="_blank" rel="noopener">http://mirrors.aliyun.com/raspbian/raspbian/</a> stretch main contrib non-free rpi </p><pre><code>vi /etc/apt/sources.list.d/raspi.list</code></pre><p>更新源</p><pre><code>sudo apt-get updatesudo apt-get upgrade -y</code></pre>]]></content>
      
      
      <categories>
          
          <category> raspberry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/02/hello-world/"/>
      <url>/2018/03/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>“间歇性踌躇满志，持续性混吃等死”，在这条路上见过了太多太多的大佬，默默的做一个小码农，当然能够有点产出是最好的:)<br>博客间歇式更新</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=444267928&auto=1&height=66"></iframe><h2 id="计划："><a href="#计划：" class="headerlink" title="计划："></a>计划：</h2><p>2019主线目标：造轮子</p><a id="more"></a><h2 id="Hexo搭建博客"><a href="#Hexo搭建博客" class="headerlink" title="Hexo搭建博客"></a>Hexo搭建博客</h2><p><a href="https://github.com/theme-next/hexo-theme-next.git" target="_blank" rel="noopener">Hexo GitHub仓库</a></p><p>1、新建博客</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="built_in">new</span> <span class="string">"My New Post"</span>/hexo <span class="built_in">new</span> <span class="built_in">post</span> hello-world</span><br></pre></td></tr></table></figure><p>详情: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><p>2、生成草稿</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="type">draft</span> hello-world</span><br></pre></td></tr></table></figure><p>3、发布草稿</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [post] hello-world</span><br></pre></td></tr></table></figure><p>4、生成静态文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate/hexo g</span><br></pre></td></tr></table></figure><p>详情: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><p>5、运行服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo </span><br><span class="line">$ hexo server/hexo s</span><br></pre></td></tr></table></figure><p>详情: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><p>6、发布博客到github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy/hexo d</span><br></pre></td></tr></table></figure><p>详情: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h2 id="优化博客"><a href="#优化博客" class="headerlink" title="优化博客"></a>优化博客</h2><p>1、修改主题</p><p>采用Next</p><p>2、添加RSS，RSS迁移; 添加Search本地搜索<br>rss:<br>hexo-generator-feed插件<br>修改主题下config文件，添加 <code>rss: /atom.xml</code></p><p>search:</p><p>3、添加博客访问量PV/UV<br>两种方法：<br>1)、在<code>theme/next/layout/_partials/footer.swig</code>添加’不蒜子’js脚本、统计标签</p><p>2）、直接开启config配置</p><p>4、添加博客字数、阅读时长; 修改博客国际化<br>统计也遇到两种方法：<br>1）、hexo-wordcount插件 + 开启config + 修改post-swig添加统计</p><p>2）、hexo-symbols-count-time插件，只需要开启config即可</p><p>5、修改博文底部标签样式; 添加<code>Read more</code></p><p>修改模板 <code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将’#’换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><p>6、增加博文置顶功能<br>两种方案：<br>1）、hexo-generator-index</p><p>2）、hexo-generator-index-pin-top</p><p>找到<code>/blog/themes/next/layout/_macro/post.swig</code>文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，插入代码：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> post.top %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-thumb-tack"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>7、添加评论功能</p><p>8、修改域名</p><p>9、网站备案</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>操作都在博客根目录下进行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HEXO_BLOG</span></span><br></pre></td></tr></table></figure><p>1、安装依赖包</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">index</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>2、卸载依赖包</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">uninstall</span> hexo-generator-<span class="keyword">index</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>3、查看安装的模块</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">ls</span> <span class="params">--depth</span> 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hello </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
