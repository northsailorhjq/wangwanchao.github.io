<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wangsir&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangwanchao.wang/"/>
  <updated>2019-06-07T03:56:03.732Z</updated>
  <id>http://wangwanchao.wang/</id>
  
  <author>
    <name>wanchao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>net-nat</title>
    <link href="http://wangwanchao.wang/2019/06/07/net-nat/"/>
    <id>http://wangwanchao.wang/2019/06/07/net-nat/</id>
    <published>2019-06-07T03:56:03.000Z</published>
    <updated>2019-06-07T03:56:03.732Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis概览(一)</title>
    <link href="http://wangwanchao.wang/2019/06/07/redis-base/"/>
    <id>http://wangwanchao.wang/2019/06/07/redis-base/</id>
    <published>2019-06-06T16:25:54.000Z</published>
    <updated>2019-06-06T16:26:32.796Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Redis" scheme="http://wangwanchao.wang/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis中的跳表(二)</title>
    <link href="http://wangwanchao.wang/2019/06/07/redis-skiplist/"/>
    <id>http://wangwanchao.wang/2019/06/07/redis-skiplist/</id>
    <published>2019-06-06T16:25:35.000Z</published>
    <updated>2019-06-06T16:27:14.851Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Redis" scheme="http://wangwanchao.wang/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis哨兵机制(七)</title>
    <link href="http://wangwanchao.wang/2019/06/07/redis-election/"/>
    <id>http://wangwanchao.wang/2019/06/07/redis-election/</id>
    <published>2019-06-06T16:18:30.000Z</published>
    <updated>2019-06-06T17:58:45.458Z</updated>
    
    <content type="html"><![CDATA[<p>redis引入了哨兵机制</p><a id="more"></a><h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><p>启动哨兵机制，可以对主从数据库进行监控</p><h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><p>启动多个哨兵(建议3个，并且使用奇数个哨兵)，可以对主从数据库进行监控，哨兵之间也可以互相通信。<br>哨兵主要功能：</p><ol><li>监控：监控master和slave是否运行正常</li><li>提醒：某个redis出现故障，可以发起通知</li><li>自动故障转移：当一个master不能正常工作时，将master下其中一个slave转为master</li></ol><p>补充：为什么哨兵至少3个？</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个哨兵会向其它哨兵、master、slave定时发送消息，保持心跳。如果指定时间未回应，则认为对方<strong>主观下线</strong>；若多数哨兵都认为某一服务没响应，则认为<strong>客观下线</strong></p><h2 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h2><p>用于接收master是否下线的消息</p><h2 id="选举master协议"><a href="#选举master协议" class="headerlink" title="选举master协议"></a>选举master协议</h2><p>用来决定是否执行故障转移，以及slave中的选主<br>选主会有两个过程：</p><h3 id="Sentinel哨兵选出leader"><a href="#Sentinel哨兵选出leader" class="headerlink" title="Sentinel哨兵选出leader"></a>Sentinel哨兵选出leader</h3><p>当某个哨兵节点确认master主管下线后，发出广播请求其它哨兵选举自己为leader，<br>被请求的哨兵如果没有选举过其它哨兵的请求，则同意该请求，否则不同意<br>当哨兵节点票数达到Max(quorum, num(sentinel)/2 + 1)，则升级为leader</p><h3 id="Sentinel-Leader选举主节点master"><a href="#Sentinel-Leader选举主节点master" class="headerlink" title="Sentinel Leader选举主节点master"></a>Sentinel Leader选举主节点master</h3><p>master选举：</p><image src="https://impwang.oss-cn-beijing.aliyuncs.com/redis/redis-leader.png"><p>slave-priority在conf中配置</p></image>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis引入了哨兵机制&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://wangwanchao.wang/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>etcd-raft</title>
    <link href="http://wangwanchao.wang/2019/06/06/etcd-raft/"/>
    <id>http://wangwanchao.wang/2019/06/06/etcd-raft/</id>
    <published>2019-06-06T15:05:56.000Z</published>
    <updated>2019-06-06T15:05:56.093Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ZooKeeper基于TCP的FastLeader(四)</title>
    <link href="http://wangwanchao.wang/2019/06/06/zk-fastleader3/"/>
    <id>http://wangwanchao.wang/2019/06/06/zk-fastleader3/</id>
    <published>2019-06-06T05:57:58.000Z</published>
    <updated>2019-06-06T08:25:41.664Z</updated>
    
    <content type="html"><![CDATA[<p>TCP选举算法</p><a id="more"></a><h2 id="核心结构"><a href="#核心结构" class="headerlink" title="核心结构"></a>核心结构</h2><h3 id="myid"><a href="#myid" class="headerlink" title="myid"></a>myid</h3><p>对应服务器在集群中的唯一ID</p><h3 id="zxid"><a href="#zxid" class="headerlink" title="zxid"></a>zxid</h3><p>类似于事务ID，顺序递增</p><p>|  高32位  |  低32位  |<br>epoch_h：用于标记leader的epoch，从1开始，每次选举出新的leader<br>，epoch_h加1，</p><p>epoch_l：用于标记epoch_h内的版本，epoch_h改变后，epoch_l会被重置</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>服务器状态：<br>looking：<br>leading：<br>following：<br>observing:</p><h3 id="选票数据结构"><a href="#选票数据结构" class="headerlink" title="选票数据结构"></a>选票数据结构</h3><p>选举领导时会进行投票，投票的数据结构：</p><p>logicClock: 表示该服务器发起的是第几轮投票，每个服务器都维护一个自增的logicClock<br>state: 当前服务器状态<br>self_id: 当前服务器的myid<br>self_zxid: zxid<br>vote_id: 被推选的的服务器的myid<br>vote_zxid: 被推选的服务器zxid</p><h2 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h2><p>选举过程很重要，也很复杂，做了一个流程图，不合理的回头补充：</p><image src="https://impwang.oss-cn-beijing.aliyuncs.com/zookeeper/FastLeaderElection%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86.png"><p>投票过程数据结构: (logicClock, myid, zxid)<br>投票箱存储结构：(投票服务器id, 被推选服务器id)</p></image>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP选举算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="ZooKeeper" scheme="http://wangwanchao.wang/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper选举算法基础(三)</title>
    <link href="http://wangwanchao.wang/2019/06/06/zk-select-base/"/>
    <id>http://wangwanchao.wang/2019/06/06/zk-select-base/</id>
    <published>2019-06-06T05:52:31.000Z</published>
    <updated>2019-06-06T05:56:54.259Z</updated>
    
    <content type="html"><![CDATA[<p>选举算法有多种</p><a id="more"></a><h2 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h2><p>electionAlg配置：</p><ol><li>0：基于UDP的LeaderElection</li><li>1：基于UDP的FastLeaderElection</li><li>2：基于UDP和认证的FastLeaderElection</li><li>3：基于TCP的FastLeaderElection(新版本默认算法)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;选举算法有多种&lt;/p&gt;
    
    </summary>
    
    
      <category term="ZooKeeper" scheme="http://wangwanchao.wang/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper选举过程(五)</title>
    <link href="http://wangwanchao.wang/2019/06/06/zk-crash-select/"/>
    <id>http://wangwanchao.wang/2019/06/06/zk-crash-select/</id>
    <published>2019-06-06T05:36:56.000Z</published>
    <updated>2019-06-06T08:26:21.367Z</updated>
    
    <content type="html"><![CDATA[<p>zk集群有正常启动过程，也会有leader/follower崩溃重启、网络分区问题，这样就导致需要重新选举</p><a id="more"></a><h2 id="正常集群启动选举"><a href="#正常集群启动选举" class="headerlink" title="正常集群启动选举"></a>正常集群启动选举</h2><h2 id="Leader重启选举"><a href="#Leader重启选举" class="headerlink" title="Leader重启选举"></a>Leader重启选举</h2><p>leader由于故障崩溃、或者网络分区导致不可连接。<br>选举流程图：</p><image src="https://impwang.oss-cn-beijing.aliyuncs.com/zookeeper/leader-2.png"><h2 id="Follower重启选举"><a href="#Follower重启选举" class="headerlink" title="Follower重启选举"></a>Follower重启选举</h2><p>follower由于故障崩溃、或者网络分区导致不可连接。<br>选举流程图：</p><image src="https://impwang.oss-cn-beijing.aliyuncs.com/zookeeper/leader-3.png"></image></image>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zk集群有正常启动过程，也会有leader/follower崩溃重启、网络分区问题，这样就导致需要重新选举&lt;/p&gt;
    
    </summary>
    
    
      <category term="ZooKeeper" scheme="http://wangwanchao.wang/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper分布式锁(六)</title>
    <link href="http://wangwanchao.wang/2019/06/06/zk-lock/"/>
    <id>http://wangwanchao.wang/2019/06/06/zk-lock/</id>
    <published>2019-06-06T05:36:37.000Z</published>
    <updated>2019-06-06T08:44:38.258Z</updated>
    
    <content type="html"><![CDATA[<p>zk典型的应用是可以作为分布式锁。</p><a id="more"></a><h2 id="zk分布式锁的特性"><a href="#zk分布式锁的特性" class="headerlink" title="zk分布式锁的特性"></a>zk分布式锁的特性</h2><p>zk作为分布式锁主要利用的还是临时节点、顺序性的特性</p><ol><li>最多只有一个获取锁：最多只有一个进程获取锁</li><li>释放锁：获取锁的进程可以主动释放锁；进程宕机后也可以释放锁</li><li>锁重入：获取锁的进程在释放锁之前可以重新进入</li><li>感知释放锁：等待锁的进程可以感知到锁的释放，并且重新竞争锁</li></ol><h2 id="锁实现"><a href="#锁实现" class="headerlink" title="锁实现"></a>锁实现</h2><h3 id="公平式锁"><a href="#公平式锁" class="headerlink" title="公平式锁"></a>公平式锁</h3><p>基于临时节点 + 顺序性，这样创建相同的节点时，都可以创建成功，但是节点具有顺序性，每个获取锁的进程判断自己是否是最小顺序的节点来获取锁</p><h3 id="非公平式锁"><a href="#非公平式锁" class="headerlink" title="非公平式锁"></a>非公平式锁</h3><p>基于临时节点 + 非顺序性，这样创建相同的节点时，只能有一个创建成功，即获得锁</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zk典型的应用是可以作为分布式锁。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ZooKeeper" scheme="http://wangwanchao.wang/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>netty-transport</title>
    <link href="http://wangwanchao.wang/2019/06/05/netty-transport/"/>
    <id>http://wangwanchao.wang/2019/06/05/netty-transport/</id>
    <published>2019-06-05T05:39:33.000Z</published>
    <updated>2019-06-05T05:39:33.210Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netty-codec</title>
    <link href="http://wangwanchao.wang/2019/06/05/netty-codec/"/>
    <id>http://wangwanchao.wang/2019/06/05/netty-codec/</id>
    <published>2019-06-05T05:39:20.000Z</published>
    <updated>2019-06-05T05:39:20.564Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Netty概览(一)</title>
    <link href="http://wangwanchao.wang/2019/06/05/netty-base/"/>
    <id>http://wangwanchao.wang/2019/06/05/netty-base/</id>
    <published>2019-06-05T04:25:13.000Z</published>
    <updated>2019-06-05T05:37:17.319Z</updated>
    
    <content type="html"><![CDATA[<p>基于Netty4.1分支，可以看到代码已经非常复杂</p><a id="more"></a><p>netty结构图<br>基础部分：</p><image width="200" height="300" src="https://impwang.oss-cn-beijing.aliyuncs.com/netty/netty-base1.png"><p>test组件：</p><image width="250" height="100" src="https://impwang.oss-cn-beijing.aliyuncs.com/netty/netty-base2.png"><p>transport组件：</p><image width="250" height="100" src="https://impwang.oss-cn-beijing.aliyuncs.com/netty/netty-base3.png"><h2 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h2><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p>示意图：</p><p>Reactor模型主要有2部分：</p><blockquote><p>Reactor：单独的线程，负责监听、分发事件，<br>Handlers：</p></blockquote><h4 id="1-单Reactor、单线程"><a href="#1-单Reactor、单线程" class="headerlink" title="1. 单Reactor、单线程"></a>1. 单Reactor、单线程</h4><h4 id="2-单Reactor、多线程"><a href="#2-单Reactor、多线程" class="headerlink" title="2. 单Reactor、多线程"></a>2. 单Reactor、多线程</h4><h4 id="3-主从Reactor、多线程"><a href="#3-主从Reactor、多线程" class="headerlink" title="3. 主从Reactor、多线程"></a>3. 主从Reactor、多线程</h4><p>模型：</p><blockquote><p>MainReactor：负责连接请求，把请求转交给SubReactor<br>SubReactor：负责相应Channel的I/O读写请求<br>非I/O请求则直接写入队列，等待worker threads(工作线程)处理</p></blockquote><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>传输服务，支持 BIO 和 NIO。<br>容器集成，支持 OSGI、JBossMC、Spring、Guice 容器。<br>协议支持，HTTP、Protobuf、二进制、文本、WebSocket、RTSP等，还支持通过实行编码解码逻辑来实现自定义协议。<br>Core 核心，可扩展事件模型、通用通信 API、支持零拷贝的 ByteBuf 缓冲对象。</p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>Netty基于主从Reactor、多线程模型。</p><blockquote><p>bossGroup：线程池，在绑定某个端口后，从线程池获取一个线程处理Accept事件(相当于MainReactor)，这样每个端口对应一个Boss线程<br>workerGroup：线程池，SubReactor和Worker线程会共用该线程池</p></blockquote><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>Bootstrap/ServerBootstrap<br>Future/ChannelFuture<br>Channel/ChannelHandler/ChannelPipline<br>Selector<br>NioEventLoop/NioEventLoopGroup</p><p>总结：从结构上看，核心功能主要有2个：</p><ol><li>I/O模型</li><li>解析协议(编码/解码)</li></ol></image></image></image>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于Netty4.1分支，可以看到代码已经非常复杂&lt;/p&gt;
    
    </summary>
    
    
      <category term="netty" scheme="http://wangwanchao.wang/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis概览(一)</title>
    <link href="http://wangwanchao.wang/2019/06/04/mybatis-base/"/>
    <id>http://wangwanchao.wang/2019/06/04/mybatis-base/</id>
    <published>2019-06-04T12:30:05.000Z</published>
    <updated>2019-06-04T16:42:43.138Z</updated>
    
    <content type="html"><![CDATA[<p>终究还是要自己来分析源码了，网上有很多MyBatis的源码分析，自己决定做，一来是加深印象；二来摸索源码分析的方法论。很多时候看源码一脸懵逼，不知道该从哪里看，看完没有形成思路。</p><a id="more"></a><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>mybatis结构图：</p><p><img width="200" height="300" src="https://impwang.oss-cn-beijing.aliyuncs.com/mybatis/mybatis-arc.png"></p><p>在我看来mybatis核心功能主要有3个：<br>1、xml/注解的解析(包括config配置、mapper)<br>2、一级缓存，二级缓存<br>3、事务</p><h2 id="MyBatis和Spring整合"><a href="#MyBatis和Spring整合" class="headerlink" title="MyBatis和Spring整合"></a>MyBatis和Spring整合</h2><p>mybatis和Spring整合插件结构图：</p><p><img width="200" height="300" src="https://impwang.oss-cn-beijing.aliyuncs.com/mybatis/mybatis-spring.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终究还是要自己来分析源码了，网上有很多MyBatis的源码分析，自己决定做，一来是加深印象；二来摸索源码分析的方法论。很多时候看源码一脸懵逼，不知道该从哪里看，看完没有形成思路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MyBatis" scheme="http://wangwanchao.wang/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis缓存(三)</title>
    <link href="http://wangwanchao.wang/2019/06/04/mybatis-cache/"/>
    <id>http://wangwanchao.wang/2019/06/04/mybatis-cache/</id>
    <published>2019-06-04T12:28:52.000Z</published>
    <updated>2019-06-04T16:26:53.125Z</updated>
    
    <content type="html"><![CDATA[<p>mybatis分为一级缓存、二级缓存</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mybatis分为一级缓存、二级缓存&lt;/p&gt;
    
    </summary>
    
    
      <category term="MyBatis" scheme="http://wangwanchao.wang/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis中的事务管理(五)</title>
    <link href="http://wangwanchao.wang/2019/06/04/mybatis-transaction/"/>
    <id>http://wangwanchao.wang/2019/06/04/mybatis-transaction/</id>
    <published>2019-06-04T12:28:37.000Z</published>
    <updated>2019-06-04T16:28:33.241Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="MyBatis" scheme="http://wangwanchao.wang/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>微服务--服务编排</title>
    <link href="http://wangwanchao.wang/2019/06/03/servicemesh-serverless/"/>
    <id>http://wangwanchao.wang/2019/06/03/servicemesh-serverless/</id>
    <published>2019-06-03T03:42:30.000Z</published>
    <updated>2019-06-03T06:32:14.539Z</updated>
    
    <content type="html"><![CDATA[<p>服务编排</p><a id="more"></a><h2 id="Dubbo-SpringCloud"><a href="#Dubbo-SpringCloud" class="headerlink" title="Dubbo/SpringCloud"></a>Dubbo/SpringCloud</h2><h2 id="ServiceMesh"><a href="#ServiceMesh" class="headerlink" title="ServiceMesh"></a>ServiceMesh</h2><p>服务网格</p><p>Linkerd/Envoy</p><p>Istio</p><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><p>无服务器架构</p><p>Knative</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务编排&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Maven依赖冲突问题</title>
    <link href="http://wangwanchao.wang/2019/06/03/maven-conflict/"/>
    <id>http://wangwanchao.wang/2019/06/03/maven-conflict/</id>
    <published>2019-06-03T02:45:33.000Z</published>
    <updated>2019-06-03T06:36:43.132Z</updated>
    
    <content type="html"><![CDATA[<p>maven依赖冲突</p><a id="more"></a><h3 id="冲突分类："><a href="#冲突分类：" class="headerlink" title="冲突分类："></a>冲突分类：</h3><p>第一类Jar包问题：依赖的同一个Jar出现不同的版本。<br>第二类Jar包问题：同样的类Class出现在多个不同的Jar包中。</p><h3 id="冲突原因："><a href="#冲突原因：" class="headerlink" title="冲突原因："></a>冲突原因：</h3><p>maven的依赖机制：<br>优先按照依赖管理<dependencymanagement>元素中指定的版本声明进行仲裁，此时下面的两个原则都无效了<br>若无版本声明，则按照“短路径优先”的原则（Maven2.0）进行仲裁，即选择依赖树中路径最短的版本<br>若路径长度一致，则按照“第一声明优先”的原则进行仲裁，即选择POM中最先声明的版本</dependencymanagement></p><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><h4 id="1、依赖管理"><a href="#1、依赖管理" class="headerlink" title="1、依赖管理"></a>1、依赖管理</h4><p>针对第一类冲突<br>方法1）通过<excludes>排除传递依赖<br>方法2）使用<dependencymanagement>对依赖包统一版本管理</dependencymanagement></excludes></p><h3 id="2、冲突检测插件"><a href="#2、冲突检测插件" class="headerlink" title="2、冲突检测插件"></a>2、冲突检测插件</h3><p>针对第二类冲突<br>maven-enforcer-plugin插件 + extra-enforcer-rules工具，注意：应用在子模块上，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;maven依赖冲突&lt;/p&gt;
    
    </summary>
    
    
      <category term="Maven" scheme="http://wangwanchao.wang/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>断路器hystrix</title>
    <link href="http://wangwanchao.wang/2019/06/03/architecture-hystrix/"/>
    <id>http://wangwanchao.wang/2019/06/03/architecture-hystrix/</id>
    <published>2019-06-03T02:18:27.000Z</published>
    <updated>2019-06-04T13:09:44.530Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统--异常控制流</title>
    <link href="http://wangwanchao.wang/2019/06/01/csapp-exception/"/>
    <id>http://wangwanchao.wang/2019/06/01/csapp-exception/</id>
    <published>2019-06-01T15:47:09.000Z</published>
    <updated>2019-06-03T02:19:28.580Z</updated>
    
    <content type="html"><![CDATA[<p>异常</p><a id="more"></a><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>异常控制流：现代系统通过使控制流发生突变来对这些情况做出反应，这些突变称为异常控制流。</p><p>异常：控制流中的突变。一部分由硬件实现，一部分由操作系统实现。</p><p>异常号：系统中可能的每种类型的异常都分配了一个唯一的非负整数，称为异常号。</p><blockquote><p>其中一些异常号由CPU设计中分配。例如：被零除、缺页、内存访问违例、断点、算术运算溢出<br>其它号码由操作系统内核的设计者分配。例如：系统调用、来自外部I/O设备的信号</p></blockquote><p>异常表：系统启动时，分配和初始化一张跳转表，称为异常表。表中维护了异常号-异常处理程序地址的关系。异常表的起始地址放在一个‘异常表基址寄存器’的特殊CPU寄存器内。</p><h3 id="异常种类"><a href="#异常种类" class="headerlink" title="异常种类"></a>异常种类</h3><table><thead><tr><th>类别</th><th style="text-align:center">原因</th><th style="text-align:center">异步/同步</th><th style="text-align:center">返回行为</th></tr></thead><tbody><tr><td>中断</td><td style="text-align:center">来自I/O设备的信号</td><td style="text-align:center">异步</td><td style="text-align:center">总是返回到下一条指令</td></tr><tr><td>陷阱</td><td style="text-align:center">有意的异常。</td><td style="text-align:center">同步</td><td style="text-align:center">总是返回到下一条指令</td></tr><tr><td>故障</td><td style="text-align:center">潜在的可恢复的错误</td><td style="text-align:center">同步</td><td style="text-align:center">可能返回到当前指令</td></tr><tr><td>终止</td><td style="text-align:center">不可恢复的错误</td><td style="text-align:center">同步</td><td style="text-align:center">不会返回</td></tr></tbody></table><h4 id="故障指令"><a href="#故障指令" class="headerlink" title="故障指令"></a>故障指令</h4><p>陷阱(系统调用)：普通程序运行在<code>用户模式</code>，系统调用运行在<code></code>内核模式<code>，系统为用户提供了特殊的</code>syscall n`指令，用户进行系统调用时进入陷阱模式。</p><p>故障：故障是由错误引起的，如果错误可以被修复，则将控制返回到引起故障的指令；如果不可修复，则返回到内核中的abort例程，abort例程会终止引起故障的应用程序。</p><p>终止：由不可恢复的致命错误引起，通常是一些硬件错误。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>并发流：并发流的思想与流运行的CPU核数、计算机数无关。</p><p>并行流：</p><h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><p>进程间内存空间私有</p><h3 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h3><p>模式位：CPU通过设置某个寄存器的模式位，指定进程处于内核模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异常&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://wangwanchao.wang/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统--CPU</title>
    <link href="http://wangwanchao.wang/2019/06/01/csapp-cpu/"/>
    <id>http://wangwanchao.wang/2019/06/01/csapp-cpu/</id>
    <published>2019-06-01T04:27:49.000Z</published>
    <updated>2019-06-03T02:46:14.477Z</updated>
    
    <content type="html"><![CDATA[<p>决定计算机性能的3个关键因素：</p><blockquote><p>指令数目 (编译器和指令集决定)<br>时钟周期长度 (CPU决定)<br>每条指令所需要的时钟周期数 (CPU决定)</p></blockquote><a id="more"></a><h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><h3 id="1-组合单元："><a href="#1-组合单元：" class="headerlink" title="1. 组合单元："></a>1. 组合单元：</h3><h3 id="2-状态单元："><a href="#2-状态单元：" class="headerlink" title="2. 状态单元："></a>2. 状态单元：</h3><p>两个输入 + 一个输出<br>    输入：<br>    写入单元的数据值<br>    决定何时写入的时钟信号</p><p>时钟方法：规定信号可以独处和写入的时间<br>    边沿触发的时钟</p><p>寄存器堆：寄存器集合，存放32个通用寄存器<br>    R型指令：<code>add $t1, $t2, $t3</code></p><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>指令执行顺序：<br>取指<br>译码<br>执行<br>访存<br>写回<br>更新PC</p><h3 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h3><ol><li><p>结构冒险</p></li><li><p>数据冒险</p></li><li><p>控制冒险(分支冒险)：</p><p> 解决方法：</p><blockquote><p>阻塞<br>预测<br>延迟决定</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;决定计算机性能的3个关键因素：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;指令数目 (编译器和指令集决定)&lt;br&gt;时钟周期长度 (CPU决定)&lt;br&gt;每条指令所需要的时钟周期数 (CPU决定)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://wangwanchao.wang/tags/CSAPP/"/>
    
  </entry>
  
</feed>
