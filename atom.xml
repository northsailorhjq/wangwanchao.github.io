<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wangsir&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangwanchao.wang/"/>
  <updated>2019-08-16T03:29:52.528Z</updated>
  <id>http://wangwanchao.wang/</id>
  
  <author>
    <name>wanchao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Serverless是什么</title>
    <link href="http://wangwanchao.wang/2019/08/16/serverless-base/"/>
    <id>http://wangwanchao.wang/2019/08/16/serverless-base/</id>
    <published>2019-08-16T01:15:50.000Z</published>
    <updated>2019-08-16T03:29:52.528Z</updated>
    
    <content type="html"><![CDATA[<p>Serverless是什么？很多地方看到serverless的文章，官方文档说：首先是一个框架。包含多个微服务的应用；事件响应，自动扩容；仅仅在运行时收费，更高于云服务平台。</p><a id="more"></a><p>从IaaS， 到SaaS，再到Paas。重新提出一种新的架构FaaS</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>阿里云也有在做，以下以AWS为例。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>中间需要用到AWS账号，没有账号的需要申请。</p><h3 id="创建AWS账号"><a href="#创建AWS账号" class="headerlink" title="创建AWS账号"></a>创建AWS账号</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Serverless是什么？很多地方看到serverless的文章，官方文档说：首先是一个框架。包含多个微服务的应用；事件响应，自动扩容；仅仅在运行时收费，更高于云服务平台。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringCloud微服务--网关</title>
    <link href="http://wangwanchao.wang/2019/08/15/spring-cloud-zuul/"/>
    <id>http://wangwanchao.wang/2019/08/15/spring-cloud-zuul/</id>
    <published>2019-08-15T08:28:03.000Z</published>
    <updated>2019-08-16T07:20:38.434Z</updated>
    
    <content type="html"><![CDATA[<p>nginx、zuul、gateway、kong都是网管组件。</p><a id="more"></a><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>nginx使用漏桶算法</p><p><code>limit_req_zone</code><br><code>limit_req_conn</code></p><h2 id="Kong"><a href="#Kong" class="headerlink" title="Kong"></a>Kong</h2><p>kong可以说是nginx的升级版，基于OpenResty。</p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ol><li>upstream</li><li>target</li><li>service</li><li>route</li></ol><h3 id="限流-1"><a href="#限流-1" class="headerlink" title="限流"></a>限流</h3><h2 id="Zuul1-Zuul2"><a href="#Zuul1-Zuul2" class="headerlink" title="Zuul1 / Zuul2"></a>Zuul1 / Zuul2</h2><h3 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h3><p>按照生命周期大约有4种过滤器：</p><ol><li><p>pre </p></li><li><p>routing</p></li><li><p>post </p></li><li><p>error</p></li></ol><h3 id="限流-2"><a href="#限流-2" class="headerlink" title="限流"></a>限流</h3><p>主流的有4种限流方式：</p><ol><li>根据认证用户</li><li>根据原始请求</li><li>根据URL</li><li>根据ServiceId</li></ol><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>zuul-ratelimit</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx、zuul、gateway、kong都是网管组件。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot配置文件加载bug</title>
    <link href="http://wangwanchao.wang/2019/08/14/spring-boot-bootstrap/"/>
    <id>http://wangwanchao.wang/2019/08/14/spring-boot-bootstrap/</id>
    <published>2019-08-14T06:16:34.000Z</published>
    <updated>2019-08-14T06:26:57.152Z</updated>
    
    <content type="html"><![CDATA[<p>IDEA环境以前曾经遇到过，通过添加依赖包可以解决，而且，创建的maven模块有时候正常，有时候出现该问题，问题的根本还是不太懂</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="未加载前"><a href="#未加载前" class="headerlink" title="未加载前"></a>未加载前</h3><p>bootstrap文件为yml格式，但是并未识别为配置文件</p><p><img src="https://impwang.oss-cn-beijing.aliyuncs.com/spring/springboot-bootstrap.png" alt></p><p>查看模块设置<code>Open Module Settings</code> - Module，发现并未自动检测，没有找到任何手动添加设置<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/spring/springboot-bootstrap2.png" alt></p><h3 id="加载后"><a href="#加载后" class="headerlink" title="加载后"></a>加载后</h3><p>添加spring-cloud-context，bootstrap文件可以被正常检测<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/spring/springboot-bootstrap3.png" alt></p><p>迷<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/spring/springboot-bootstrap4.png" alt></p><h2 id="加载原理"><a href="#加载原理" class="headerlink" title="加载原理"></a>加载原理</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IDEA环境以前曾经遇到过，通过添加依赖包可以解决，而且，创建的maven模块有时候正常，有时候出现该问题，问题的根本还是不太懂&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mac-multi-mysql</title>
    <link href="http://wangwanchao.wang/2019/08/08/mac-multi-mysql/"/>
    <id>http://wangwanchao.wang/2019/08/08/mac-multi-mysql/</id>
    <published>2019-08-08T01:55:25.000Z</published>
    <updated>2019-08-08T01:55:26.010Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络--概览</title>
    <link href="http://wangwanchao.wang/2019/08/03/net-overview/"/>
    <id>http://wangwanchao.wang/2019/08/03/net-overview/</id>
    <published>2019-08-03T03:19:10.000Z</published>
    <updated>2019-08-03T03:20:26.796Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="NetWork" scheme="http://wangwanchao.wang/tags/NetWork/"/>
    
  </entry>
  
  <entry>
    <title>瓶颈期</title>
    <link href="http://wangwanchao.wang/2019/07/30/thinking-in-bottleneck/"/>
    <id>http://wangwanchao.wang/2019/07/30/thinking-in-bottleneck/</id>
    <published>2019-07-30T02:46:07.000Z</published>
    <updated>2019-08-03T03:23:00.500Z</updated>
    
    <content type="html"><![CDATA[<p>这一段时间，我一直在思考的一个问题就是：我和别人到底差在哪里？我迷茫、困惑，陷入一个万劫不复的僵局，呆在其中，却无法突破。也许这就是所谓的瓶颈期。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一段时间，我一直在思考的一个问题就是：我和别人到底差在哪里？我迷茫、困惑，陷入一个万劫不复的僵局，呆在其中，却无法突破。也许这就是所谓的瓶颈期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="http://wangwanchao.wang/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>go--csp并发模型</title>
    <link href="http://wangwanchao.wang/2019/07/16/go-csp/"/>
    <id>http://wangwanchao.wang/2019/07/16/go-csp/</id>
    <published>2019-07-16T06:50:07.000Z</published>
    <updated>2019-07-16T07:24:26.909Z</updated>
    
    <content type="html"><![CDATA[<p>go引入了协程的概念，使用goroutine通过channel通信</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go引入了协程的概念，使用goroutine通过channel通信&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Consul环境</title>
    <link href="http://wangwanchao.wang/2019/07/03/consul-base/"/>
    <id>http://wangwanchao.wang/2019/07/03/consul-base/</id>
    <published>2019-07-03T01:33:02.000Z</published>
    <updated>2019-08-14T08:45:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>原来一直用Eureka Server，现在尝试用Consul.</p><a id="more"></a><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>brew install consul</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>consul agent -dev</code></pre><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>管理页面地址 <a href="http://127.0.0.1:8500/ui/dc1/services" target="_blank" rel="noopener">http://127.0.0.1:8500/ui/dc1/services</a></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原来一直用Eureka Server，现在尝试用Consul.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-lifecycle</title>
    <link href="http://wangwanchao.wang/2019/06/28/vue-lifecycle/"/>
    <id>http://wangwanchao.wang/2019/06/28/vue-lifecycle/</id>
    <published>2019-06-28T02:18:58.000Z</published>
    <updated>2019-06-28T02:18:58.823Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue--数据传递</title>
    <link href="http://wangwanchao.wang/2019/06/28/vue-data/"/>
    <id>http://wangwanchao.wang/2019/06/28/vue-data/</id>
    <published>2019-06-28T02:03:57.000Z</published>
    <updated>2019-06-28T02:07:25.102Z</updated>
    
    <content type="html"><![CDATA[<p>组件之间的数据传递</p><a id="more"></a><h2 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h2><h2 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h2><h2 id="Event-Bus"><a href="#Event-Bus" class="headerlink" title="Event Bus"></a>Event Bus</h2><p>可以平级传数</p><h2 id="Vuex传递"><a href="#Vuex传递" class="headerlink" title="Vuex传递"></a>Vuex传递</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组件之间的数据传递&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js-icon</title>
    <link href="http://wangwanchao.wang/2019/06/24/js-icon/"/>
    <id>http://wangwanchao.wang/2019/06/24/js-icon/</id>
    <published>2019-06-24T01:20:26.000Z</published>
    <updated>2019-06-24T01:20:26.255Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringSecurity--SAAS平台设计思路(七)</title>
    <link href="http://wangwanchao.wang/2019/06/21/spring-security-saas/"/>
    <id>http://wangwanchao.wang/2019/06/21/spring-security-saas/</id>
    <published>2019-06-21T03:49:55.000Z</published>
    <updated>2019-06-24T02:05:57.205Z</updated>
    
    <content type="html"><![CDATA[<p>最近要做一个saas平台，20171年的时候选用的是Shiro实现，考虑到SpringSecurity可以完美的整合Oauth2.0/OpenID</p><a id="more"></a><p>RBAC模型</p><h3 id="安全原则"><a href="#安全原则" class="headerlink" title="安全原则"></a>安全原则</h3><ol><li>最小权限原则</li><li>责任分离原则</li><li>数据抽象原则</li></ol><p>页面权限<br>功能权限<br>数据权限</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>用户</p><p>角色：可以按照部门、岗位、</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要做一个saas平台，20171年的时候选用的是Shiro实现，考虑到SpringSecurity可以完美的整合Oauth2.0/OpenID&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringSecurity--原理与流程(二)</title>
    <link href="http://wangwanchao.wang/2019/06/21/spring-security-flow/"/>
    <id>http://wangwanchao.wang/2019/06/21/spring-security-flow/</id>
    <published>2019-06-21T03:12:47.000Z</published>
    <updated>2019-06-21T03:18:23.636Z</updated>
    
    <content type="html"><![CDATA[<p>从启动，到权限认证过程</p><a id="more"></a><p>流程图：</p><image src></image>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从启动，到权限认证过程&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringSecurity--过滤器(三)</title>
    <link href="http://wangwanchao.wang/2019/06/21/spring-security-filter/"/>
    <id>http://wangwanchao.wang/2019/06/21/spring-security-filter/</id>
    <published>2019-06-21T03:12:01.000Z</published>
    <updated>2019-06-21T03:16:46.049Z</updated>
    
    <content type="html"><![CDATA[<p>实现权限的框架，无非都是一些filter过滤</p><a id="more"></a><p>SpringSecurity有十多种filter，</p><p>filter流程时序图：</p><image src></image>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现权限的框架，无非都是一些filter过滤&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringSecurity--整合jwt(六)</title>
    <link href="http://wangwanchao.wang/2019/06/21/spring-security-jwt/"/>
    <id>http://wangwanchao.wang/2019/06/21/spring-security-jwt/</id>
    <published>2019-06-21T03:11:21.000Z</published>
    <updated>2019-08-17T06:53:15.932Z</updated>
    
    <content type="html"><![CDATA[<p>jwt模式，web请求模式中分：有状态模无状态模式。一般基于session的就是有状态模式，基于token的是无状态模式。而jwt的token可以存储用户信息，个人认为也算是一种有状态模式。</p><a id="more"></a><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Securtiy默认是基于session会话的模式，jwt既然基于token的模式，就要关闭session。</p><h3 id="宏观上来看执行流程："><a href="#宏观上来看执行流程：" class="headerlink" title="宏观上来看执行流程："></a>宏观上来看执行流程：</h3><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>Security对SecurityContext的存储也是分session状态：</p><p>完全无session状态，可以看到SecurityContext使用<code>NullSecurityContextRepository</code>存储，每次请求创建新的上下文context。<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/security/SecurityContextPersistenceFilter00.png" alt="1"></p><p><img src="https://impwang.oss-cn-beijing.aliyuncs.com/security/SecurityContextPersistenceFilter01.png" alt="2"></p><p><img src="https://impwang.oss-cn-beijing.aliyuncs.com/security/SecurityContextPersistenceFilter03.png" alt="3"></p><p>session禁用状态，使用<code>HttpSessionSecurityContextRepository</code>存储，每次请求根据session会话获取上下文context。<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/security/SecurityContextPersistenceFilter04.png" alt></p><p><img src="https://impwang.oss-cn-beijing.aliyuncs.com/security/SecurityContextPersistenceFilter05.png" alt></p><p><code>SecurityContextRepository</code>类从名字也可看出就是一个存储仓库，对比两个不同的实现。<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/security/SecurityContextPersistenceFilter02.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jwt模式，web请求模式中分：有状态模无状态模式。一般基于session的就是有状态模式，基于token的是无状态模式。而jwt的token可以存储用户信息，个人认为也算是一种有状态模式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringSecurity--整合oauth2(五)</title>
    <link href="http://wangwanchao.wang/2019/06/21/spring-security-oauth2/"/>
    <id>http://wangwanchao.wang/2019/06/21/spring-security-oauth2/</id>
    <published>2019-06-21T03:11:03.000Z</published>
    <updated>2019-06-21T03:20:28.898Z</updated>
    
    <content type="html"><![CDATA[<p>oauth2.0有4种认证模型</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在客户端和服务端中间，设置了一个授权层，客户端不能登陆服务端，只能登录中间授权层。</p><p>第一阶段使用account + secret登录中间层，获得token</p><p>第二阶段开始使用token进行权限验证</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;oauth2.0有4种认证模型&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringSecurity--概览(一)</title>
    <link href="http://wangwanchao.wang/2019/06/21/spring-security-base/"/>
    <id>http://wangwanchao.wang/2019/06/21/spring-security-base/</id>
    <published>2019-06-21T03:07:55.000Z</published>
    <updated>2019-06-24T02:05:51.456Z</updated>
    
    <content type="html"><![CDATA[<p>权限模型</p><a id="more"></a><h2 id="权限控制模型"><a href="#权限控制模型" class="headerlink" title="权限控制模型"></a>权限控制模型</h2><h3 id="自主访问控制-DAC"><a href="#自主访问控制-DAC" class="headerlink" title="自主访问控制 DAC"></a>自主访问控制 DAC</h3><h3 id="强制访问控制-MAC"><a href="#强制访问控制-MAC" class="headerlink" title="强制访问控制 MAC"></a>强制访问控制 MAC</h3><p>通过硬件实现</p><p>场景：安全要求较高的军事系统</p><h3 id="基于角色的访问控制-RBAC"><a href="#基于角色的访问控制-RBAC" class="headerlink" title="基于角色的访问控制 RBAC"></a>基于角色的访问控制 RBAC</h3><h4 id="RBAC0-基本模型"><a href="#RBAC0-基本模型" class="headerlink" title="RBAC0 基本模型"></a>RBAC0 基本模型</h4><p>U 用户<br>R 角色<br>P 权限</p><h4 id="RBAC1-角色分级模型"><a href="#RBAC1-角色分级模型" class="headerlink" title="RBAC1 角色分级模型"></a>RBAC1 角色分级模型</h4><ol><li>一般继承关系：允许角色之间多继承关系</li><li>受限继承关系：角色继承是一个树形的单继承关系</li></ol><p>优点：<br>缺点：<br>适用场景：</p><h4 id="RBAC2-角色限制模型"><a href="#RBAC2-角色限制模型" class="headerlink" title="RBAC2 角色限制模型"></a>RBAC2 角色限制模型</h4><ol><li>静态分离：互斥的角色不能赋给同一个用户</li><li>动态分离：用户不能使用两个互斥的角色登录</li></ol><h4 id="RBAC3-统一模型"><a href="#RBAC3-统一模型" class="headerlink" title="RBAC3 统一模型"></a>RBAC3 统一模型</h4><p>用户管理角色<br>角色关联权限</p><h3 id="基于属性的访问控制-ABAC"><a href="#基于属性的访问控制-ABAC" class="headerlink" title="基于属性的访问控制 ABAC"></a>基于属性的访问控制 ABAC</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ol><li>用户属性 用户年龄</li><li>环境属性 当前时间</li><li>操作属性 读/写</li><li>资源属性 文章/图片</li></ol><h2 id="权限对象模型"><a href="#权限对象模型" class="headerlink" title="权限对象模型"></a>权限对象模型</h2><h3 id="按-分类："><a href="#按-分类：" class="headerlink" title="按  分类："></a>按  分类：</h3><p>页面权限 用户可以看到那些页面；<br>操作权限 用户可以在页面内进行那些操作，增删改查等；<br>数据权限 用户可以看到那些数据或内容；</p><h3 id="按-分类：-1"><a href="#按-分类：-1" class="headerlink" title="按  分类："></a>按  分类：</h3><p>功能权限<br>数据权限</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;权限模型&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux--零拷贝</title>
    <link href="http://wangwanchao.wang/2019/06/17/linux-zerocopy/"/>
    <id>http://wangwanchao.wang/2019/06/17/linux-zerocopy/</id>
    <published>2019-06-17T02:13:56.000Z</published>
    <updated>2019-06-17T02:23:02.181Z</updated>
    
    <content type="html"><![CDATA[<p>linux中的零拷贝技术</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>普通I/O：应用程序或者运行在用户模式下的库函数访问硬件设备时，I/O操作需要</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux中的零拷贝技术&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wangwanchao.wang/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat--类加载模型(五)</title>
    <link href="http://wangwanchao.wang/2019/06/16/tomcat-classloader/"/>
    <id>http://wangwanchao.wang/2019/06/16/tomcat-classloader/</id>
    <published>2019-06-16T04:15:30.000Z</published>
    <updated>2019-06-16T04:47:48.620Z</updated>
    
    <content type="html"><![CDATA[<p>tomcat类加载器破坏了jvm的双亲委派机制</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.catalina.startup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Daemon reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">Object</span> catalinaDaemon = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">ClassLoader commonLoader = <span class="keyword">null</span>;</span><br><span class="line">ClassLoader catalinaLoader = <span class="keyword">null</span>;</span><br><span class="line">ClassLoader sharedLoader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> initClassLoaders() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        commonLoader = createClassLoader(<span class="string">"common"</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (commonLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// no config file, default to this loader - we might be in a 'single' env.</span></span><br><span class="line">            commonLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        catalinaLoader = createClassLoader(<span class="string">"server"</span>, commonLoader);</span><br><span class="line">        sharedLoader = createClassLoader(<span class="string">"shared"</span>, commonLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleThrowable(t);</span><br><span class="line">        <span class="built_in">log</span>.error(<span class="string">"Class loader creation threw exception"</span>, t);</span><br><span class="line">        System.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类加载器</th><th style="text-align:center">tomcat可见性</th><th style="text-align:center">webapp可见性</th></tr></thead><tbody><tr><td>commonLoader</td><td style="text-align:center">可见</td><td style="text-align:center">可见</td></tr><tr><td>catalinaLoader</td><td style="text-align:center">可见</td><td style="text-align:center">不可见</td></tr><tr><td>sharedLoader</td><td style="text-align:center">不可见</td><td style="text-align:center">可见</td></tr><tr><td>WebappClassLoader</td><td style="text-align:center">不可见</td><td style="text-align:center">只对当前web可见</td></tr></tbody></table><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol><li>jar类库隔离：tomcat可以部署多个应用，如果引用多个不同版本的jar，类实现不同，所以需要加载不同的jar包</li><li>jar类库共享：如果jar版本相同，则只加载一份</li><li>安全隔离：tomcat自身的类加载器和web应用的类加载器隔离</li><li>热加载：jsp修改后不需要重启也可以刷新，这样就需要动态加载jsp文件</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tomcat类加载器破坏了jvm的双亲委派机制&lt;/p&gt;
    
    </summary>
    
    
      <category term="tomcat" scheme="http://wangwanchao.wang/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>java-jmx</title>
    <link href="http://wangwanchao.wang/2019/06/16/java-jmx/"/>
    <id>http://wangwanchao.wang/2019/06/16/java-jmx/</id>
    <published>2019-06-16T04:04:45.000Z</published>
    <updated>2019-06-16T04:04:45.112Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
